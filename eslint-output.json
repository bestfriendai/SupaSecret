[{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useDataIntegrityMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useDynamicType.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":264,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":264,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from \"react\";\nimport { AccessibilityInfo, PixelRatio } from \"react-native\";\n\nexport interface DynamicTypeSettings {\n  fontScale: number;\n  isBoldTextEnabled: boolean;\n  isReduceMotionEnabled: boolean;\n  isScreenReaderEnabled: boolean;\n}\n\nexport interface ScaledFontSizes {\n  xs: number;\n  sm: number;\n  base: number;\n  lg: number;\n  xl: number;\n  \"2xl\": number;\n  \"3xl\": number;\n  \"4xl\": number;\n  \"5xl\": number;\n}\n\n// Base font sizes (in points)\nconst BASE_FONT_SIZES = {\n  xs: 12,\n  sm: 14,\n  base: 16,\n  lg: 18,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 30,\n  \"4xl\": 36,\n  \"5xl\": 48,\n};\n\n/**\n * Hook for supporting dynamic type and accessibility preferences\n * Automatically scales fonts and adjusts UI based on user preferences\n */\nexport const useDynamicType = () => {\n  const [settings, setSettings] = useState<DynamicTypeSettings>({\n    fontScale: PixelRatio.getFontScale(),\n    isBoldTextEnabled: false,\n    isReduceMotionEnabled: false,\n    isScreenReaderEnabled: false,\n  });\n\n  useEffect(() => {\n    const loadAccessibilitySettings = async () => {\n      try {\n        const [isBoldTextEnabled, isReduceMotionEnabled, isScreenReaderEnabled] = await Promise.all([\n          // Feature-detect accessibility APIs before calling\n          AccessibilityInfo.isBoldTextEnabled?.() ?? Promise.resolve(false),\n          AccessibilityInfo.isReduceMotionEnabled?.() ?? Promise.resolve(false),\n          AccessibilityInfo.isScreenReaderEnabled?.() ?? Promise.resolve(false),\n        ]);\n\n        setSettings((prev) => ({\n          ...prev,\n          isBoldTextEnabled,\n          isReduceMotionEnabled,\n          isScreenReaderEnabled,\n        }));\n      } catch (error) {\n        if (__DEV__) {\n          console.warn(\"Failed to load accessibility settings:\", error);\n        }\n      }\n    };\n\n    loadAccessibilitySettings();\n\n    // Listen for changes in accessibility settings\n    const subscriptions = [\n      AccessibilityInfo.addEventListener(\"reduceMotionChanged\", (isReduceMotionEnabled) => {\n        setSettings((prev) => ({ ...prev, isReduceMotionEnabled }));\n      }),\n      AccessibilityInfo.addEventListener(\"screenReaderChanged\", (isScreenReaderEnabled) => {\n        setSettings((prev) => ({ ...prev, isScreenReaderEnabled }));\n      }),\n      AccessibilityInfo.addEventListener(\"boldTextChanged\", (isBoldTextEnabled) => {\n        setSettings((prev) => ({ ...prev, isBoldTextEnabled }));\n      }),\n    ].filter(Boolean);\n\n    return () => {\n      subscriptions.forEach((subscription) => subscription?.remove());\n    };\n  }, []);\n\n  // Calculate scaled font sizes based on user preferences\n  const getScaledFontSizes = (): ScaledFontSizes => {\n    const scale = settings.fontScale;\n    const finalScale = scale;\n\n    return Object.entries(BASE_FONT_SIZES).reduce((acc, [key, size]) => {\n      acc[key as keyof ScaledFontSizes] = Math.round(size * finalScale);\n      return acc;\n    }, {} as ScaledFontSizes);\n  };\n\n  // Get font weight based on bold text preference\n  const getFontWeight = (baseWeight: string = \"normal\"): string => {\n    if (settings.isBoldTextEnabled) {\n      switch (baseWeight) {\n        case \"normal\":\n        case \"400\":\n          return \"600\";\n        case \"medium\":\n        case \"500\":\n          return \"700\";\n        case \"semibold\":\n        case \"600\":\n          return \"700\";\n        case \"bold\":\n        case \"700\":\n          return \"800\";\n        default:\n          return \"bold\";\n      }\n    }\n    return baseWeight;\n  };\n\n  // Get animation duration based on reduce motion preference\n  const getAnimationDuration = (baseDuration: number): number => {\n    return settings.isReduceMotionEnabled ? 0 : baseDuration;\n  };\n\n  // Get spacing scale based on font scale\n  const getSpacingScale = (): number => {\n    return settings.fontScale > 1.2 ? 1.15 : 1;\n  };\n\n  // Check if text should be larger for better readability\n  const shouldUseLargerText = (): boolean => {\n    return settings.fontScale > 1.3;\n  };\n\n  // Get minimum touch target size (44pt recommended by Apple/Google)\n  const getMinTouchTargetSize = (): number => {\n    const baseSize = 44;\n    return settings.fontScale > 1.2 ? baseSize * 1.2 : baseSize;\n  };\n\n  // Get contrast ratio adjustments\n  const getContrastAdjustments = () => {\n    return {\n      // Increase contrast for better readability\n      textOpacity: settings.isScreenReaderEnabled ? 1 : 0.9,\n      borderOpacity: settings.isScreenReaderEnabled ? 1 : 0.8,\n      backgroundOpacity: settings.isScreenReaderEnabled ? 1 : 0.95,\n    };\n  };\n\n  return {\n    settings,\n    scaledFontSizes: getScaledFontSizes(),\n    getFontWeight,\n    getAnimationDuration,\n    getSpacingScale,\n    shouldUseLargerText,\n    getMinTouchTargetSize,\n    getContrastAdjustments,\n  };\n};\n\n// Utility functions for responsive design\nexport const DynamicTypeUtils = {\n  // Scale a value based on font scale\n  scaleValue: (value: number, fontScale: number): number => {\n    return Math.round(value * fontScale);\n  },\n\n  // Get responsive padding based on text size\n  getResponsivePadding: (basePadding: number, fontScale: number): number => {\n    const scale = Math.max(1, fontScale);\n    return Math.round(basePadding * scale);\n  },\n\n  // Get responsive margin based on text size\n  getResponsiveMargin: (baseMargin: number, fontScale: number): number => {\n    const scale = Math.max(1, fontScale);\n    return Math.round(baseMargin * scale);\n  },\n\n  // Calculate line height based on font size and accessibility needs\n  getLineHeight: (fontSize: number, isLargeText: boolean = false): number => {\n    const baseRatio = isLargeText ? 1.6 : 1.5;\n    return Math.round(fontSize * baseRatio);\n  },\n\n  // Get accessible color contrast with WCAG compliance\n  getAccessibleColor: (baseColor: string, backgroundColor: string, isHighContrast: boolean = false): string => {\n    // Helper function to convert hex to RGB\n    const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n      // Remove # if present and convert to lowercase\n      const cleanHex = hex.replace(/^#/, \"\").toLowerCase();\n\n      // Check for 3-digit or 6-digit hex format\n      const shortHexRegex = /^([a-f\\d])([a-f\\d])([a-f\\d])$/;\n      const longHexRegex = /^([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/;\n\n      let result = longHexRegex.exec(cleanHex);\n\n      if (!result) {\n        // Try 3-digit format and expand to 6-digit\n        const shortResult = shortHexRegex.exec(cleanHex);\n        if (shortResult) {\n          // Expand 3-digit to 6-digit (e.g., \"abc\" -> \"aabbcc\")\n          const expandedHex =\n            shortResult[1] + shortResult[1] + shortResult[2] + shortResult[2] + shortResult[3] + shortResult[3];\n          result = longHexRegex.exec(expandedHex);\n        }\n      }\n\n      return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n          }\n        : null;\n    };\n\n    // Calculate relative luminance\n    const getLuminance = (r: number, g: number, b: number): number => {\n      const [rs, gs, bs] = [r, g, b].map((c) => {\n        c = c / 255;\n        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n      });\n      return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;\n    };\n\n    // Calculate contrast ratio\n    const getContrastRatio = (lum1: number, lum2: number): number => {\n      const brightest = Math.max(lum1, lum2);\n      const darkest = Math.min(lum1, lum2);\n      return (brightest + 0.05) / (darkest + 0.05);\n    };\n\n    try {\n      const baseRgb = hexToRgb(baseColor);\n      const bgRgb = hexToRgb(backgroundColor);\n\n      if (!baseRgb || !bgRgb) {\n        // Fallback for invalid colors\n        return isHighContrast ? \"#000000\" : baseColor;\n      }\n\n      const baseLum = getLuminance(baseRgb.r, baseRgb.g, baseRgb.b);\n      const bgLum = getLuminance(bgRgb.r, bgRgb.g, bgRgb.b);\n      const contrast = getContrastRatio(baseLum, bgLum);\n\n      // WCAG AA requires 4.5:1 for normal text, 7:1 for AAA\n      const requiredContrast = isHighContrast ? 7 : 4.5;\n\n      if (contrast >= requiredContrast) {\n        return baseColor;\n      }\n\n      // If contrast is insufficient, return black or white based on background\n      return bgLum > 0.5 ? \"#000000\" : \"#FFFFFF\";\n    } catch (error) {\n      // Fallback on error\n      return isHighContrast ? \"#000000\" : baseColor;\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useFormValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useLoadingStates.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has unnecessary dependencies: 'initializeState' and 'states'. Either exclude them or remove the dependency array.","line":186,"column":5,"nodeType":"ArrayExpression","endLine":186,"endColumn":64,"suggestions":[{"desc":"Update the dependencies array to be: [setLoading, setSuccess, setError]","fix":{"range":[5926,5985],"text":"[setLoading, setSuccess, setError]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'timeoutsRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'timeoutsRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":259,"column":19,"nodeType":"Identifier","endLine":259,"endColumn":26},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'callTokensRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'callTokensRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":260,"column":21,"nodeType":"Identifier","endLine":260,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useRef, useEffect, createContext, useContext } from \"react\";\n\nexport interface LoadingState {\n  isLoading: boolean;\n  error: string | null;\n  data: any;\n  lastUpdated: number | null;\n}\n\nexport interface LoadingStates {\n  [key: string]: LoadingState;\n}\n\nexport interface LoadingOptions {\n  key: string;\n  minLoadingTime?: number; // Minimum time to show loading state (prevents flashing)\n  timeout?: number; // Timeout for the operation\n  retryCount?: number; // Number of automatic retries\n  retryDelay?: number; // Delay between retries in ms\n}\n\n/**\n * Hook for managing consistent loading states across the application\n * Provides unified loading, error, and success states with retry logic\n */\nexport const useLoadingStates = () => {\n  const [states, setStates] = useState<LoadingStates>({});\n  const timeoutsRef = useRef<Map<string, ReturnType<typeof setTimeout>>>(new Map());\n  const retriesRef = useRef<Map<string, number>>(new Map());\n  const callTokensRef = useRef<Map<string, number>>(new Map());\n  const isMountedRef = useRef(true);\n\n  // Initialize a loading state\n  const initializeState = useCallback((key: string, initialData?: any) => {\n    setStates((prev) => ({\n      ...prev,\n      [key]: {\n        isLoading: false,\n        error: null,\n        data: initialData || null,\n        lastUpdated: null,\n      },\n    }));\n  }, []);\n\n  // Set loading state\n  const setLoading = useCallback((key: string, isLoading: boolean) => {\n    if (!isMountedRef.current) return;\n\n    setStates((prev) => {\n      const existing = prev[key] ?? { isLoading: false, error: null, data: null, lastUpdated: null };\n      return {\n        ...prev,\n        [key]: {\n          ...existing,\n          isLoading,\n          error: isLoading ? null : existing.error,\n        },\n      };\n    });\n  }, []);\n\n  // Set error state\n  const setError = useCallback((key: string, error: string | null) => {\n    if (!isMountedRef.current) return;\n\n    setStates((prev) => {\n      const existing = prev[key] ?? { isLoading: false, error: null, data: null, lastUpdated: null };\n      return {\n        ...prev,\n        [key]: {\n          ...existing,\n          isLoading: false,\n          error,\n        },\n      };\n    });\n  }, []);\n\n  // Set success state with data\n  const setSuccess = useCallback((key: string, data: any) => {\n    if (!isMountedRef.current) return;\n\n    setStates((prev) => {\n      const existing = prev[key] ?? { isLoading: false, error: null, data: null, lastUpdated: null };\n      return {\n        ...prev,\n        [key]: {\n          ...existing,\n          isLoading: false,\n          error: null,\n          data,\n          lastUpdated: Date.now(),\n        },\n      };\n    });\n\n    // Clear retry count on success\n    retriesRef.current.delete(key);\n  }, []);\n\n  // Execute an async operation with loading state management\n  const executeWithLoading = useCallback(\n    async function <T>(options: LoadingOptions, operation: () => Promise<T>): Promise<T | null> {\n      const { key, minLoadingTime = 300, timeout = 30000, retryCount = 0, retryDelay = 1000 } = options;\n\n      // Generate call token to prevent race conditions\n      const currentToken = (callTokensRef.current.get(key) || 0) + 1;\n      callTokensRef.current.set(key, currentToken);\n\n      const startTime = Date.now();\n      setLoading(key, true);\n\n      // Clear any existing timeout\n      const existingTimeout = timeoutsRef.current.get(key);\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n      }\n\n      try {\n        // Set up timeout\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          const timeoutId = setTimeout(() => {\n            timeoutsRef.current.delete(key); // Remove from map when timeout fires\n            reject(new Error(\"Operation timed out\"));\n          }, timeout);\n          timeoutsRef.current.set(key, timeoutId);\n        });\n\n        // Execute operation with timeout\n        const result = await Promise.race([operation(), timeoutPromise]);\n\n        // Clear timeout\n        const timeoutId = timeoutsRef.current.get(key);\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutsRef.current.delete(key);\n        }\n\n        // Ensure minimum loading time\n        const elapsedTime = Date.now() - startTime;\n        if (elapsedTime < minLoadingTime) {\n          await new Promise((resolve) => setTimeout(resolve, minLoadingTime - elapsedTime));\n        }\n\n        // Only update state if this is still the latest call and component is mounted\n        if (callTokensRef.current.get(key) === currentToken && isMountedRef.current) {\n          setSuccess(key, result);\n        }\n        return result;\n      } catch (error) {\n        // Clear timeout\n        const timeoutId = timeoutsRef.current.get(key);\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutsRef.current.delete(key);\n        }\n\n        const errorMessage = error instanceof Error ? error.message : \"An error occurred\";\n\n        // Handle retries\n        const currentRetries = retriesRef.current.get(key) || 0;\n        if (currentRetries < retryCount) {\n          retriesRef.current.set(key, currentRetries + 1);\n\n          // Wait before retry\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n\n          // Retry the operation\n          return executeWithLoading(options, operation);\n        }\n\n        // Ensure minimum loading time even for errors\n        const elapsedTime = Date.now() - startTime;\n        if (elapsedTime < minLoadingTime) {\n          await new Promise((resolve) => setTimeout(resolve, minLoadingTime - elapsedTime));\n        }\n\n        // Only update state if this is still the latest call and component is mounted\n        if (callTokensRef.current.get(key) === currentToken && isMountedRef.current) {\n          setError(key, errorMessage);\n        }\n        return null;\n      }\n    },\n    [states, initializeState, setLoading, setSuccess, setError],\n  );\n\n  // Retry a failed operation\n  const retry = useCallback(\n    async function <T>(key: string, operation: () => Promise<T>, options?: Partial<LoadingOptions>): Promise<T | null> {\n      // Reset retry count\n      retriesRef.current.delete(key);\n\n      return executeWithLoading({ key, ...options }, operation);\n    },\n    [executeWithLoading],\n  );\n\n  // Clear a specific state\n  const clearState = useCallback((key: string) => {\n    setStates((prev) => {\n      const newStates = { ...prev };\n      delete newStates[key];\n      return newStates;\n    });\n\n    // Clear any associated timeouts and retries\n    const timeoutId = timeoutsRef.current.get(key);\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutsRef.current.delete(key);\n    }\n    retriesRef.current.delete(key);\n  }, []);\n\n  // Clear all states\n  const clearAllStates = useCallback(() => {\n    setStates({});\n\n    // Clear all timeouts\n    timeoutsRef.current.forEach((timeoutId) => clearTimeout(timeoutId));\n    timeoutsRef.current.clear();\n    retriesRef.current.clear();\n  }, []);\n\n  // Get state for a specific key\n  const getState = useCallback(\n    (key: string): LoadingState => {\n      return (\n        states[key] || {\n          isLoading: false,\n          error: null,\n          data: null,\n          lastUpdated: null,\n        }\n      );\n    },\n    [states],\n  );\n\n  // Check if any state is loading\n  const isAnyLoading = useCallback(() => {\n    return Object.values(states).some((state) => state.isLoading);\n  }, [states]);\n\n  // Get all errors\n  const getAllErrors = useCallback(() => {\n    return Object.entries(states)\n      .filter(([_, state]) => state.error)\n      .map(([key, state]) => ({ key, error: state.error }));\n  }, [states]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n      timeoutsRef.current.forEach((timeoutId) => clearTimeout(timeoutId));\n      timeoutsRef.current.clear();\n      callTokensRef.current.clear();\n    };\n  }, []);\n\n  return {\n    states,\n    initializeState,\n    setLoading,\n    setError,\n    setSuccess,\n    executeWithLoading,\n    retry,\n    clearState,\n    clearAllStates,\n    getState,\n    isAnyLoading,\n    getAllErrors,\n  };\n};\n\n// React Context pattern for global loading states\nconst LoadingStatesContext = createContext<ReturnType<typeof useLoadingStates> | null>(null);\n\nexport const LoadingStatesProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const loadingStates = useLoadingStates();\n  return <LoadingStatesContext.Provider value={loadingStates}>{children}</LoadingStatesContext.Provider>;\n};\n\nexport const useGlobalLoadingStates = () => {\n  const context = useContext(LoadingStatesContext);\n  if (!context) {\n    throw new Error(\"useGlobalLoadingStates must be used within a LoadingStatesProvider\");\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useMediaPermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useOfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useOnboardingAnimation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useOptimizedReplies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useScreenStatus.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useScreenStatus\" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.","line":173,"column":27,"nodeType":"Identifier","endLine":173,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useScrollRestoration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useSimpleVideoPlayer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useUnifiedPermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useVideoAnalyticsTracker.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handlePause' and 'handlePlay'. Either include them or remove the dependency array.","line":132,"column":6,"nodeType":"ArrayExpression","endLine":132,"endColumn":32,"suggestions":[{"desc":"Update the dependencies array to be: [analyticsState.isPlaying, handlePause, handlePlay]","fix":{"range":[3922,3948],"text":"[analyticsState.isPlaying, handlePause, handlePlay]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useCallback, useState } from \"react\";\nimport { AppState, AppStateStatus } from \"react-native\";\n\nimport { VideoDataService } from \"../services/VideoDataService\";\nimport { consentStore } from \"../state/consentStore\";\n\ninterface PlaybackStatusSnapshot {\n  isLoaded: boolean;\n  isPlaying: boolean;\n  isBuffering?: boolean;\n  positionMillis?: number;\n  durationMillis?: number;\n  didJustFinish?: boolean;\n}\n\nexport interface VideoAnalyticsConfig {\n  videoId: string;\n  videoDuration?: number;\n  enableDetailedTracking?: boolean;\n  trackQualityChanges?: boolean;\n  sessionId?: string;\n  onEngagementUpdate?: (score: number) => void;\n  onCompletionDetected?: (completionRate: number) => void;\n}\n\nexport interface VideoAnalyticsState {\n  watchTime: number;\n  completionRate: number;\n  engagementScore: number;\n  isPlaying: boolean;\n  bufferingCount: number;\n  seekCount: number;\n  sessionActive: boolean;\n}\n\ninterface WatchTimeState {\n  startTime: number | null;\n  totalWatchTime: number;\n  lastPosition: number;\n}\n\nconst WATCH_TIME_UPDATE_INTERVAL = 1000; // Update watch time every second\nconst ENGAGEMENT_CALC_INTERVAL = 5000; // Calculate engagement every 5 seconds\nconst POSITION_TOLERANCE = 2; // 2 second tolerance for seek detection\n\nexport function useVideoAnalyticsTracker(config: VideoAnalyticsConfig) {\n  const {\n    videoId,\n    videoDuration,\n    enableDetailedTracking = true,\n    trackQualityChanges = true,\n    sessionId: providedSessionId,\n    onEngagementUpdate,\n    onCompletionDetected,\n  } = config;\n\n  const [analyticsState, setAnalyticsState] = useState<VideoAnalyticsState>({\n    watchTime: 0,\n    completionRate: 0,\n    engagementScore: 0,\n    isPlaying: false,\n    bufferingCount: 0,\n    seekCount: 0,\n    sessionActive: false,\n  });\n\n  const watchTimeRef = useRef<WatchTimeState>({\n    startTime: null,\n    totalWatchTime: 0,\n    lastPosition: 0,\n  });\n\n  const sessionIdRef = useRef<string | null>(providedSessionId || null);\n  const watchTimeIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const engagementIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const appStateRef = useRef<AppStateStatus>(AppState.currentState);\n  const lastPlaybackStatusRef = useRef<PlaybackStatusSnapshot | null>(null);\n  const hasTrackedImpressionRef = useRef(false);\n  const isBufferingRef = useRef(false);\n  const lastQualityRef = useRef<string | null>(null);\n  const hasMarkedCompletedRef = useRef(false);\n\n  // Initialize session\n  useEffect(() => {\n    if (!videoId || !consentStore.preferences.analytics) return;\n\n    // Get or create session\n    if (!sessionIdRef.current) {\n      sessionIdRef.current = VideoDataService.getOrCreateSession(videoId);\n    }\n\n    // Track impression\n    if (!hasTrackedImpressionRef.current) {\n      VideoDataService.trackVideoEvent(videoId, {\n        type: \"impression\",\n        timestamp: Date.now(),\n        metadata: { videoDuration },\n      });\n      hasTrackedImpressionRef.current = true;\n    }\n\n    setAnalyticsState((prev) => ({ ...prev, sessionActive: true }));\n\n    return () => {\n      // Cleanup on unmount\n      if (sessionIdRef.current) {\n        VideoDataService.endSession(sessionIdRef.current);\n      }\n    };\n  }, [videoId, videoDuration]);\n\n  // Handle app state changes\n  useEffect(() => {\n    const subscription = AppState.addEventListener(\"change\", (nextAppState: AppStateStatus) => {\n      if (appStateRef.current === \"active\" && nextAppState.match(/inactive|background/)) {\n        // App going to background - pause tracking\n        handlePause();\n      } else if (\n        appStateRef.current.match(/inactive|background/) &&\n        nextAppState === \"active\" &&\n        analyticsState.isPlaying\n      ) {\n        // App returning to foreground - resume tracking if was playing\n        handlePlay();\n      }\n      appStateRef.current = nextAppState;\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [analyticsState.isPlaying]);\n\n  // Start watch time tracking\n  const startWatchTimeTracking = useCallback(() => {\n    if (watchTimeIntervalRef.current) {\n      clearInterval(watchTimeIntervalRef.current);\n    }\n\n    watchTimeRef.current.startTime = Date.now();\n\n    watchTimeIntervalRef.current = setInterval(() => {\n      if (watchTimeRef.current.startTime) {\n        const elapsed = (Date.now() - watchTimeRef.current.startTime) / 1000;\n        const newTotalTime = watchTimeRef.current.totalWatchTime + elapsed;\n        watchTimeRef.current.totalWatchTime = newTotalTime;\n        watchTimeRef.current.startTime = Date.now();\n\n        setAnalyticsState((prev) => ({\n          ...prev,\n          watchTime: newTotalTime,\n          completionRate: videoDuration ? (newTotalTime / videoDuration) * 100 : 0,\n        }));\n\n        // Update cached analytics\n        VideoDataService.updateAnalyticsCache(videoId, {\n          watchTime: newTotalTime,\n          completionRate: videoDuration ? (newTotalTime / videoDuration) * 100 : 0,\n        });\n      }\n    }, WATCH_TIME_UPDATE_INTERVAL);\n  }, [videoId, videoDuration]);\n\n  // Stop watch time tracking\n  const stopWatchTimeTracking = useCallback(() => {\n    if (watchTimeIntervalRef.current) {\n      clearInterval(watchTimeIntervalRef.current);\n      watchTimeIntervalRef.current = null;\n    }\n\n    if (watchTimeRef.current.startTime) {\n      const elapsed = (Date.now() - watchTimeRef.current.startTime) / 1000;\n      watchTimeRef.current.totalWatchTime += elapsed;\n      watchTimeRef.current.startTime = null;\n    }\n  }, []);\n\n  // Calculate engagement score\n  const calculateEngagement = useCallback(() => {\n    const engagementScore = VideoDataService.calculateEngagementScore({\n      completionRate: analyticsState.completionRate / 100,\n      watchTime: analyticsState.watchTime,\n    });\n\n    setAnalyticsState((prev) => ({ ...prev, engagementScore }));\n\n    if (onEngagementUpdate) {\n      onEngagementUpdate(engagementScore);\n    }\n\n    VideoDataService.updateAnalyticsCache(videoId, { engagementScore });\n  }, [videoId, analyticsState.completionRate, analyticsState.watchTime, onEngagementUpdate]);\n\n  // Start engagement calculation\n  useEffect(() => {\n    if (analyticsState.isPlaying && enableDetailedTracking) {\n      engagementIntervalRef.current = setInterval(calculateEngagement, ENGAGEMENT_CALC_INTERVAL);\n    } else if (engagementIntervalRef.current) {\n      clearInterval(engagementIntervalRef.current);\n      engagementIntervalRef.current = null;\n    }\n\n    return () => {\n      if (engagementIntervalRef.current) {\n        clearInterval(engagementIntervalRef.current);\n      }\n    };\n  }, [analyticsState.isPlaying, enableDetailedTracking, calculateEngagement]);\n\n  // Handle play event\n  const handlePlay = useCallback(() => {\n    if (!consentStore.preferences.analytics) return;\n\n    VideoDataService.trackVideoEvent(videoId, {\n      type: analyticsState.watchTime > 0 ? \"resume\" : \"play\",\n      timestamp: Date.now(),\n      metadata: { position: watchTimeRef.current.lastPosition },\n    });\n\n    startWatchTimeTracking();\n    setAnalyticsState((prev) => ({ ...prev, isPlaying: true }));\n  }, [videoId, analyticsState.watchTime, startWatchTimeTracking]);\n\n  // Handle pause event\n  const handlePause = useCallback(() => {\n    if (!consentStore.preferences.analytics) return;\n\n    VideoDataService.trackVideoEvent(videoId, {\n      type: \"pause\",\n      timestamp: Date.now(),\n      metadata: {\n        position: watchTimeRef.current.lastPosition,\n        watchTime: watchTimeRef.current.totalWatchTime,\n      },\n    });\n\n    stopWatchTimeTracking();\n    setAnalyticsState((prev) => ({ ...prev, isPlaying: false }));\n  }, [videoId, stopWatchTimeTracking]);\n\n  // Handle seek event\n  const handleSeek = useCallback(\n    (fromPosition: number, toPosition: number) => {\n      if (!consentStore.preferences.analytics || !enableDetailedTracking) return;\n\n      VideoDataService.trackVideoEvent(videoId, {\n        type: \"seek\",\n        timestamp: Date.now(),\n        metadata: { from: fromPosition, to: toPosition },\n      });\n\n      setAnalyticsState((prev) => ({ ...prev, seekCount: prev.seekCount + 1 }));\n    },\n    [videoId, enableDetailedTracking],\n  );\n\n  // Handle buffer start\n  const handleBufferStart = useCallback(() => {\n    if (!consentStore.preferences.analytics || !enableDetailedTracking) return;\n\n    isBufferingRef.current = true;\n\n    VideoDataService.trackVideoEvent(videoId, {\n      type: \"buffer_start\",\n      timestamp: Date.now(),\n      metadata: { position: watchTimeRef.current.lastPosition },\n    });\n\n    VideoDataService.trackBufferingStart(videoId);\n    setAnalyticsState((prev) => ({ ...prev, bufferingCount: prev.bufferingCount + 1 }));\n  }, [videoId, enableDetailedTracking]);\n\n  // Handle buffer end\n  const handleBufferEnd = useCallback(() => {\n    if (!consentStore.preferences.analytics || !enableDetailedTracking) return;\n\n    if (isBufferingRef.current) {\n      isBufferingRef.current = false;\n\n      VideoDataService.trackVideoEvent(videoId, {\n        type: \"buffer_end\",\n        timestamp: Date.now(),\n        metadata: { position: watchTimeRef.current.lastPosition },\n      });\n\n      VideoDataService.trackBufferingEnd(videoId);\n    }\n  }, [videoId, enableDetailedTracking]);\n\n  // Handle quality change\n  const handleQualityChange = useCallback(\n    (newQuality: string) => {\n      if (!consentStore.preferences.analytics || !trackQualityChanges) return;\n\n      VideoDataService.trackVideoEvent(videoId, {\n        type: \"quality_change\",\n        timestamp: Date.now(),\n        metadata: {\n          from: lastQualityRef.current,\n          to: newQuality,\n          position: watchTimeRef.current.lastPosition,\n        },\n      });\n\n      lastQualityRef.current = newQuality;\n    },\n    [videoId, trackQualityChanges],\n  );\n\n  // Handle completion\n  const handleCompletion = useCallback(() => {\n    if (!consentStore.preferences.analytics) return;\n\n    const completionRate = videoDuration ? (watchTimeRef.current.totalWatchTime / videoDuration) * 100 : 0;\n\n    VideoDataService.trackVideoCompletion(videoId, watchTimeRef.current.totalWatchTime, videoDuration || 0);\n\n    if (onCompletionDetected) {\n      onCompletionDetected(completionRate);\n    }\n\n    setAnalyticsState((prev) => ({ ...prev, completionRate }));\n  }, [videoId, videoDuration, onCompletionDetected]);\n\n  // Process playback status update\n  const onPlaybackStatusUpdate = useCallback(\n    (status: PlaybackStatusSnapshot) => {\n      if (!status.isLoaded || !consentStore.preferences.analytics) return;\n\n      const prevStatus = lastPlaybackStatusRef.current;\n      lastPlaybackStatusRef.current = status;\n\n      // Track play/pause state changes\n      if (status.isPlaying && (!prevStatus || !prevStatus.isLoaded || !prevStatus.isPlaying)) {\n        handlePlay();\n      } else if (!status.isPlaying && prevStatus?.isLoaded && prevStatus.isPlaying) {\n        handlePause();\n      }\n\n      // Track buffering\n      if (enableDetailedTracking) {\n        if (status.isBuffering && !isBufferingRef.current) {\n          handleBufferStart();\n        } else if (!status.isBuffering && isBufferingRef.current) {\n          handleBufferEnd();\n        }\n      }\n\n      // Track position and detect seeks\n      if (status.positionMillis !== undefined) {\n        const currentPosition = status.positionMillis / 1000;\n\n        if (prevStatus?.isLoaded && prevStatus.positionMillis !== undefined) {\n          const prevPosition = prevStatus.positionMillis / 1000;\n          const timeDiff = Math.abs(currentPosition - prevPosition);\n\n          // Detect seek (position change larger than normal playback)\n          if (timeDiff > POSITION_TOLERANCE && enableDetailedTracking) {\n            handleSeek(prevPosition, currentPosition);\n          }\n        }\n\n        watchTimeRef.current.lastPosition = currentPosition;\n      }\n\n      // Check for completion - track once per session regardless of looping\n      const currentCompletionRate = videoDuration ? watchTimeRef.current.totalWatchTime / videoDuration : 0;\n\n      if (!hasMarkedCompletedRef.current && (status.didJustFinish || currentCompletionRate >= 0.8) && videoDuration) {\n        hasMarkedCompletedRef.current = true;\n        handleCompletion();\n      }\n    },\n    [\n      handlePlay,\n      handlePause,\n      handleBufferStart,\n      handleBufferEnd,\n      handleSeek,\n      handleCompletion,\n      enableDetailedTracking,\n      videoDuration,\n    ],\n  );\n\n  // Track interaction events\n  const trackInteraction = useCallback(\n    (type: \"like\" | \"unlike\" | \"comment\" | \"share\" | \"save\") => {\n      if (!consentStore.preferences.analytics) return;\n\n      VideoDataService.trackVideoEvent(videoId, {\n        type,\n        timestamp: Date.now(),\n        metadata: {\n          position: watchTimeRef.current.lastPosition,\n          watchTime: watchTimeRef.current.totalWatchTime,\n        },\n      });\n    },\n    [videoId],\n  );\n\n  // Manual quality update\n  const updateQuality = useCallback(\n    (quality: string) => {\n      handleQualityChange(quality);\n    },\n    [handleQualityChange],\n  );\n\n  // Manual completion trigger\n  const markAsCompleted = useCallback(() => {\n    handleCompletion();\n  }, [handleCompletion]);\n\n  // Get current analytics state\n  const getCurrentAnalytics = useCallback(\n    () => ({\n      ...analyticsState,\n      sessionId: sessionIdRef.current,\n      currentPosition: watchTimeRef.current.lastPosition,\n    }),\n    [analyticsState],\n  );\n\n  // Cleanup function\n  const cleanup = useCallback(() => {\n    stopWatchTimeTracking();\n    if (engagementIntervalRef.current) {\n      clearInterval(engagementIntervalRef.current);\n    }\n    if (sessionIdRef.current) {\n      VideoDataService.endSession(sessionIdRef.current);\n    }\n  }, [stopWatchTimeTracking]);\n\n  return {\n    // State\n    analyticsState,\n\n    // Event handlers\n    onPlaybackStatusUpdate,\n    trackInteraction,\n    updateQuality,\n    markAsCompleted,\n\n    // Utilities\n    getCurrentAnalytics,\n    cleanup,\n\n    // Direct event handlers (for custom players)\n    handlePlay,\n    handlePause,\n    handleSeek,\n    handleBufferStart,\n    handleBufferEnd,\n    handleQualityChange,\n    handleCompletion,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useVideoFeedGestures.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withSequence' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withTiming' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tapTimeout' is assigned a value but never used.","line":71,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'activeDirection'. Either include it or remove the dependency array.","line":245,"column":6,"nodeType":"ArrayExpression","endLine":245,"endColumn":93,"suggestions":[{"desc":"Update the dependencies array to be: [translateY, translateX, scale, opacity, progressY, progressX, pinchScale, isScrolling, activeDirection]","fix":{"range":[7897,7984],"text":"[translateY, translateX, scale, opacity, progressY, progressX, pinchScale, isScrolling, activeDirection]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useRef } from \"react\";\nimport { Gesture } from \"react-native-gesture-handler\";\nimport {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withSequence,\n  withTiming,\n  runOnJS,\n  interpolate,\n} from \"react-native-reanimated\";\nimport { Dimensions } from \"react-native\";\nimport * as Haptics from \"expo-haptics\";\n\nconst { height: SCREEN_HEIGHT, width: SCREEN_WIDTH } = Dimensions.get(\"window\");\n\n// Gesture thresholds and configuration\nconst SWIPE_THRESHOLD = 60;\nconst SWIPE_VELOCITY_THRESHOLD = 650;\nconst HORIZONTAL_SWIPE_THRESHOLD = 80;\nconst DOUBLE_TAP_MAX_DELAY = 280;\nconst PINCH_SCALE_THRESHOLD = 0.1;\nconst SPRING_CONFIG = {\n  damping: 20,\n  stiffness: 300,\n  mass: 1,\n};\n\ninterface UseVideoFeedGesturesProps {\n  currentIndex: number;\n  totalVideos: number;\n  onLongPress?: () => void;\n  onRefresh?: () => void;\n  onSwipeUp?: () => void;\n  onSwipeDown?: () => void;\n  onSwipeLeft?: () => void;\n  onSwipeRight?: () => void;\n  onDoubleTap?: () => void;\n  onPinch?: (scale: number) => void;\n  onPlaybackSpeedChange?: () => void;\n  isLoading?: boolean;\n}\n\nexport function useVideoFeedGestures({\n  currentIndex,\n  totalVideos,\n  onLongPress,\n  onRefresh,\n  onSwipeUp,\n  onSwipeDown,\n  onSwipeLeft,\n  onSwipeRight,\n  onDoubleTap,\n  onPinch,\n  onPlaybackSpeedChange,\n  isLoading = false,\n}: UseVideoFeedGesturesProps) {\n  // Animation values\n  const translateY = useSharedValue(0);\n  const translateX = useSharedValue(0);\n  const scale = useSharedValue(1);\n  const opacity = useSharedValue(1);\n  const progressY = useSharedValue(0);\n  const progressX = useSharedValue(0);\n  const pinchScale = useSharedValue(1);\n\n  // Gesture state\n  const isScrolling = useSharedValue(false);\n  const activeDirection = useSharedValue<\"idle\" | \"up\" | \"down\" | \"left\" | \"right\">(\"idle\");\n  const lastTapTime = useRef(0);\n  const tapTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  // Pan gesture for swipe navigation (vertical and horizontal)\n  const panGesture = Gesture.Pan()\n    .onStart(() => {\n      isScrolling.value = true;\n      activeDirection.value = \"idle\";\n    })\n    .onUpdate((event) => {\n      const absY = Math.abs(event.translationY);\n      const absX = Math.abs(event.translationX);\n\n      // Determine primary direction\n      if (absY > absX) {\n        // Vertical swipe\n        const dampenedTranslation = event.translationY + event.velocityY * 0.05;\n        translateY.value = dampenedTranslation;\n\n        // Scale effect for visual feedback\n        const progress = Math.abs(dampenedTranslation) / SCREEN_HEIGHT;\n        scale.value = interpolate(progress, [0, 0.3], [1, 0.95], \"clamp\");\n\n        // Opacity effect for smooth transitions\n        opacity.value = interpolate(progress, [0, 0.5], [1, 0.8], \"clamp\");\n\n        activeDirection.value = dampenedTranslation > 0 ? \"down\" : \"up\";\n\n        // Update shared value for progress\n        const normalized = Math.max(-1, Math.min(1, dampenedTranslation / SCREEN_HEIGHT));\n        progressY.value = normalized;\n      } else {\n        // Horizontal swipe\n        translateX.value = event.translationX;\n\n        // Scale effect for horizontal swipes\n        const progress = Math.abs(event.translationX) / SCREEN_WIDTH;\n        scale.value = interpolate(progress, [0, 0.2], [1, 0.98], \"clamp\");\n\n        activeDirection.value = event.translationX > 0 ? \"right\" : \"left\";\n\n        // Update shared value for progress\n        const normalized = Math.max(-1, Math.min(1, event.translationX / SCREEN_WIDTH));\n        progressX.value = normalized;\n      }\n    })\n    .onEnd((event) => {\n      const absY = Math.abs(event.translationY);\n      const absX = Math.abs(event.translationX);\n      const shouldSwipeVertical = absY > SWIPE_THRESHOLD || Math.abs(event.velocityY) > SWIPE_VELOCITY_THRESHOLD;\n      const shouldSwipeHorizontal =\n        absX > HORIZONTAL_SWIPE_THRESHOLD || Math.abs(event.velocityX) > SWIPE_VELOCITY_THRESHOLD;\n\n      if (absY > absX) {\n        // Vertical swipe handling\n        if (shouldSwipeVertical && event.translationY > 0 && currentIndex === 0 && onRefresh && !isLoading) {\n          runOnJS(() => {\n            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n            onRefresh();\n          })();\n        } else if (shouldSwipeVertical) {\n          runOnJS(() => {\n            if (event.translationY > 0 && onSwipeDown) {\n              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              onSwipeDown();\n            } else if (event.translationY < 0 && onSwipeUp) {\n              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              onSwipeUp();\n            }\n          })();\n        }\n      } else {\n        // Horizontal swipe handling\n        if (shouldSwipeHorizontal) {\n          runOnJS(() => {\n            if (event.translationX > 0 && onSwipeRight) {\n              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              onSwipeRight();\n            } else if (event.translationX < 0 && onSwipeLeft) {\n              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              onSwipeLeft();\n            }\n          })();\n        }\n      }\n\n      // Reset animations\n      translateY.value = withSpring(0, SPRING_CONFIG);\n      translateX.value = withSpring(0, SPRING_CONFIG);\n      scale.value = withSpring(1, SPRING_CONFIG);\n      opacity.value = withSpring(1, SPRING_CONFIG);\n      progressY.value = withSpring(0, SPRING_CONFIG);\n      progressX.value = withSpring(0, SPRING_CONFIG);\n      isScrolling.value = false;\n      activeDirection.value = \"idle\";\n    });\n\n  // Double tap gesture for like\n  const doubleTapGesture = Gesture.Tap()\n    .numberOfTaps(2)\n    .maxDuration(250)\n    .onEnd(() => {\n      const now = Date.now();\n      const timeSinceLastTap = now - lastTapTime.current;\n\n      if (timeSinceLastTap < DOUBLE_TAP_MAX_DELAY && onDoubleTap) {\n        runOnJS(() => {\n          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n          onDoubleTap();\n        })();\n      }\n      lastTapTime.current = now;\n    });\n\n  // Long press gesture for playback speed control\n  const longPressGesture = Gesture.LongPress()\n    .minDuration(500)\n    .onStart(() => {\n      if (onPlaybackSpeedChange) {\n        runOnJS(() => {\n          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n          onPlaybackSpeedChange();\n        })();\n      } else if (onLongPress) {\n        runOnJS(onLongPress)();\n      }\n    });\n\n  // Pinch gesture for zoom controls\n  const pinchGesture = Gesture.Pinch()\n    .onUpdate((event) => {\n      pinchScale.value = event.scale;\n    })\n    .onEnd((event) => {\n      const scaleChange = event.scale - 1;\n      if (Math.abs(scaleChange) > PINCH_SCALE_THRESHOLD && onPinch) {\n        runOnJS(() => {\n          onPinch(event.scale);\n        })();\n      }\n      pinchScale.value = withSpring(1, SPRING_CONFIG);\n    });\n\n  // Compose all gestures with proper priority\n  const composedGestures = Gesture.Race(\n    doubleTapGesture,\n    Gesture.Simultaneous(panGesture, pinchGesture),\n    longPressGesture,\n  );\n\n  // Animated styles\n  const containerStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: translateY.value },\n      { translateX: translateX.value },\n      { scale: scale.value * pinchScale.value },\n    ],\n    opacity: opacity.value,\n  }));\n\n  const overlayStyle = useAnimatedStyle(() => ({\n    opacity: isScrolling.value ? 0.5 : 1,\n  }));\n\n  // Reset animations\n  const resetAnimations = useCallback(() => {\n    translateY.value = withSpring(0, SPRING_CONFIG);\n    translateX.value = withSpring(0, SPRING_CONFIG);\n    scale.value = withSpring(1, SPRING_CONFIG);\n    opacity.value = withSpring(1, SPRING_CONFIG);\n    progressY.value = withSpring(0, SPRING_CONFIG);\n    progressX.value = withSpring(0, SPRING_CONFIG);\n    pinchScale.value = withSpring(1, SPRING_CONFIG);\n    isScrolling.value = false;\n    activeDirection.value = \"idle\";\n  }, [translateY, translateX, scale, opacity, progressY, progressX, pinchScale, isScrolling]);\n\n  return {\n    gestures: composedGestures,\n    containerStyle,\n    overlayStyle,\n    resetAnimations,\n    isScrolling,\n    progressY,\n    progressX,\n    pinchScale,\n    gestureState: {\n      activeDirection,\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useVideoPerformanceOptimization.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useCallback' is defined but never used.","line":1,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VideoDataService' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":26},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initializePerformanceOptimization'. Either include it or remove the dependency array.","line":127,"column":6,"nodeType":"ArrayExpression","endLine":127,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [initializePerformanceOptimization]","fix":{"range":[3883,3885],"text":"[initializePerformanceOptimization]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deviceInfo' is assigned a value but never used.","line":163,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":163,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from \"react\";\nimport { AppState, AppStateStatus } from \"react-native\";\nimport NetInfo from \"@react-native-community/netinfo\";\nimport { videoQualitySelector } from \"../services/VideoQualitySelector\";\nimport { videoBackgroundQueue, JobType, JobPriority } from \"../services/VideoBackgroundQueue\";\nimport { networkProfiler, NetworkProfile, NetworkQuality } from \"../utils/networkProfiler\";\nimport { videoPerformanceConfig, DevicePerformanceTier, NetworkQualityTier } from \"../config/videoPerformance\";\nimport { videoCacheManager } from \"../utils/videoCacheManager\";\nimport { environmentDetector } from \"../utils/environmentDetector\";\nimport { VideoDataService } from \"../services/VideoDataService\";\n\nexport interface VideoPerformanceState {\n  deviceTier: DevicePerformanceTier;\n  networkQuality: NetworkQuality;\n  currentVideoQuality: \"360p\" | \"720p\" | \"1080p\";\n  isOptimizing: boolean;\n  cacheStats: {\n    size: number;\n    count: number;\n    hitRate: number;\n  };\n  backgroundQueueStats: {\n    pending: number;\n    processing: number;\n    completed: number;\n  };\n  memoryPressure: number;\n  adaptiveSettings: {\n    preloadCount: number;\n    cacheSize: number;\n    qualityMode: \"auto\" | \"manual\" | \"save-data\";\n  };\n  errors: string[];\n}\n\nexport interface VideoPerformanceActions {\n  optimizeVideoQuality: (videoUri: string) => Promise<void>;\n  preloadVideos: (videoUris: string[], priority?: \"high\" | \"normal\" | \"low\") => Promise<void>;\n  clearCache: () => Promise<void>;\n  forceQuality: (quality: \"360p\" | \"720p\" | \"1080p\") => void;\n  toggleSaveDataMode: () => void;\n  runPerformanceTest: () => Promise<PerformanceTestResult>;\n  getRecommendedSettings: () => PerformanceRecommendations;\n}\n\nexport interface PerformanceTestResult {\n  bandwidth: number;\n  latency: number;\n  deviceScore: number;\n  recommendedQuality: \"360p\" | \"720p\" | \"1080p\";\n  issues: string[];\n}\n\nexport interface PerformanceRecommendations {\n  quality: \"360p\" | \"720p\" | \"1080p\";\n  preloadCount: number;\n  cacheStrategy: \"aggressive\" | \"balanced\" | \"conservative\";\n  features: {\n    autoQualityUpgrade: boolean;\n    backgroundProcessing: boolean;\n    aggressivePreloading: boolean;\n  };\n}\n\ninterface UseVideoPerformanceOptions {\n  enableAutoOptimization?: boolean;\n  enableBackgroundProcessing?: boolean;\n  enableAnalytics?: boolean;\n  debugMode?: boolean;\n}\n\nexport function useVideoPerformanceOptimization(\n  currentVideoUri?: string,\n  options: UseVideoPerformanceOptions = {},\n): [VideoPerformanceState, VideoPerformanceActions] {\n  const {\n    enableAutoOptimization = true,\n    enableBackgroundProcessing = true,\n    enableAnalytics = true,\n    debugMode = false,\n  } = options;\n\n  // State\n  const [state, setState] = useState<VideoPerformanceState>({\n    deviceTier: DevicePerformanceTier.MID,\n    networkQuality: \"fair\",\n    currentVideoQuality: \"720p\",\n    isOptimizing: false,\n    cacheStats: {\n      size: 0,\n      count: 0,\n      hitRate: 0,\n    },\n    backgroundQueueStats: {\n      pending: 0,\n      processing: 0,\n      completed: 0,\n    },\n    memoryPressure: 0,\n    adaptiveSettings: {\n      preloadCount: 5,\n      cacheSize: 500 * 1024 * 1024,\n      qualityMode: \"auto\",\n    },\n    errors: [],\n  });\n\n  // Refs\n  const appStateRef = useRef<AppStateStatus>(AppState.currentState);\n  const networkSubscription = useRef<any>(null);\n  const memoryMonitorInterval = useRef<NodeJS.Timeout | null>(null);\n  const analyticsInterval = useRef<NodeJS.Timeout | null>(null);\n  const appStateSubscription = useRef<any>(null);\n  const queueStatsInterval = useRef<NodeJS.Timeout | null>(null);\n  const isInitialized = useRef(false);\n\n  // Initialize performance optimization\n  useEffect(() => {\n    if (isInitialized.current) return;\n    isInitialized.current = true;\n\n    initializePerformanceOptimization();\n\n    return () => {\n      cleanup();\n    };\n  }, []);\n\n  const initializePerformanceOptimization = async () => {\n    try {\n      // Detect device capabilities\n      await detectDeviceCapabilities();\n\n      // Initialize network monitoring\n      initializeNetworkMonitoring();\n\n      // Start memory monitoring\n      startMemoryMonitoring();\n\n      // Initialize background processing\n      if (enableBackgroundProcessing) {\n        await initializeBackgroundProcessing();\n      }\n\n      // Start analytics collection\n      if (enableAnalytics) {\n        startAnalyticsCollection();\n      }\n\n      // Initialize app state monitoring\n      initializeAppStateMonitoring();\n\n      // Update initial state\n      await updatePerformanceState();\n    } catch (error) {\n      console.error(\"Failed to initialize performance optimization:\", error);\n      addError(\"Failed to initialize performance optimization\");\n    }\n  };\n\n  const detectDeviceCapabilities = async () => {\n    try {\n      const deviceInfo = await environmentDetector.getDeviceInfo();\n      const memoryInfo = await environmentDetector.getMemoryInfo();\n\n      const totalMemoryGB = memoryInfo.totalMemory / (1024 * 1024 * 1024);\n      let tier: DevicePerformanceTier;\n\n      if (totalMemoryGB >= 6) {\n        tier = DevicePerformanceTier.HIGH;\n      } else if (totalMemoryGB >= 4) {\n        tier = DevicePerformanceTier.MID;\n      } else {\n        tier = DevicePerformanceTier.LOW;\n      }\n\n      videoPerformanceConfig.setDeviceTier(tier);\n\n      setState((prev) => ({ ...prev, deviceTier: tier }));\n    } catch (error) {\n      console.error(\"Failed to detect device capabilities:\", error);\n      addError(\"Failed to detect device capabilities\");\n    }\n  };\n\n  const initializeNetworkMonitoring = () => {\n    networkSubscription.current = NetInfo.addEventListener(async (state) => {\n      if (state.isConnected) {\n        const profile = await networkProfiler.measureNetworkCondition();\n        if (profile) {\n          handleNetworkChange(profile);\n        }\n      } else {\n        setState((prev) => ({ ...prev, networkQuality: \"poor\" }));\n      }\n    });\n  };\n\n  const handleNetworkChange = async (profile: NetworkProfile) => {\n    setState((prev) => ({ ...prev, networkQuality: profile.quality }));\n\n    // Map to NetworkQualityTier for video config\n    const qualityTierMap: Record<NetworkQuality, NetworkQualityTier> = {\n      excellent: NetworkQualityTier.EXCELLENT,\n      good: NetworkQualityTier.GOOD,\n      fair: NetworkQualityTier.FAIR,\n      poor: NetworkQualityTier.POOR,\n    };\n\n    videoPerformanceConfig.setNetworkQuality(qualityTierMap[profile.quality]);\n\n    // Auto-optimize quality if enabled\n    if (enableAutoOptimization && currentVideoUri) {\n      if (profile.quality === \"excellent\") {\n        const canUpgrade = await videoQualitySelector.canUpgradeQuality(currentVideoUri);\n        if (canUpgrade) {\n          await optimizeCurrentVideo();\n        }\n      } else if (profile.quality === \"poor\") {\n        const shouldDowngrade = await videoQualitySelector.shouldDowngradeQuality(currentVideoUri);\n        if (shouldDowngrade) {\n          setState((prev) => ({ ...prev, currentVideoQuality: \"360p\" }));\n        }\n      }\n    }\n  };\n\n  const startMemoryMonitoring = () => {\n    memoryMonitorInterval.current = setInterval(async () => {\n      try {\n        const memoryInfo = await environmentDetector.getMemoryInfo();\n        const usedMemory = memoryInfo.totalMemory - memoryInfo.availableMemory;\n        const memoryPressure = usedMemory / memoryInfo.totalMemory;\n\n        setState((prev) => ({ ...prev, memoryPressure }));\n\n        // Trigger cache cleanup if memory pressure is high\n        if (memoryPressure > 0.8) {\n          await videoCacheManager.forceCleanup();\n        }\n      } catch (error) {\n        console.error(\"Memory monitoring failed:\", error);\n      }\n    }, 10000); // Check every 10 seconds\n  };\n\n  const initializeBackgroundProcessing = async () => {\n    // Queue some initial optimization jobs\n    await videoBackgroundQueue.enqueueJob(JobType.CACHE_OPTIMIZATION, {}, JobPriority.LOW);\n\n    // Update queue stats periodically\n    queueStatsInterval.current = setInterval(() => {\n      const queueStats = videoBackgroundQueue.getQueueStats();\n      setState((prev) => ({\n        ...prev,\n        backgroundQueueStats: {\n          pending: queueStats.pending,\n          processing: queueStats.processing,\n          completed: queueStats.completed,\n        },\n      }));\n    }, 5000);\n  };\n\n  const startAnalyticsCollection = () => {\n    analyticsInterval.current = setInterval(async () => {\n      try {\n        const cacheStats = videoCacheManager.getDeviceAwareCacheStats();\n\n        setState((prev) => ({\n          ...prev,\n          cacheStats: {\n            size: cacheStats.size,\n            count: cacheStats.count,\n            hitRate: cacheStats.hitRate,\n          },\n        }));\n\n        // Send analytics data (placeholder)\n        if (debugMode) {\n          console.log(\"Performance Analytics:\", {\n            deviceTier: state.deviceTier,\n            networkQuality: state.networkQuality,\n            cacheHitRate: cacheStats.hitRate,\n            memoryPressure: state.memoryPressure,\n          });\n        }\n      } catch (error) {\n        console.error(\"Analytics collection failed:\", error);\n      }\n    }, 30000); // Every 30 seconds\n  };\n\n  const initializeAppStateMonitoring = () => {\n    appStateSubscription.current = AppState.addEventListener(\"change\", (nextAppState) => {\n      if (appStateRef.current === \"background\" && nextAppState === \"active\") {\n        // App came to foreground - refresh state\n        updatePerformanceState();\n      }\n      appStateRef.current = nextAppState;\n    });\n  };\n\n  const updatePerformanceState = async () => {\n    try {\n      const [networkProfile, cacheStats, queueStats] = await Promise.all([\n        networkProfiler.getCurrentProfile(),\n        videoCacheManager.getDeviceAwareCacheStats(),\n        Promise.resolve(videoBackgroundQueue.getQueueStats()),\n      ]);\n\n      const perfConfig = videoPerformanceConfig.getDynamicConfig();\n\n      setState((prev) => ({\n        ...prev,\n        networkQuality: networkProfile?.quality ?? \"fair\",\n        cacheStats: {\n          size: cacheStats.size,\n          count: cacheStats.count,\n          hitRate: cacheStats.hitRate,\n        },\n        backgroundQueueStats: {\n          pending: queueStats.pending,\n          processing: queueStats.processing,\n          completed: queueStats.completed,\n        },\n        adaptiveSettings: {\n          preloadCount: perfConfig.preloadProfile.preloadWindowSize,\n          cacheSize: perfConfig.cacheConfig.maxCacheSize,\n          qualityMode: prev.adaptiveSettings.qualityMode,\n        },\n      }));\n    } catch (error) {\n      console.error(\"Failed to update performance state:\", error);\n    }\n  };\n\n  const optimizeCurrentVideo = async () => {\n    if (!currentVideoUri) {\n      console.warn(\"No current video URI provided for optimization\");\n      return;\n    }\n\n    setState((prev) => ({ ...prev, isOptimizing: true }));\n\n    try {\n      const qualityResult = await videoQualitySelector.selectVideoQuality(currentVideoUri);\n      setState((prev) => ({\n        ...prev,\n        currentVideoQuality: qualityResult.selectedQuality,\n        isOptimizing: false,\n      }));\n    } catch (error) {\n      console.error(\"Video optimization failed:\", error);\n      setState((prev) => ({ ...prev, isOptimizing: false }));\n    }\n  };\n\n  const addError = (error: string) => {\n    setState((prev) => ({\n      ...prev,\n      errors: [...prev.errors.slice(-4), error], // Keep last 5 errors\n    }));\n  };\n\n  const cleanup = () => {\n    if (networkSubscription.current) {\n      networkSubscription.current();\n      networkSubscription.current = null;\n    }\n    if (memoryMonitorInterval.current) {\n      clearInterval(memoryMonitorInterval.current);\n      memoryMonitorInterval.current = null;\n    }\n    if (analyticsInterval.current) {\n      clearInterval(analyticsInterval.current);\n      analyticsInterval.current = null;\n    }\n    if (appStateSubscription.current) {\n      appStateSubscription.current.remove();\n      appStateSubscription.current = null;\n    }\n    if (queueStatsInterval.current) {\n      clearInterval(queueStatsInterval.current);\n      queueStatsInterval.current = null;\n    }\n  };\n\n  // Actions\n  const actions: VideoPerformanceActions = {\n    optimizeVideoQuality: async (videoUri: string) => {\n      setState((prev) => ({ ...prev, isOptimizing: true }));\n\n      try {\n        const qualityResult = await videoQualitySelector.selectVideoQuality(videoUri);\n\n        setState((prev) => ({\n          ...prev,\n          currentVideoQuality: qualityResult.selectedQuality,\n          isOptimizing: false,\n        }));\n\n        // Queue background optimization\n        if (enableBackgroundProcessing) {\n          await videoBackgroundQueue.enqueueJob(\n            JobType.QUALITY_VARIANT_GENERATION,\n            { uri: videoUri, videoId: \"generated\" },\n            JobPriority.NORMAL,\n          );\n        }\n      } catch (error) {\n        console.error(\"Quality optimization failed:\", error);\n        addError(\"Quality optimization failed\");\n        setState((prev) => ({ ...prev, isOptimizing: false }));\n      }\n    },\n\n    preloadVideos: async (videoUris: string[], priority = \"normal\") => {\n      try {\n        await videoCacheManager.preloadVideos(videoUris, priority);\n\n        // Queue background preloading for additional optimization\n        if (enableBackgroundProcessing) {\n          await videoBackgroundQueue.enqueueJob(\n            JobType.VIDEO_PRELOADING,\n            { uris: videoUris, priority },\n            JobPriority.LOW,\n          );\n        }\n      } catch (error) {\n        console.error(\"Video preloading failed:\", error);\n        addError(\"Video preloading failed\");\n      }\n    },\n\n    clearCache: async () => {\n      try {\n        await videoCacheManager.clearCache();\n        await updatePerformanceState();\n      } catch (error) {\n        console.error(\"Cache clearing failed:\", error);\n        addError(\"Cache clearing failed\");\n      }\n    },\n\n    forceQuality: (quality: \"360p\" | \"720p\" | \"1080p\") => {\n      setState((prev) => ({\n        ...prev,\n        currentVideoQuality: quality,\n        adaptiveSettings: {\n          ...prev.adaptiveSettings,\n          qualityMode: \"manual\",\n        },\n      }));\n    },\n\n    toggleSaveDataMode: () => {\n      setState((prev) => {\n        const newMode = prev.adaptiveSettings.qualityMode === \"save-data\" ? \"auto\" : \"save-data\";\n\n        if (newMode === \"save-data\") {\n          // Force low quality in save data mode\n          return {\n            ...prev,\n            currentVideoQuality: \"360p\",\n            adaptiveSettings: {\n              ...prev.adaptiveSettings,\n              qualityMode: newMode,\n              preloadCount: 2,\n              cacheSize: 100 * 1024 * 1024, // 100MB\n            },\n          };\n        } else {\n          return {\n            ...prev,\n            adaptiveSettings: {\n              ...prev.adaptiveSettings,\n              qualityMode: newMode,\n            },\n          };\n        }\n      });\n    },\n\n    runPerformanceTest: async (): Promise<PerformanceTestResult> => {\n      try {\n        const [networkProfile, memoryInfo] = await Promise.all([\n          networkProfiler.measureNetworkCondition(),\n          environmentDetector.getMemoryInfo(),\n        ]);\n\n        const deviceScore = calculateDeviceScore(memoryInfo);\n        const issues: string[] = [];\n\n        if (!networkProfile) {\n          throw new Error(\"Network test failed\");\n        }\n\n        if (networkProfile.bandwidth < 2) {\n          issues.push(\"Low bandwidth detected\");\n        }\n        if (networkProfile.latency > 100) {\n          issues.push(\"High latency detected\");\n        }\n        const memoryUsageRatio = (memoryInfo.totalMemory - memoryInfo.availableMemory) / memoryInfo.totalMemory;\n        if (memoryUsageRatio > 0.8) {\n          issues.push(\"High memory usage\");\n        }\n\n        const recommendedQuality = determineRecommendedQuality(networkProfile.bandwidth, deviceScore);\n\n        return {\n          bandwidth: networkProfile.bandwidth,\n          latency: networkProfile.latency,\n          deviceScore,\n          recommendedQuality,\n          issues,\n        };\n      } catch (error) {\n        console.error(\"Performance test failed:\", error);\n        throw error;\n      }\n    },\n\n    getRecommendedSettings: (): PerformanceRecommendations => {\n      const perfConfig = videoPerformanceConfig.getDynamicConfig();\n\n      let cacheStrategy: \"aggressive\" | \"balanced\" | \"conservative\";\n      if (state.deviceTier === DevicePerformanceTier.HIGH) {\n        cacheStrategy = \"aggressive\";\n      } else if (state.deviceTier === DevicePerformanceTier.MID) {\n        cacheStrategy = \"balanced\";\n      } else {\n        cacheStrategy = \"conservative\";\n      }\n\n      return {\n        quality: state.currentVideoQuality,\n        preloadCount: perfConfig.preloadProfile.preloadWindowSize,\n        cacheStrategy,\n        features: {\n          autoQualityUpgrade: perfConfig.features.autoQualityUpgrade,\n          backgroundProcessing: perfConfig.features.backgroundTranscoding,\n          aggressivePreloading: perfConfig.features.aggressivePreloading,\n        },\n      };\n    },\n  };\n\n  return [state, actions];\n}\n\n// Helper functions\nfunction calculateDeviceScore(memoryInfo: any): number {\n  const memoryGB = memoryInfo.totalMemory / (1024 * 1024 * 1024);\n  const memoryScore = Math.min(100, (memoryGB / 8) * 100);\n\n  // Simple scoring based on available memory\n  return memoryScore;\n}\n\nfunction determineRecommendedQuality(bandwidth: number, deviceScore: number): \"360p\" | \"720p\" | \"1080p\" {\n  const combinedScore = (bandwidth / 20) * 50 + (deviceScore / 100) * 50;\n\n  if (combinedScore >= 70) return \"1080p\";\n  if (combinedScore >= 40) return \"720p\";\n  return \"360p\";\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useVideoPlayers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/hooks/useVideoRecorder.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'cleanup'. Either include it or remove the dependency array.","line":134,"column":6,"nodeType":"ArrayExpression","endLine":134,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [cleanup]","fix":{"range":[4374,4376],"text":"[cleanup]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'startVideoProcessing'. Either include it or remove the dependency array.","line":184,"column":5,"nodeType":"ArrayExpression","endLine":184,"endColumn":58,"suggestions":[{"desc":"Update the dependencies array to be: [onRecordingStop, autoProcessAfterRecording, startVideoProcessing, onError]","fix":{"range":[5880,5933],"text":"[onRecordingStop, autoProcessAfterRecording, startVideoProcessing, onError]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'speechRecognitionRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'speechRecognitionRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":196,"column":30,"nodeType":"Identifier","endLine":196,"endColumn":37},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'startLiveTranscription'. Either include it or remove the dependency array.","line":252,"column":6,"nodeType":"ArrayExpression","endLine":261,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [isRecording, hasVideoPermissions, enableLiveCaptions, onRecordingStart, maxDuration, requestVideoPermissions, startLiveTranscription, onError]","fix":{"range":[7956,8123],"text":"[isRecording, hasVideoPermissions, enableLiveCaptions, onRecordingStart, maxDuration, requestVideoPermissions, startLiveTranscription, onError]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'stopLiveTranscription'. Either include it or remove the dependency array.","line":299,"column":6,"nodeType":"ArrayExpression","endLine":299,"endColumn":64,"suggestions":[{"desc":"Update the dependencies array to be: [isRecording, stopLiveTranscription, handleRecordingComplete, onError]","fix":{"range":[9277,9335],"text":"[isRecording, stopLiveTranscription, handleRecordingComplete, onError]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'startRealTimeSpeechRecognition'. Either include it or remove the dependency array.","line":463,"column":6,"nodeType":"ArrayExpression","endLine":463,"endColumn":26,"suggestions":[{"desc":"Update the dependencies array to be: [enableLiveCaptions, startRealTimeSpeechRecognition]","fix":{"range":[14757,14777],"text":"[enableLiveCaptions, startRealTimeSpeechRecognition]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'stopLiveTranscription'. Either include it or remove the dependency array.","line":531,"column":6,"nodeType":"ArrayExpression","endLine":531,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [stopLiveTranscription]","fix":{"range":[16745,16747],"text":"[stopLiveTranscription]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Video Recorder Hook with Real-time Effects\n * Comprehensive dual-mode support for Expo Go and development builds\n * Features: permissions, recording, face blur, pitch shifting, live captions\n */\n\nimport { useState, useRef, useCallback, useEffect } from \"react\";\nimport { Platform } from \"react-native\";\nimport { CameraView, CameraType } from \"expo-camera\";\nimport * as Audio from \"expo-audio\";\nimport { env } from \"../utils/env\";\nimport { useMediaPermissions } from \"./useMediaPermissions\";\nimport { unifiedVideoProcessingService, ProcessingMode } from \"../services/UnifiedVideoProcessingService\";\nimport type { ProcessedVideo, VideoProcessingOptions } from \"../services/IAnonymiser\";\n\nexport interface VideoRecorderState {\n  isRecording: boolean;\n  isProcessing: boolean;\n  recordingTime: number;\n  processingProgress: number;\n  processingStatus: string;\n  hasPermissions: boolean;\n  isInitialized: boolean;\n  error?: string;\n}\n\nexport interface VideoRecorderOptions {\n  maxDuration?: number;\n  quality?: \"high\" | \"medium\" | \"low\";\n  enableFaceBlur?: boolean;\n  enableVoiceChange?: boolean;\n  enableLiveCaptions?: boolean;\n  voiceEffect?: \"deep\" | \"light\";\n  processingMode?: ProcessingMode;\n  autoProcessAfterRecording?: boolean;\n  onRecordingStart?: () => void;\n  onRecordingStop?: (uri: string) => void;\n  onProcessingComplete?: (processed: ProcessedVideo) => void;\n  onError?: (error: string) => void;\n}\n\nexport interface VideoRecorderControls {\n  startRecording: () => Promise<void>;\n  stopRecording: () => Promise<void>;\n  pauseRecording: () => Promise<void>;\n  resumeRecording: () => Promise<void>;\n  toggleCamera: () => void;\n  reset: () => void;\n  cleanup: () => void;\n  startProcessing: () => Promise<void>;\n}\n\nexport interface VideoRecorderData {\n  cameraRef: React.RefObject<CameraView | null>;\n  facing: CameraType;\n  liveTranscription: string;\n  processedVideo?: ProcessedVideo;\n}\n\n/**\n * Comprehensive video recorder hook with real-time effects\n */\nexport const useVideoRecorder = (options: VideoRecorderOptions = {}) => {\n  const {\n    maxDuration = 60,\n    quality = \"medium\",\n    enableFaceBlur = true,\n    enableVoiceChange = true,\n    enableLiveCaptions = true,\n    voiceEffect = \"deep\",\n    processingMode = ProcessingMode.HYBRID,\n    autoProcessAfterRecording = true,\n    onRecordingStart,\n    onRecordingStop,\n    onProcessingComplete,\n    onError,\n  } = options;\n\n  // Refs\n  const cameraRef = useRef<CameraView>(null);\n  const recordingPromiseRef = useRef<Promise<{ uri: string }> | null>(null);\n  const recordingRef = useRef<any | null>(null);\n  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const audioRecorderRef = useRef<any | null>(null);\n  const speechRecognitionRef = useRef<any>(null);\n  const isRecordingRef = useRef<boolean>(false);\n\n  // State\n  const [facing, setFacing] = useState<CameraType>(\"front\");\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [isRecording, setIsRecording] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    isRecordingRef.current = isRecording;\n  }, [isRecording]);\n\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [processingProgress, setProcessingProgress] = useState(0);\n  const [processingStatus, setProcessingStatus] = useState(\"\");\n  const [liveTranscription, setLiveTranscription] = useState(\"\");\n  const [processedVideo, setProcessedVideo] = useState<ProcessedVideo | undefined>();\n  const [error, setError] = useState<string | undefined>();\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [recordedVideoUri, setRecordedVideoUri] = useState<string | null>(null);\n\n  // Permissions\n  const { permissionState, requestVideoPermissions, hasVideoPermissions } = useMediaPermissions({\n    autoRequest: false,\n    showAlerts: true,\n  });\n\n  // Initialize audio session for real-time effects\n  useEffect(() => {\n    const initializeAudio = async () => {\n      try {\n        await Audio.setAudioModeAsync({\n          allowsRecording: true,\n          playsInSilentMode: true,\n          interruptionModeAndroid: \"duckOthers\",\n        });\n      } catch (error) {\n        console.warn(\"Failed to initialize audio session:\", error);\n      }\n    };\n\n    initializeAudio();\n    setIsInitialized(true);\n\n    return () => {\n      cleanup();\n    };\n  }, []);\n\n  // Timer effect for recording duration\n  useEffect(() => {\n    if (isRecording && !isPaused) {\n      timerRef.current = setInterval(() => {\n        setRecordingTime((prev) => prev + 1);\n      }, 1000);\n    } else if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, [isRecording, isPaused]);\n\n  // Auto-stop recording when max duration reached\n  useEffect(() => {\n    if (recordingTime >= maxDuration && isRecording) {\n      stopRecordingRef.current?.();\n    }\n  }, [recordingTime, maxDuration, isRecording]);\n\n  const handleRecordingComplete = useCallback(\n    async (videoUri: string) => {\n      try {\n        console.log(\"🎬 Recording completed:\", videoUri);\n        setRecordedVideoUri(videoUri);\n        onRecordingStop?.(videoUri);\n\n        // Always call onRecordingStop callback regardless of autoProcessAfterRecording\n        // This ensures the UI can show the \"Next\" button\n        if (onRecordingStop) {\n          onRecordingStop(videoUri);\n        }\n\n        // Only start processing automatically if enabled\n        if (autoProcessAfterRecording) {\n          await startVideoProcessing(videoUri);\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"Failed to handle recording completion\";\n        setError(errorMessage);\n        onError?.(errorMessage);\n      }\n    },\n    [onRecordingStop, autoProcessAfterRecording, onError],\n  );\n\n  // Initialize speech recognition for live captions (if supported)\n  useEffect(() => {\n    if (enableLiveCaptions && Platform.OS === \"ios\") {\n      // iOS has built-in speech recognition\n      initializeSpeechRecognition();\n    }\n\n    return () => {\n      if (speechRecognitionRef.current) {\n        speechRecognitionRef.current.stop();\n      }\n    };\n  }, [enableLiveCaptions]);\n\n  const initializeSpeechRecognition = async () => {\n    try {\n      // Note: This would use a speech recognition library in production\n      // For now, we'll simulate live transcription\n      console.log(\"🎯 Initializing speech recognition for live captions\");\n    } catch (error) {\n      console.warn(\"Speech recognition initialization failed:\", error);\n    }\n  };\n\n  const startRecording = useCallback(async () => {\n    if (!cameraRef.current || isRecording) return;\n\n    try {\n      setError(undefined);\n\n      // Check permissions\n      if (!hasVideoPermissions) {\n        const granted = await requestVideoPermissions();\n        if (!granted) {\n          throw new Error(\"Camera and microphone permissions are required\");\n        }\n      }\n\n      // Start live transcription if enabled\n      if (enableLiveCaptions) {\n        setLiveTranscription(\"\");\n        startLiveTranscription();\n      }\n\n      // Start recording asynchronously\n      setIsRecording(true);\n      setRecordingTime(0);\n      setIsPaused(false);\n\n      onRecordingStart?.();\n\n      console.log(\"🎬 Starting camera recording...\");\n      // Type assertion to handle potential undefined return\n      recordingPromiseRef.current = cameraRef.current.recordAsync({\n        maxDuration,\n      }) as Promise<{ uri: string }>;\n    } catch (error) {\n      console.error(\"❌ Recording error:\", error);\n      const errorMessage = error instanceof Error ? error.message : \"Failed to start recording\";\n      setError(errorMessage);\n      onError?.(errorMessage);\n      setIsRecording(false);\n      setRecordingTime(0);\n      recordingPromiseRef.current = null;\n    }\n  }, [\n    cameraRef,\n    isRecording,\n    hasVideoPermissions,\n    requestVideoPermissions,\n    maxDuration,\n    enableLiveCaptions,\n    onRecordingStart,\n    onError,\n  ]);\n\n  const stopRecording = useCallback(async () => {\n    if (!cameraRef.current || !isRecording || !recordingPromiseRef.current) return;\n\n    try {\n      setIsRecording(false);\n      setIsPaused(false);\n\n      // Stop the recording\n      cameraRef.current.stopRecording();\n\n      // Wait for the promise to resolve\n      const video = await recordingPromiseRef.current;\n      recordingPromiseRef.current = null;\n\n      // Stop live transcription\n      stopLiveTranscription();\n\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n        timerRef.current = null;\n      }\n\n      console.log(\"🎬 Recording stopped:\", video);\n      if (video?.uri) {\n        await handleRecordingComplete(video.uri);\n      } else {\n        console.warn(\"⚠️ No video URI received from recording\");\n        setError(\"Recording failed - no video file created\");\n      }\n    } catch (error) {\n      console.error(\"❌ Stop recording error:\", error);\n      const errorMessage = error instanceof Error ? error.message : \"Failed to stop recording\";\n      setError(errorMessage);\n      onError?.(errorMessage);\n      recordingPromiseRef.current = null;\n    }\n  }, [cameraRef, isRecording, onError, handleRecordingComplete]);\n\n  // Refs for async operations\n  const stopRecordingRef = useRef<typeof stopRecording>(() => Promise.resolve());\n  useEffect(() => {\n    stopRecordingRef.current = stopRecording;\n  }, [stopRecording]);\n\n  const pauseRecording = useCallback(async () => {\n    if (!isRecording || isPaused) return;\n\n    try {\n      // Note: Camera recording pause/resume not directly supported\n      // This would require custom implementation with multiple segments\n      setIsPaused(true);\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n        timerRef.current = null;\n      }\n    } catch (error) {\n      console.warn(\"Failed to pause recording:\", error);\n    }\n  }, [isRecording, isPaused]);\n\n  const resumeRecording = useCallback(async () => {\n    if (!isRecording || !isPaused) return;\n\n    try {\n      setIsPaused(false);\n      // Restart timer\n      timerRef.current = setInterval(() => {\n        setRecordingTime((prev) => prev + 1);\n      }, 1000);\n    } catch (error) {\n      console.warn(\"Failed to resume recording:\", error);\n    }\n  }, [isRecording, isPaused]);\n\n  const startVideoProcessing = useCallback(\n    async (videoUri?: string) => {\n      const uriToProcess = videoUri || recordedVideoUri;\n      if (!uriToProcess) {\n        throw new Error(\"No video to process\");\n      }\n\n      try {\n        console.log(\"🎬 Starting video processing for:\", uriToProcess);\n\n        // Start processing\n        setIsProcessing(true);\n        setProcessingProgress(0);\n        setProcessingStatus(\"Starting video processing...\");\n\n        const processingOptions: VideoProcessingOptions = {\n          enableFaceBlur,\n          enableVoiceChange,\n          enableTranscription: true,\n          quality,\n          voiceEffect,\n          onProgress: (progress, status) => {\n            setProcessingProgress(progress);\n            setProcessingStatus(status);\n          },\n        };\n\n        let processed: ProcessedVideo;\n\n        if (env.expoGo) {\n          console.log(\"🎯 Processing video in Expo Go mode\");\n          // Expo Go mode - try local processing first, fallback to server\n          try {\n            processed = await unifiedVideoProcessingService.processVideo(uriToProcess, {\n              ...processingOptions,\n              mode: ProcessingMode.LOCAL,\n            });\n          } catch (localError) {\n            console.warn(\"Local processing failed in Expo Go, trying server:\", localError);\n            try {\n              processed = await unifiedVideoProcessingService.processVideo(uriToProcess, {\n                ...processingOptions,\n                mode: ProcessingMode.SERVER,\n              });\n            } catch (serverError) {\n              console.warn(\"Server processing failed, using fallback:\", serverError);\n              // Fallback: create a basic processed video object\n              processed = {\n                uri: uriToProcess,\n                width: 1920,\n                height: 1080,\n                duration: 30,\n                size: 0,\n                transcription: \"Transcription not available in Expo Go\",\n                faceBlurApplied: enableFaceBlur,\n                voiceChangeApplied: enableVoiceChange,\n              } as ProcessedVideo;\n            }\n          }\n        } else {\n          // Development build - use dual mode\n          processed = await unifiedVideoProcessingService.processVideo(uriToProcess, {\n            ...processingOptions,\n            mode: processingMode,\n          });\n        }\n\n        console.log(\"✅ Video processing completed successfully:\", processed);\n        setProcessedVideo(processed);\n        setIsProcessing(false);\n        setProcessingProgress(100);\n        setProcessingStatus(\"Processing complete!\");\n\n        console.log(\"🎯 Calling onProcessingComplete callback...\");\n        if (onProcessingComplete) {\n          onProcessingComplete(processed);\n          console.log(\"✅ onProcessingComplete callback called\");\n        } else {\n          console.warn(\"⚠️ No onProcessingComplete callback provided\");\n        }\n      } catch (error) {\n        console.error(\"❌ Video processing failed:\", error);\n        console.error(\"❌ Error details:\", {\n          message: error instanceof Error ? error.message : \"Unknown error\",\n          stack: error instanceof Error ? error.stack : undefined,\n          error,\n        });\n        const errorMessage = error instanceof Error ? error.message : \"Video processing failed\";\n        setError(errorMessage);\n        if (onError) {\n          onError(errorMessage);\n          console.log(\"✅ onError callback called with:\", errorMessage);\n        } else {\n          console.warn(\"⚠️ No onError callback provided\");\n        }\n        setIsProcessing(false);\n        setProcessingProgress(0);\n        setProcessingStatus(\"\");\n      }\n    },\n    [\n      enableFaceBlur,\n      enableVoiceChange,\n      quality,\n      voiceEffect,\n      processingMode,\n      onProcessingComplete,\n      onError,\n      recordedVideoUri,\n    ],\n  );\n\n  const startLiveTranscription = useCallback(async () => {\n    if (!enableLiveCaptions) return;\n\n    try {\n      if (env.expoGo) {\n        // Expo Go - simulate live transcription\n        simulateLiveTranscription();\n      } else {\n        // Development build - use real speech recognition\n        await startRealTimeSpeechRecognition();\n      }\n    } catch (error) {\n      console.warn(\"Failed to start live transcription:\", error);\n    }\n  }, [enableLiveCaptions]);\n\n  const stopLiveTranscription = useCallback(() => {\n    if (speechRecognitionRef.current) {\n      speechRecognitionRef.current.stop();\n    }\n    setLiveTranscription(\"\");\n  }, []);\n\n  const simulateLiveTranscription = () => {\n    // Simulate live transcription for demo purposes\n    const phrases = [\n      \"I'm recording my anonymous confession...\",\n      \"This is something I've never shared before...\",\n      \"I need to get this off my chest...\",\n      \"Here's my story...\",\n    ];\n\n    let currentIndex = 0;\n    const interval = setInterval(() => {\n      if (currentIndex < phrases.length && isRecordingRef.current) {\n        setLiveTranscription(phrases[currentIndex]);\n        currentIndex++;\n      } else {\n        clearInterval(interval);\n      }\n    }, 3000);\n\n    // Clear interval when recording stops\n    return () => clearInterval(interval);\n  };\n\n  const startRealTimeSpeechRecognition = async () => {\n    try {\n      // This would integrate with a speech recognition service\n      // For now, we'll use the existing transcribe-audio API periodically\n      console.log(\"🎯 Starting real-time speech recognition\");\n\n      // Placeholder for real implementation\n      // Would use libraries like @react-native-voice/voice or similar\n    } catch (error) {\n      console.warn(\"Real-time speech recognition failed:\", error);\n      // Fallback to simulation\n      simulateLiveTranscription();\n    }\n  };\n\n  const toggleCamera = useCallback(() => {\n    setFacing((current) => (current === \"back\" ? \"front\" : \"back\"));\n  }, []);\n\n  const reset = useCallback(() => {\n    setIsRecording(false);\n    setIsPaused(false);\n    setRecordingTime(0);\n    setIsProcessing(false);\n    setProcessingProgress(0);\n    setProcessingStatus(\"\");\n    setLiveTranscription(\"\");\n    setProcessedVideo(undefined);\n    setError(undefined);\n\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n\n    stopLiveTranscription();\n  }, []);\n\n  const cleanup = useCallback(() => {\n    reset();\n\n    if (recordingRef.current) {\n      recordingRef.current = null;\n    }\n\n    if (audioRecorderRef.current) {\n      audioRecorderRef.current = null;\n    }\n  }, [reset]);\n\n  // State object\n  const state: VideoRecorderState = {\n    isRecording,\n    isProcessing,\n    recordingTime,\n    processingProgress,\n    processingStatus,\n    hasPermissions: permissionState.camera && permissionState.microphone,\n    isInitialized,\n    error,\n  };\n\n  // Controls object\n  const controls: VideoRecorderControls = {\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    toggleCamera,\n    reset,\n    cleanup,\n    startProcessing: startVideoProcessing,\n  };\n\n  // Data object\n  const data: VideoRecorderData = {\n    cameraRef,\n    facing,\n    liveTranscription,\n    processedVideo,\n  };\n\n  return {\n    state,\n    controls,\n    data,\n    // Convenience getters\n    isRecording,\n    isProcessing,\n    recordingTime,\n    hasPermissions: hasVideoPermissions,\n    error,\n    requestPermissions: requestVideoPermissions,\n    permissionState,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/authStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/confessionStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/consentStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/globalVideoStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DisposalConfig' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mapDisposalStrategy' is assigned a value but never used.","line":81,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":208,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'results' is assigned a value but never used.","line":247,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":247,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { registerStoreCleanup } from \"../utils/storeCleanup\";\nimport { trackStoreOperation } from \"../utils/storePerformanceMonitor\";\nimport {\n  VideoPlayerInterface,\n  VideoPlayerState,\n  VideoPlayerCapabilities,\n  VideoPlaybackState,\n} from \"../types/videoPlayer\";\nimport { BaseVideoError, VideoErrorCode, VideoErrorSeverity } from \"../types/videoErrors\";\nimport {\n  disposeVideoPlayer,\n  scheduleVideoPlayerDisposal,\n  DisposalStrategy,\n  DisposalConfig,\n} from \"../utils/videoPlayerDisposal\";\n\ninterface VideoPlayerRef {\n  id: string;\n  player: VideoPlayerInterface;\n  state: VideoPlayerState;\n  capabilities: VideoPlayerCapabilities;\n  playbackState?: VideoPlaybackState;\n  lastActivity: number;\n  disposalAttempts: number;\n  errorCount: number;\n}\n\n// Comment 3: Use plain POJO for serializable error\ninterface SerializableError {\n  code: VideoErrorCode;\n  message: string;\n  severity: VideoErrorSeverity;\n  at: number;\n}\n\ninterface PlayerMetadata {\n  isPlaying: boolean;\n  lastError?: SerializableError;\n  recoveryAttempts: number;\n  lastRecoveryTime?: number;\n}\n\ninterface GlobalVideoState {\n  videoPlayers: Map<string, VideoPlayerRef>;\n  playersMeta: Record<string, PlayerMetadata>;\n  currentTab: string;\n  hermesCompatMode: boolean;\n  cleanupInterval?: NodeJS.Timeout;\n  errorMetrics: {\n    disposalErrors: number;\n    recoverySuccesses: number;\n    totalErrors: number;\n  };\n\n  // Actions\n  registerVideoPlayer: (id: string, player: VideoPlayerInterface, capabilities?: VideoPlayerCapabilities) => void;\n  unregisterVideoPlayer: (id: string) => Promise<void>;\n  pauseAllVideos: () => Promise<void>;\n  resumeVideosForTab: (tabName: string) => Promise<void>;\n  setCurrentTab: (tabName: string) => void;\n  updatePlayerState: (id: string, state: Partial<VideoPlaybackState>) => void;\n  recoverPlayer: (id: string) => Promise<boolean>;\n  cleanupStalePlayers: () => Promise<void>;\n  updateErrorMetrics: (type: \"disposal\" | \"recovery\" | \"general\", success: boolean) => void;\n}\n\n// Hermes detection utility\nconst isHermesRuntime = (): boolean => {\n  try {\n    // @ts-ignore - HermesInternal is a global object in Hermes runtime\n    return typeof HermesInternal !== \"undefined\";\n  } catch {\n    return false;\n  }\n};\n\n// Comment 1: Map disposal strategy types\nconst mapDisposalStrategy = (type: \"immediate\" | \"delayed\" | \"forced\"): DisposalStrategy => {\n  switch (type) {\n    case \"immediate\":\n      return DisposalStrategy.GRACEFUL;\n    case \"delayed\":\n      return DisposalStrategy.SCHEDULED;\n    case \"forced\":\n      return DisposalStrategy.FORCED;\n    default:\n      return DisposalStrategy.GRACEFUL;\n  }\n};\n\nexport const useGlobalVideoStore = create<GlobalVideoState>()(\n  persist(\n    (set, get) => ({\n      videoPlayers: new Map(),\n      playersMeta: {},\n      currentTab: \"Home\",\n      hermesCompatMode: isHermesRuntime(),\n      cleanupInterval: undefined,\n      errorMetrics: {\n        disposalErrors: 0,\n        recoverySuccesses: 0,\n        totalErrors: 0,\n      },\n\n      registerVideoPlayer: (id, player, capabilities) => {\n        const t0 = Date.now();\n        const { videoPlayers, playersMeta } = get();\n        const newPlayers = new Map(videoPlayers);\n\n        // Clean up existing player if it exists\n        const existingPlayer = videoPlayers.get(id);\n        if (existingPlayer?.player) {\n          // Comment 1 & 8: Use centralized disposal utility with schedule\n          scheduleVideoPlayerDisposal(id, existingPlayer.player, 0, {\n            strategy: DisposalStrategy.SCHEDULED,\n            timeout: 1000,\n            retries: 2,\n          });\n        }\n\n        // Create new player reference with enhanced metadata\n        const playerRef: VideoPlayerRef = {\n          id,\n          player,\n          state: VideoPlayerState.Idle,\n          capabilities: capabilities || {\n            canPlay: true,\n            canPause: true,\n            canSeek: false,\n            canSetVolume: true,\n            canSetPlaybackRate: false,\n            supportsFullscreen: false,\n            supportsPiP: false,\n          },\n          lastActivity: Date.now(),\n          disposalAttempts: 0,\n          errorCount: 0,\n        };\n\n        // Preserve existing metadata\n        const isPlaying = playersMeta[id]?.isPlaying ?? false;\n        newPlayers.set(id, playerRef);\n\n        set({\n          videoPlayers: newPlayers,\n          playersMeta: {\n            ...playersMeta,\n            [id]: {\n              isPlaying,\n              recoveryAttempts: 0,\n            },\n          },\n        });\n\n        trackStoreOperation(\"globalVideoStore\", \"registerVideoPlayer\", Date.now() - t0);\n\n        // Start cleanup interval if not running\n        if (!get().cleanupInterval) {\n          const interval = setInterval(() => {\n            get().cleanupStalePlayers();\n          }, 30000); // Run every 30 seconds\n          set({ cleanupInterval: interval });\n        }\n      },\n\n      // Comment 2: Always remove player from store, force dispose on failure\n      unregisterVideoPlayer: async (id) => {\n        const t0 = Date.now();\n        const { videoPlayers, playersMeta } = get();\n        const playerRef = videoPlayers.get(id);\n\n        // Always remove from store first\n        const newPlayers = new Map(videoPlayers);\n        newPlayers.delete(id);\n        const { [id]: _removed, ...restMeta } = playersMeta;\n\n        set({\n          videoPlayers: newPlayers,\n          playersMeta: restMeta,\n        });\n\n        // Attempt disposal if player exists\n        if (playerRef?.player) {\n          try {\n            // Comment 1: Use centralized disposal utility\n            const result = await disposeVideoPlayer(id, playerRef.player, {\n              strategy: DisposalStrategy.GRACEFUL,\n              timeout: 500,\n              retries: 3,\n            });\n\n            if (result.success) {\n              get().updateErrorMetrics(\"disposal\", true);\n            } else {\n              // Comment 2: Force disposal in background on failure\n              disposeVideoPlayer(id, playerRef.player, {\n                strategy: DisposalStrategy.FORCED,\n                retries: 1,\n                timeout: 100,\n              }).then(\n                () => get().updateErrorMetrics(\"disposal\", true),\n                () => get().updateErrorMetrics(\"disposal\", false),\n              );\n            }\n          } catch (error) {\n            get().updateErrorMetrics(\"disposal\", false);\n\n            // Comment 2: Force disposal in background\n            disposeVideoPlayer(id, playerRef.player, {\n              strategy: DisposalStrategy.FORCED,\n              retries: 1,\n              timeout: 100,\n            }).catch(() => {\n              // Ignore errors, player is already removed from store\n            });\n          }\n        }\n\n        trackStoreOperation(\"globalVideoStore\", \"unregisterVideoPlayer\", Date.now() - t0);\n      },\n\n      pauseAllVideos: async () => {\n        const t0 = Date.now();\n        const { videoPlayers, playersMeta } = get();\n\n        const pauseOperations = Array.from(videoPlayers.entries()).map(async ([id, playerRef]) => {\n          try {\n            if (playerRef.player) {\n              if (typeof playerRef.player.pause === \"function\") {\n                await playerRef.player.pause();\n              }\n              if (typeof playerRef.player.setMuted === \"function\") {\n                playerRef.player.setMuted(true);\n              }\n            }\n            return { id, success: true };\n          } catch (error) {\n            get().updateErrorMetrics(\"general\", false);\n            if (__DEV__) console.warn(`🎥 Failed to pause video ${id}:`, error);\n            return { id, success: false };\n          }\n        });\n\n        const results = await Promise.allSettled(pauseOperations);\n\n        // Update metadata for all players\n        const nextMeta: Record<string, PlayerMetadata> = {};\n        Object.keys(playersMeta).forEach((k) => {\n          nextMeta[k] = { ...playersMeta[k], isPlaying: false };\n        });\n        set({ playersMeta: nextMeta });\n\n        trackStoreOperation(\"globalVideoStore\", \"pauseAllVideos\", Date.now() - t0);\n      },\n\n      resumeVideosForTab: async (tabName) => {\n        const t0 = Date.now();\n        const { videoPlayers, currentTab, playersMeta } = get();\n\n        if (tabName === \"Videos\" && currentTab === \"Videos\") {\n          const resumeOperations = Array.from(videoPlayers.entries()).map(async ([id, playerRef]) => {\n            try {\n              if (playerRef.player && playersMeta[id]?.isPlaying) {\n                if (typeof playerRef.player.setMuted === \"function\") {\n                  playerRef.player.setMuted(false);\n                }\n                if (typeof playerRef.player.play === \"function\") {\n                  await playerRef.player.play();\n                }\n              }\n              return { id, success: true };\n            } catch (error) {\n              get().updateErrorMetrics(\"general\", false);\n\n              // Attempt recovery\n              const recovered = await get().recoverPlayer(id);\n              if (!recovered && __DEV__) {\n                console.warn(`🎥 Failed to resume video ${id}:`, error);\n              }\n              return { id, success: recovered };\n            }\n          });\n\n          await Promise.allSettled(resumeOperations);\n        }\n\n        trackStoreOperation(\"globalVideoStore\", \"resumeVideosForTab\", Date.now() - t0);\n      },\n\n      setCurrentTab: (tabName) => {\n        const { currentTab } = get();\n        if (currentTab !== tabName) {\n          if (tabName !== \"Videos\") {\n            get().pauseAllVideos();\n          }\n          set({ currentTab: tabName });\n          if (tabName === \"Videos\") {\n            requestAnimationFrame(() => get().resumeVideosForTab(tabName));\n          }\n        }\n      },\n\n      // Comment 7: Improved state derivation logic\n      updatePlayerState: (id, state) => {\n        const { videoPlayers, playersMeta } = get();\n        const playerRef = videoPlayers.get(id);\n\n        if (playerRef) {\n          const newPlayers = new Map(videoPlayers);\n          const updatedRef: VideoPlayerRef = {\n            ...playerRef,\n            playbackState: { ...playerRef.playbackState, ...state },\n            lastActivity: Date.now(),\n          };\n\n          // Only derive state when both values are meaningful\n          if (\n            state.currentTime !== undefined &&\n            state.duration !== undefined &&\n            state.currentTime > 0 &&\n            state.duration > 0\n          ) {\n            updatedRef.state = state.currentTime > 0 ? VideoPlayerState.Playing : VideoPlayerState.Idle;\n          }\n\n          newPlayers.set(id, updatedRef);\n\n          set({\n            videoPlayers: newPlayers,\n            playersMeta: {\n              ...playersMeta,\n              [id]: {\n                ...playersMeta[id],\n                isPlaying: state.isPlaying ?? playersMeta[id]?.isPlaying ?? false,\n              },\n            },\n          });\n        } else {\n          set({\n            playersMeta: {\n              ...playersMeta,\n              [id]: {\n                ...playersMeta[id],\n                isPlaying: state.isPlaying ?? false,\n              },\n            },\n          });\n        }\n      },\n\n      recoverPlayer: async (id) => {\n        const { videoPlayers, playersMeta } = get();\n        const playerRef = videoPlayers.get(id);\n\n        if (!playerRef?.player) return false;\n\n        const metadata = playersMeta[id];\n        if (metadata?.recoveryAttempts >= 3) {\n          return false; // Too many recovery attempts\n        }\n\n        try {\n          const playerInstance = playerRef.player as any;\n          if (typeof playerInstance?.reset === \"function\") {\n            await playerInstance.reset();\n          }\n\n          // Update recovery metrics\n          set({\n            playersMeta: {\n              ...playersMeta,\n              [id]: {\n                ...metadata,\n                recoveryAttempts: (metadata?.recoveryAttempts || 0) + 1,\n                lastRecoveryTime: Date.now(),\n              },\n            },\n          });\n\n          get().updateErrorMetrics(\"recovery\", true);\n          return true;\n        } catch (error) {\n          get().updateErrorMetrics(\"recovery\", false);\n\n          const message = error instanceof Error ? error.message : String(error);\n\n          if (error instanceof BaseVideoError) {\n            set({\n              playersMeta: {\n                ...playersMeta,\n                [id]: {\n                  ...playersMeta[id],\n                  lastError: {\n                    code: error.code,\n                    message,\n                    severity: error.severity || VideoErrorSeverity.ERROR,\n                    at: Date.now(),\n                  },\n                },\n              },\n            });\n          } else {\n            set({\n              playersMeta: {\n                ...playersMeta,\n                [id]: {\n                  ...playersMeta[id],\n                  lastError: {\n                    code: VideoErrorCode.Unknown,\n                    message,\n                    severity: VideoErrorSeverity.ERROR,\n                    at: Date.now(),\n                  },\n                },\n              },\n            });\n          }\n          return false;\n        }\n      },\n\n      cleanupStalePlayers: async () => {\n        const { videoPlayers } = get();\n        const now = Date.now();\n        const staleThreshold = 5 * 60 * 1000; // 5 minutes\n\n        const stalePlayerIds: string[] = [];\n\n        videoPlayers.forEach((playerRef, id) => {\n          if (now - playerRef.lastActivity > staleThreshold) {\n            stalePlayerIds.push(id);\n          }\n        });\n\n        for (const id of stalePlayerIds) {\n          await get().unregisterVideoPlayer(id);\n        }\n      },\n\n      updateErrorMetrics: (type, success) => {\n        const { errorMetrics } = get();\n        const newMetrics = { ...errorMetrics };\n\n        switch (type) {\n          case \"disposal\":\n            if (!success) newMetrics.disposalErrors++;\n            break;\n          case \"recovery\":\n            if (success) newMetrics.recoverySuccesses++;\n            break;\n          case \"general\":\n            if (!success) newMetrics.totalErrors++;\n            break;\n        }\n\n        set({ errorMetrics: newMetrics });\n      },\n    }),\n    {\n      name: \"global-video-store\",\n      storage: createJSONStorage(() => AsyncStorage),\n      partialize: (state) => ({\n        currentTab: state.currentTab,\n        playersMeta: state.playersMeta,\n        errorMetrics: state.errorMetrics,\n      }),\n      version: 2,\n    },\n  ),\n);\n\n// Centralized cleanup registration with enhanced disposal\nregisterStoreCleanup(\"globalVideoStore\", async () => {\n  const state = useGlobalVideoStore.getState();\n  const { videoPlayers } = state;\n\n  // Clear cleanup interval\n  if (state.cleanupInterval) {\n    clearInterval(state.cleanupInterval);\n  }\n\n  // Comment 1: Use centralized disposal utility\n  const disposalPromises = Array.from(videoPlayers.entries()).map(([id, playerRef]) =>\n    disposeVideoPlayer(id, playerRef.player, {\n      strategy: DisposalStrategy.FORCED,\n      timeout: 100,\n      retries: 1,\n    }),\n  );\n\n  await Promise.allSettled(disposalPromises);\n\n  useGlobalVideoStore.setState({\n    videoPlayers: new Map(),\n    cleanupInterval: undefined,\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/membershipStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/navigationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/notificationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/replyStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'replyIds' is assigned a value but never used.","line":267,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":267,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is assigned a value but never used.","line":1122,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":1122,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\nimport { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { supabase } from \"../lib/supabase\";\nimport { wrapWithRetry } from \"../utils/supabaseWithRetry\";\nimport { invalidateCache } from \"../utils/cacheInvalidation\";\nimport { isValidForDatabase } from \"../utils/consolidatedUtils\";\nimport { registerStoreCleanup } from \"../utils/storeCleanup\";\nimport { trackStoreOperation } from \"../utils/storePerformanceMonitor\";\nimport { VideoDataService } from \"../services/VideoDataService\";\n\n// Debounce utility for preventing race conditions\nconst pendingOperations = new Map<string, Promise<any>>();\n\nconst debouncedOperation = async <T>(key: string, operation: () => Promise<T>): Promise<T> => {\n  if (pendingOperations.has(key)) {\n    return pendingOperations.get(key) as Promise<T>;\n  }\n\n  const promise = operation().finally(() => {\n    pendingOperations.delete(key);\n  });\n\n  pendingOperations.set(key, promise);\n  return promise;\n};\n\n// Comment reaction types - exported for use in components\nexport type ReactionType = \"heart\" | \"laugh\" | \"sad\" | \"angry\" | \"wow\" | \"thumbs_up\";\n\nexport interface Reaction {\n  id: string;\n  reply_id: string;\n  user_id: string;\n  type: ReactionType;\n  created_at: string;\n}\n\n/**\n * Enhanced Reply interface with threading support\n */\nexport interface Reply {\n  id: string;\n  confessionId: string;\n  userId?: string;\n  content: string;\n  isAnonymous: boolean;\n  likes: number;\n  isLiked?: boolean;\n  timestamp: number;\n  // New threading fields\n  parentId?: string | null;\n  replies?: Reply[];\n  replyCount?: number;\n  depth?: number;\n  // New reaction fields\n  reactions?: Reaction[];\n  reactionCounts?: Record<ReactionType, number>;\n  userReactions?: ReactionType[];\n  // New metadata fields\n  edited_at?: string;\n  deleted_at?: string;\n  flagged?: boolean;\n  flag_reason?: string;\n  // Draft support\n  isDraft?: boolean;\n  draftId?: string;\n}\n\n/**\n * Enhanced database reply record structure\n */\ninterface DatabaseReplyRecord {\n  id: string;\n  confession_id: string;\n  user_id: string | null;\n  content: string;\n  is_anonymous: boolean;\n  likes: number;\n  created_at: string;\n  parent_id?: string | null;\n  reply_count?: number;\n  edited_at?: string;\n  deleted_at?: string;\n  flagged?: boolean;\n  flag_reason?: string;\n}\n\n// Typing indicator state\ninterface TypingUser {\n  userId: string;\n  replyId?: string;\n  timestamp: number;\n}\n\n// Comment draft\ninterface CommentDraft {\n  id: string;\n  confessionId: string;\n  content: string;\n  parentId?: string;\n  timestamp: number;\n}\n\nexport interface ReplyState {\n  replies: Record<string, Reply[]>;\n  pagination: Record<\n    string,\n    {\n      hasMore: boolean;\n      lastCreatedAt?: string;\n      isLoadingMore?: boolean;\n      isLoading?: boolean;\n      cursor?: string;\n      totalCount?: number;\n    }\n  >;\n  loading: boolean;\n  error: string | null;\n\n  // New state fields\n  typingUsers: Record<string, TypingUser[]>; // confessionId -> typing users\n  drafts: Record<string, CommentDraft>; // confessionId -> draft\n  searchResults: Record<string, Reply[]>; // confessionId -> search results\n  searchQuery: string;\n  offlineQueue: {\n    type: \"add\" | \"edit\" | \"delete\" | \"react\";\n    payload: any;\n    timestamp: number;\n  }[];\n  connectionStatus: \"online\" | \"offline\" | \"reconnecting\";\n\n  // Enhanced actions\n  loadReplies: (confessionId: string, parentId?: string) => Promise<void>;\n  loadMoreReplies: (confessionId: string) => Promise<void>;\n  addReply: (confessionId: string, content: string, isAnonymous?: boolean, parentId?: string | null) => Promise<void>;\n  deleteReply: (replyId: string, confessionId?: string) => Promise<void>;\n  editReply: (replyId: string, content: string) => Promise<void>;\n  toggleReplyLike: (replyId: string, confessionId: string) => Promise<void>;\n\n  // New threading actions\n  loadThreadReplies: (parentId: string) => Promise<void>;\n  collapseThread: (replyId: string) => void;\n  expandThread: (replyId: string) => void;\n\n  // New reaction actions\n  addReaction: (replyId: string, type: ReactionType) => Promise<void>;\n  removeReaction: (replyId: string, type: ReactionType) => Promise<void>;\n\n  // New search actions\n  searchComments: (confessionId: string, query: string) => Promise<void>;\n  clearSearch: () => void;\n\n  // New moderation actions\n  reportComment: (replyId: string, reason: string) => Promise<void>;\n  flagComment: (replyId: string, reason: string) => Promise<void>;\n\n  // New typing indicator actions\n  startTyping: (confessionId: string, parentId?: string) => void;\n  stopTyping: (confessionId: string, parentId?: string) => void;\n\n  // New draft actions\n  saveDraft: (confessionId: string, content: string, parentId?: string) => void;\n  loadDraft: (confessionId: string) => CommentDraft | null;\n  clearDraft: (confessionId: string) => void;\n\n  // New offline support actions\n  processOfflineQueue: () => Promise<void>;\n  setConnectionStatus: (status: \"online\" | \"offline\" | \"reconnecting\") => void;\n\n  // Real-time subscription management\n  subscribeToReplies: (confessionId: string) => void;\n  unsubscribeFromReplies: () => void;\n  subscribeToTypingIndicators: (confessionId: string) => void;\n  unsubscribeFromTypingIndicators: () => void;\n\n  // Utility actions\n  bulkDeleteReplies: (replyIds: string[], confessionId: string) => Promise<void>;\n  bulkToggleReplyLikes: (replyIds: string[], confessionId: string, like: boolean) => Promise<void>;\n  clearError: () => void;\n  getRepliesForConfession: (confessionId: string) => Reply[];\n}\n\n// Real-time subscription channels\nlet repliesChannel: any = null;\nlet typingChannel: any = null;\nlet reconnectTimer: any = null;\nlet reconnectAttempts = 0;\nlet typingTimers: Record<string, NodeJS.Timeout> = {};\n\nexport const useReplyStore = create<ReplyState>()(\n  persist(\n    (set, get) => ({\n      replies: {},\n      pagination: {},\n      loading: false,\n      error: null,\n      typingUsers: {},\n      drafts: {},\n      searchResults: {},\n      searchQuery: \"\",\n      offlineQueue: [],\n      connectionStatus: \"online\",\n\n      loadReplies: async (confessionId: string, parentId?: string) => {\n        set({ loading: true, error: null });\n        try {\n          trackStoreOperation(\"replyStore\", \"loadReplies\", Date.now());\n\n          if (!isValidForDatabase(confessionId)) {\n            set((state) => ({\n              replies: { ...state.replies, [confessionId]: [] },\n              loading: false,\n            }));\n            return;\n          }\n\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n\n          const INITIAL_LIMIT = 20;\n          let query = supabase\n            .from(\"replies\")\n            .select(\n              `\n              *,\n              reactions:comment_reactions(*),\n              replies:replies!parent_id(count)\n            `,\n            )\n            .eq(\"confession_id\", confessionId)\n            .order(\"created_at\", { ascending: false })\n            .limit(INITIAL_LIMIT);\n\n          if (parentId) {\n            query = query.eq(\"parent_id\", parentId);\n          } else {\n            query = query.is(\"parent_id\", null);\n          }\n\n          const { data, error } = await wrapWithRetry(async () => query)();\n\n          if (error) throw error;\n\n          const rows = (data ?? []) as {\n            id: string;\n            confession_id: string;\n            user_id?: string | null;\n            content: string;\n            is_anonymous: boolean;\n            likes?: number | null;\n            created_at: string;\n            replies?: { count: number }[] | null;\n            reactions?: { type: string }[] | null;\n            edited_at?: string | null;\n            deleted_at?: string | null;\n            flagged?: boolean;\n            flag_reason?: string | null;\n            parent_id?: string | null;\n          }[];\n\n          // Get user reactions if authenticated\n          let userReactions: Record<string, ReactionType[]> = {};\n          if (user && rows.length > 0) {\n            const replyIds = rows.map((reply) => reply.id);\n            // Comment reactions table not yet implemented\n            const reactionsData: any[] = [];\n\n            if (reactionsData) {\n              reactionsData.forEach((r) => {\n                if (!userReactions[r.reply_id]) userReactions[r.reply_id] = [];\n                userReactions[r.reply_id].push(r.type as ReactionType);\n              });\n            }\n          }\n\n          // Get user likes\n          let userLikes: string[] = [];\n          if (user && rows.length > 0) {\n            const replyIds = rows.map((reply) => reply.id);\n            const { data: likesData } = await supabase\n              .from(\"user_likes\")\n              .select(\"reply_id\")\n              .eq(\"user_id\", user.id)\n              .in(\"reply_id\", replyIds);\n\n            const likeRows = (likesData ?? []) as { reply_id: string | null }[];\n            userLikes = likeRows.map((like) => like.reply_id).filter((id): id is string => Boolean(id));\n          }\n\n          const replies: Reply[] = rows.map((item) => {\n            const reactionCounts: Record<ReactionType, number> = {\n              heart: 0,\n              laugh: 0,\n              sad: 0,\n              angry: 0,\n              wow: 0,\n              thumbs_up: 0,\n            };\n\n            const reply: Reply = {\n              id: item.id,\n              confessionId: item.confession_id,\n              userId: item.user_id || undefined,\n              content: item.content,\n              isAnonymous: item.is_anonymous,\n              likes: item.likes || 0,\n              isLiked: userLikes.includes(item.id),\n              timestamp: new Date(item.created_at).getTime(),\n              parentId: item.parent_id || undefined,\n              replyCount: item.replies?.[0]?.count || 0,\n              reactions: [],\n              reactionCounts,\n              userReactions: userReactions[item.id] || [],\n              edited_at: item.edited_at || undefined,\n              deleted_at: item.deleted_at || undefined,\n              flagged: item.flagged,\n              flag_reason: item.flag_reason || undefined,\n            };\n\n            return reply;\n          });\n\n          const hasMore = rows.length >= INITIAL_LIMIT;\n          const lastCreatedAt = rows[rows.length - 1]?.created_at;\n\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: replies,\n            },\n            pagination: {\n              ...state.pagination,\n              [confessionId]: {\n                hasMore,\n                lastCreatedAt,\n                isLoadingMore: false,\n                isLoading: false,\n                totalCount: replies.length,\n              },\n            },\n            loading: false,\n          }));\n\n          // Track analytics\n          VideoDataService.trackVideoEvent(\"comments_loaded\", {\n            confession_id: confessionId,\n            count: replies.length,\n            has_parent: !!parentId,\n          });\n        } catch (error) {\n          console.error(\"Error loading replies:\", error);\n          set({\n            error: error instanceof Error ? error.message : \"Failed to load comments\",\n            loading: false,\n          });\n        }\n      },\n\n      loadMoreReplies: async (confessionId: string) => {\n        const state = get();\n        const page = state.pagination[confessionId];\n        if (!page || page.isLoadingMore || !page.hasMore) return;\n\n        set({\n          pagination: {\n            ...state.pagination,\n            [confessionId]: { ...page, isLoadingMore: true },\n          },\n        });\n\n        try {\n          const LIMIT = 10;\n          let query = supabase\n            .from(\"replies\")\n            .select(\n              `\n              *,\n              reactions:comment_reactions(*),\n              replies:replies!parent_id(count)\n            `,\n            )\n            .eq(\"confession_id\", confessionId)\n            .is(\"parent_id\", null)\n            .order(\"created_at\", { ascending: false })\n            .limit(LIMIT);\n\n          if (page.lastCreatedAt) {\n            query = query.lt(\"created_at\", page.lastCreatedAt);\n          }\n\n          const { data, error } = await wrapWithRetry(async () => query)();\n          if (error) throw error;\n\n          const newReplies: Reply[] = (data || []).map((item) => ({\n            id: item.id,\n            confessionId: item.confession_id,\n            userId: item.user_id || undefined,\n            content: item.content,\n            isAnonymous: item.is_anonymous,\n            likes: item.likes || 0,\n            timestamp: new Date(item.created_at).getTime(),\n            parentId: (item as any).parent_id,\n            replyCount: item.replies?.[0]?.count || 0,\n            reactions: item.reactions || [],\n          }));\n\n          const hasMore = (data?.length || 0) >= LIMIT;\n          const lastCreatedAt = data?.[data.length - 1]?.created_at || page.lastCreatedAt;\n\n          set((curr) => ({\n            replies: {\n              ...curr.replies,\n              [confessionId]: [...(curr.replies[confessionId] || []), ...newReplies],\n            },\n            pagination: {\n              ...curr.pagination,\n              [confessionId]: {\n                hasMore,\n                lastCreatedAt,\n                isLoadingMore: false,\n                totalCount: (curr.replies[confessionId]?.length || 0) + newReplies.length,\n              },\n            },\n          }));\n        } catch (error) {\n          set((curr) => ({\n            error: error instanceof Error ? error.message : \"Failed to load more comments\",\n            pagination: {\n              ...curr.pagination,\n              [confessionId]: { ...(curr.pagination[confessionId] || {}), isLoadingMore: false },\n            },\n          }));\n        }\n      },\n\n      addReply: async (confessionId: string, content: string, isAnonymous = true, parentId?: string | null) => {\n        const state = get();\n\n        // Save to offline queue if offline\n        if (state.connectionStatus === \"offline\") {\n          set((state) => ({\n            offlineQueue: [\n              ...state.offlineQueue,\n              {\n                type: \"add\",\n                payload: { confessionId, content, isAnonymous, parentId },\n                timestamp: Date.now(),\n              },\n            ],\n          }));\n          return;\n        }\n\n        set({ loading: true, error: null });\n        try {\n          if (!isValidForDatabase(confessionId)) {\n            throw new Error(\"Cannot add replies to sample confessions\");\n          }\n\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n\n          // Optimistic update\n          const tempId = `temp-${Date.now()}`;\n          const optimisticReply: Reply = {\n            id: tempId,\n            confessionId,\n            userId: user?.id,\n            content: content.trim(),\n            isAnonymous,\n            likes: 0,\n            isLiked: false,\n            timestamp: Date.now(),\n            parentId,\n            reactions: [],\n            reactionCounts: { heart: 0, laugh: 0, sad: 0, angry: 0, wow: 0, thumbs_up: 0 },\n            userReactions: [],\n          };\n\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: [optimisticReply, ...(state.replies[confessionId] || [])],\n            },\n          }));\n\n          const { data, error } = await supabase\n            .from(\"replies\")\n            .insert({\n              confession_id: confessionId,\n              user_id: user?.id,\n              content: content.trim(),\n              is_anonymous: isAnonymous,\n              parent_id: parentId,\n            })\n            .select()\n            .single();\n\n          if (error) throw error;\n\n          const newReply: Reply = {\n            id: data.id,\n            confessionId: data.confession_id,\n            userId: data.user_id || undefined,\n            content: data.content,\n            isAnonymous: data.is_anonymous,\n            likes: data.likes || 0,\n            isLiked: false,\n            timestamp: new Date(data.created_at).getTime(),\n            parentId: data.parent_id,\n            reactions: [],\n            reactionCounts: { heart: 0, laugh: 0, sad: 0, angry: 0, wow: 0, thumbs_up: 0 },\n            userReactions: [],\n          };\n\n          // Replace optimistic update with real data\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: state.replies[confessionId].map((r) => (r.id === tempId ? newReply : r)),\n            },\n            loading: false,\n          }));\n\n          // Clear draft after successful submission\n          get().clearDraft(confessionId);\n\n          // Trigger cache invalidation\n          invalidateCache(\"reply_created\", { replyId: newReply.id, confessionId });\n\n          // Track analytics\n          VideoDataService.trackVideoEvent(\"comment_added\", {\n            confession_id: confessionId,\n            parent_id: parentId,\n            is_anonymous: isAnonymous,\n            content_length: content.length,\n          });\n        } catch (error) {\n          // Remove optimistic update on error\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: state.replies[confessionId].filter((r) => !r.id.startsWith(\"temp-\")),\n            },\n            error: error instanceof Error ? error.message : \"Failed to add comment\",\n            loading: false,\n          }));\n          throw error;\n        }\n      },\n\n      deleteReply: async (replyId: string, confessionId?: string) => {\n        set({ loading: true, error: null });\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) throw new Error(\"User not authenticated\");\n\n          const { error } = await supabase.from(\"replies\").delete().eq(\"id\", replyId).eq(\"user_id\", user.id);\n\n          if (error) throw error;\n\n          // Update all confession replies that might contain this reply\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].filter((r) => r.id !== replyId);\n            });\n            return { replies: newReplies, loading: false };\n          });\n\n          VideoDataService.trackVideoEvent(\"comment_deleted\", { confession_id: \"\" }); // TODO: Add confession_id\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to delete comment\",\n            loading: false,\n          });\n          throw error;\n        }\n      },\n\n      editReply: async (replyId: string, content: string) => {\n        set({ loading: true, error: null });\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) throw new Error(\"User not authenticated\");\n\n          const { data, error } = await supabase\n            .from(\"replies\")\n            .update({\n              content: content.trim(),\n              edited_at: new Date().toISOString(),\n            })\n            .eq(\"id\", replyId)\n            .eq(\"user_id\", user.id)\n            .select()\n            .single();\n\n          if (error) throw error;\n\n          // Update in all confessions\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].map((r) =>\n                r.id === replyId ? { ...r, content: data.content, edited_at: data.edited_at } : r,\n              );\n            });\n            return { replies: newReplies, loading: false };\n          });\n\n          VideoDataService.trackVideoEvent(\"comment_edited\", { confession_id: \"\" }); // TODO: Add confession_id\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to edit comment\",\n            loading: false,\n          });\n          throw error;\n        }\n      },\n\n      toggleReplyLike: async (replyId: string, confessionId: string) => {\n        return debouncedOperation(`reply-like-${replyId}`, async () => {\n          const state = get();\n          const replies = state.replies[confessionId] || [];\n          const reply = replies.find((r) => r.id === replyId);\n\n          if (!reply) return;\n\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) return;\n\n          const newIsLiked = !reply.isLiked;\n          const optimisticLikes = newIsLiked ? reply.likes + 1 : Math.max(0, reply.likes - 1);\n\n          // Optimistic update\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: replies.map((r) =>\n                r.id === replyId ? { ...r, likes: optimisticLikes, isLiked: newIsLiked } : r,\n              ),\n            },\n          }));\n\n          try {\n            if (newIsLiked) {\n              await supabase.from(\"user_likes\").insert({ user_id: user.id, reply_id: replyId });\n              await supabase.from(\"replies\").update({ likes: optimisticLikes }).eq(\"id\", replyId);\n            } else {\n              await supabase.from(\"user_likes\").delete().eq(\"user_id\", user.id).eq(\"reply_id\", replyId);\n              await supabase.from(\"replies\").update({ likes: optimisticLikes }).eq(\"id\", replyId);\n            }\n\n            VideoDataService.trackVideoEvent(newIsLiked ? \"comment_liked\" : \"comment_unliked\", {\n              reply_id: replyId,\n              confession_id: confessionId,\n            });\n          } catch (error) {\n            // Revert optimistic update\n            set((state) => ({\n              replies: {\n                ...state.replies,\n                [confessionId]: replies,\n              },\n              error: error instanceof Error ? error.message : \"Failed to update like\",\n            }));\n          }\n        });\n      },\n\n      // Threading actions\n      loadThreadReplies: async (parentId: string) => {\n        try {\n          const { data, error } = await supabase\n            .from(\"replies\")\n            .select(\"*\")\n            .eq(\"parent_id\", parentId)\n            .order(\"created_at\", { ascending: true });\n\n          if (error) throw error;\n\n          // Update parent reply with children\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].map((r) => {\n                if (r.id === parentId) {\n                  return {\n                    ...r,\n                    replies: data.map((d: any) => ({\n                      id: d.id,\n                      confessionId: d.confession_id,\n                      content: d.content,\n                      userId: d.user_id,\n                      isAnonymous: d.is_anonymous,\n                      likes: d.likes,\n                      timestamp: new Date(d.created_at).getTime(),\n                      parentId: d.parent_id,\n                    })),\n                  };\n                }\n                return r;\n              });\n            });\n            return { replies: newReplies };\n          });\n        } catch (error) {\n          console.error(\"Error loading thread replies:\", error);\n        }\n      },\n\n      collapseThread: (replyId: string) => {\n        set((state) => {\n          const newReplies = { ...state.replies };\n          Object.keys(newReplies).forEach((cId) => {\n            newReplies[cId] = newReplies[cId].map((r) => (r.id === replyId ? { ...r, replies: undefined } : r));\n          });\n          return { replies: newReplies };\n        });\n      },\n\n      expandThread: (replyId: string) => {\n        get().loadThreadReplies(replyId);\n      },\n\n      // Reaction actions\n      addReaction: async (replyId: string, type: ReactionType) => {\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) return;\n\n          const { error } = await supabase\n            .from(\"comment_reactions\")\n            .insert({ reply_id: replyId, user_id: user.id, type });\n\n          if (error) throw error;\n\n          // Update local state\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].map((r) => {\n                if (r.id === replyId) {\n                  const newReactionCounts = { ...r.reactionCounts };\n                  newReactionCounts[type] = (newReactionCounts[type] || 0) + 1;\n                  return {\n                    ...r,\n                    reactionCounts: newReactionCounts,\n                    userReactions: [...(r.userReactions || []), type],\n                  };\n                }\n                return r;\n              });\n            });\n            return { replies: newReplies };\n          });\n\n          VideoDataService.trackVideoEvent(\"comment_reaction_added\", {\n            confession_id: \"\", // TODO: Add confession_id\n            reaction_type: type,\n          });\n        } catch (error) {\n          console.error(\"Error adding reaction:\", error);\n        }\n      },\n\n      removeReaction: async (replyId: string, type: ReactionType) => {\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) return;\n\n          const { error } = await supabase\n            .from(\"comment_reactions\")\n            .delete()\n            .eq(\"reply_id\", replyId)\n            .eq(\"user_id\", user.id)\n            .eq(\"type\", type);\n\n          if (error) throw error;\n\n          // Update local state\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].map((r) => {\n                if (r.id === replyId) {\n                  const newReactionCounts = { ...r.reactionCounts };\n                  newReactionCounts[type] = Math.max(0, (newReactionCounts[type] || 0) - 1);\n                  return {\n                    ...r,\n                    reactionCounts: newReactionCounts,\n                    userReactions: (r.userReactions || []).filter((rt) => rt !== type),\n                  };\n                }\n                return r;\n              });\n            });\n            return { replies: newReplies };\n          });\n\n          VideoDataService.trackVideoEvent(\"comment_reaction_removed\", {\n            confession_id: \"\", // TODO: Add confession_id\n            reaction_type: type,\n          });\n        } catch (error) {\n          console.error(\"Error removing reaction:\", error);\n        }\n      },\n\n      // Search actions\n      searchComments: async (confessionId: string, query: string) => {\n        set({ loading: true, searchQuery: query });\n        try {\n          const { data, error } = await supabase\n            .from(\"replies\")\n            .select(\"*\")\n            .eq(\"confession_id\", confessionId)\n            .textSearch(\"content\", query)\n            .order(\"created_at\", { ascending: false });\n\n          if (error) throw error;\n\n          const searchResults: Reply[] = (data || []).map((item) => ({\n            id: item.id,\n            confessionId: item.confession_id,\n            userId: item.user_id || undefined,\n            content: item.content,\n            isAnonymous: item.is_anonymous,\n            likes: item.likes || 0,\n            timestamp: new Date(item.created_at).getTime(),\n            parentId: (item as any).parent_id,\n          }));\n\n          set((state) => ({\n            searchResults: { ...state.searchResults, [confessionId]: searchResults },\n            loading: false,\n          }));\n\n          VideoDataService.trackVideoEvent(\"comments_searched\", {\n            confession_id: confessionId,\n            query,\n            results_count: searchResults.length,\n          });\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : \"Search failed\", loading: false });\n        }\n      },\n\n      clearSearch: () => {\n        set({ searchResults: {}, searchQuery: \"\" });\n      },\n\n      // Moderation actions\n      reportComment: async (replyId: string, reason: string) => {\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) return;\n\n          // Comment reports table not yet implemented\n          const error = null;\n          // await supabase\n          //   .from(\"comment_reports\")\n          //   .insert({ reply_id: replyId, user_id: user.id, reason });\n\n          if (error) throw error;\n\n          VideoDataService.trackVideoEvent(\"comment_reported\", { confession_id: \"\", reason }); // TODO: Add confession_id\n        } catch (error) {\n          console.error(\"Error reporting comment:\", error);\n        }\n      },\n\n      flagComment: async (replyId: string, reason: string) => {\n        try {\n          const { error } = await supabase\n            .from(\"replies\")\n            .update({ flagged: true, flag_reason: reason })\n            .eq(\"id\", replyId);\n\n          if (error) throw error;\n\n          // Update local state\n          set((state) => {\n            const newReplies = { ...state.replies };\n            Object.keys(newReplies).forEach((cId) => {\n              newReplies[cId] = newReplies[cId].map((r) =>\n                r.id === replyId ? { ...r, flagged: true, flag_reason: reason } : r,\n              );\n            });\n            return { replies: newReplies };\n          });\n        } catch (error) {\n          console.error(\"Error flagging comment:\", error);\n        }\n      },\n\n      // Typing indicators\n      startTyping: async (confessionId: string, parentId?: string) => {\n        const {\n          data: { user },\n        } = await supabase.auth.getUser();\n        if (!user) return;\n\n        const key = `${confessionId}-${parentId || \"main\"}`;\n\n        // Clear existing timer\n        if (typingTimers[key]) {\n          clearTimeout(typingTimers[key]);\n        }\n\n        // Broadcast typing event\n        if (typingChannel) {\n          typingChannel.send({\n            type: \"broadcast\",\n            event: \"typing\",\n            payload: { confessionId, parentId, userId: user.id },\n          });\n        }\n\n        // Auto-stop typing after 3 seconds\n        typingTimers[key] = setTimeout(() => {\n          get().stopTyping(confessionId, parentId);\n        }, 3000);\n      },\n\n      stopTyping: async (confessionId: string, parentId?: string) => {\n        const {\n          data: { user },\n        } = await supabase.auth.getUser();\n        if (!user) return;\n\n        const key = `${confessionId}-${parentId || \"main\"}`;\n\n        // Clear timer\n        if (typingTimers[key]) {\n          clearTimeout(typingTimers[key]);\n          delete typingTimers[key];\n        }\n\n        // Broadcast stop typing event\n        if (typingChannel) {\n          typingChannel.send({\n            type: \"broadcast\",\n            event: \"stop_typing\",\n            payload: { confessionId, parentId, userId: user.id },\n          });\n        }\n      },\n\n      // Draft management\n      saveDraft: (confessionId: string, content: string, parentId?: string) => {\n        const draft: CommentDraft = {\n          id: `draft-${confessionId}`,\n          confessionId,\n          content,\n          parentId,\n          timestamp: Date.now(),\n        };\n\n        set((state) => ({\n          drafts: { ...state.drafts, [confessionId]: draft },\n        }));\n      },\n\n      loadDraft: (confessionId: string) => {\n        const state = get();\n        return state.drafts[confessionId] || null;\n      },\n\n      clearDraft: (confessionId: string) => {\n        set((state) => {\n          const newDrafts = { ...state.drafts };\n          delete newDrafts[confessionId];\n          return { drafts: newDrafts };\n        });\n      },\n\n      // Offline support\n      processOfflineQueue: async () => {\n        const state = get();\n        if (state.connectionStatus !== \"online\" || state.offlineQueue.length === 0) return;\n\n        const queue = [...state.offlineQueue];\n        set({ offlineQueue: [] });\n\n        for (const item of queue) {\n          try {\n            switch (item.type) {\n              case \"add\":\n                await get().addReply(\n                  item.payload.confessionId,\n                  item.payload.content,\n                  item.payload.isAnonymous,\n                  item.payload.parentId,\n                );\n                break;\n              case \"edit\":\n                await get().editReply(item.payload.replyId, item.payload.content);\n                break;\n              case \"delete\":\n                await get().deleteReply(item.payload.replyId);\n                break;\n              case \"react\":\n                await get().addReaction(item.payload.replyId, item.payload.type);\n                break;\n            }\n          } catch (error) {\n            console.error(\"Error processing offline queue item:\", error);\n            // Re-add to queue if failed\n            set((state) => ({\n              offlineQueue: [...state.offlineQueue, item],\n            }));\n          }\n        }\n      },\n\n      setConnectionStatus: (status) => {\n        set({ connectionStatus: status });\n        if (status === \"online\") {\n          get().processOfflineQueue();\n        }\n      },\n\n      // Real-time subscriptions\n      subscribeToReplies: (confessionId: string) => {\n        if (repliesChannel) return;\n\n        repliesChannel = supabase\n          .channel(`replies:${confessionId}`)\n          .on(\n            \"postgres_changes\",\n            { event: \"INSERT\", schema: \"public\", table: \"replies\", filter: `confession_id=eq.${confessionId}` },\n            (payload) => {\n              const reply = payload.new as DatabaseReplyRecord;\n              set((state) => {\n                const existing = state.replies[confessionId] || [];\n                if (existing.find((r) => r.id === reply.id)) return state;\n\n                const newReply: Reply = {\n                  id: reply.id,\n                  confessionId: reply.confession_id,\n                  userId: reply.user_id || undefined,\n                  content: reply.content,\n                  isAnonymous: reply.is_anonymous,\n                  likes: reply.likes || 0,\n                  timestamp: new Date(reply.created_at).getTime(),\n                  parentId: reply.parent_id,\n                };\n\n                return {\n                  replies: {\n                    ...state.replies,\n                    [confessionId]: [newReply, ...existing].slice(0, 200),\n                  },\n                };\n              });\n            },\n          )\n          .on(\"postgres_changes\", { event: \"UPDATE\", schema: \"public\", table: \"replies\" }, (payload) => {\n            const reply = payload.new as DatabaseReplyRecord;\n            set((state) => {\n              const newReplies = { ...state.replies };\n              if (newReplies[confessionId]) {\n                newReplies[confessionId] = newReplies[confessionId].map((r) =>\n                  r.id === reply.id ? { ...r, likes: reply.likes || r.likes, content: reply.content } : r,\n                );\n              }\n              return { replies: newReplies };\n            });\n          })\n          .subscribe((status) => {\n            if (status === \"SUBSCRIBED\") {\n              reconnectAttempts = 0;\n              set({ connectionStatus: \"online\" });\n            }\n            if (status === \"CHANNEL_ERROR\" || status === \"CLOSED\") {\n              set({ connectionStatus: \"reconnecting\" });\n              const delay = Math.min(30000, 1000 * Math.pow(2, reconnectAttempts++));\n              reconnectTimer = setTimeout(() => {\n                get().unsubscribeFromReplies();\n                get().subscribeToReplies(confessionId);\n              }, delay);\n            }\n          });\n      },\n\n      unsubscribeFromReplies: () => {\n        if (repliesChannel) {\n          repliesChannel.unsubscribe();\n          repliesChannel = null;\n        }\n        if (reconnectTimer) {\n          clearTimeout(reconnectTimer);\n          reconnectTimer = null;\n        }\n      },\n\n      subscribeToTypingIndicators: (confessionId: string) => {\n        if (typingChannel) return;\n\n        typingChannel = supabase\n          .channel(`typing:${confessionId}`)\n          .on(\"broadcast\", { event: \"typing\" }, (payload) => {\n            const { userId, parentId } = payload.payload;\n            set((state) => {\n              const key = parentId || \"main\";\n              const typing = state.typingUsers[confessionId] || [];\n              const newTyping = typing.filter((t) => t.userId !== userId);\n              newTyping.push({ userId, replyId: parentId, timestamp: Date.now() });\n              return {\n                typingUsers: {\n                  ...state.typingUsers,\n                  [confessionId]: newTyping,\n                },\n              };\n            });\n          })\n          .on(\"broadcast\", { event: \"stop_typing\" }, (payload) => {\n            const { userId } = payload.payload;\n            set((state) => {\n              const typing = state.typingUsers[confessionId] || [];\n              return {\n                typingUsers: {\n                  ...state.typingUsers,\n                  [confessionId]: typing.filter((t) => t.userId !== userId),\n                },\n              };\n            });\n          })\n          .subscribe();\n      },\n\n      unsubscribeFromTypingIndicators: () => {\n        if (typingChannel) {\n          typingChannel.unsubscribe();\n          typingChannel = null;\n        }\n        // Clear all typing timers\n        Object.values(typingTimers).forEach((timer) => clearTimeout(timer));\n        typingTimers = {};\n      },\n\n      // Bulk actions\n      bulkDeleteReplies: async (replyIds: string[], confessionId: string) => {\n        set({ loading: true, error: null });\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) throw new Error(\"User not authenticated\");\n\n          const { error } = await supabase.from(\"replies\").delete().in(\"id\", replyIds).eq(\"user_id\", user.id);\n\n          if (error) throw error;\n\n          set((state) => ({\n            replies: {\n              ...state.replies,\n              [confessionId]: (state.replies[confessionId] || []).filter((r) => !replyIds.includes(r.id)),\n            },\n            loading: false,\n          }));\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : \"Failed to delete comments\", loading: false });\n          throw error;\n        }\n      },\n\n      bulkToggleReplyLikes: async (replyIds: string[], confessionId: string, like: boolean) => {\n        const state = get();\n        const replies = state.replies[confessionId] || [];\n\n        // Optimistic batch update\n        set({\n          replies: {\n            ...state.replies,\n            [confessionId]: replies.map((r) =>\n              replyIds.includes(r.id)\n                ? { ...r, likes: like ? r.likes + 1 : Math.max(0, r.likes - 1), isLiked: like }\n                : r,\n            ),\n          },\n        });\n\n        try {\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (!user) return;\n\n          if (like) {\n            const rows = replyIds.map((id) => ({ user_id: user.id, reply_id: id }));\n            const { error } = await supabase.from(\"user_likes\").insert(rows);\n            if (error) throw error;\n          } else {\n            const { error } = await supabase\n              .from(\"user_likes\")\n              .delete()\n              .eq(\"user_id\", user.id)\n              .in(\"reply_id\", replyIds);\n            if (error) throw error;\n          }\n        } catch (error) {\n          // Revert on error\n          set({ replies: { ...state.replies, [confessionId]: replies } });\n          set({ error: error instanceof Error ? error.message : \"Failed to update likes\" });\n        }\n      },\n\n      clearError: () => {\n        set({ error: null });\n      },\n\n      getRepliesForConfession: (confessionId: string) => {\n        const state = get();\n        return state.replies[confessionId] ?? [];\n      },\n    }),\n    {\n      name: \"reply-storage\",\n      storage: createJSONStorage(() => AsyncStorage),\n      partialize: (state) => ({\n        replies: state.replies,\n        drafts: state.drafts,\n        offlineQueue: state.offlineQueue,\n      }),\n    },\n  ),\n);\n\n// Cleanup function\nconst cleanupSubscriptions = () => {\n  const store = useReplyStore.getState();\n  store.unsubscribeFromReplies();\n  store.unsubscribeFromTypingIndicators();\n};\n\n// Register cleanup\nregisterStoreCleanup(\"replyStore\", cleanupSubscriptions);\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/reportStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/savedStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'trackStoreOperation' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalizeConfession' is defined but never used.","line":8,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { supabase } from \"../lib/supabase\";\nimport type { Confession } from \"../types/confession\";\nimport { offlineQueue, OFFLINE_ACTIONS } from \"../utils/offlineQueue\";\nimport { trackStoreOperation } from \"../utils/storePerformanceMonitor\";\nimport { normalizeConfessions, normalizeConfession } from \"../utils/confessionNormalizer\";\n\ninterface SavedState {\n  savedConfessionIds: string[];\n  savedConfessions: Confession[];\n  isLoading: boolean;\n  isLoadingMore: boolean;\n  hasMore: boolean;\n  error: string | null;\n  lastFetchTime: number | null;\n\n  // Actions\n  saveConfession: (confessionId: string) => Promise<void>;\n  unsaveConfession: (confessionId: string) => Promise<void>;\n  batchSaveConfessions: (confessionIds: string[]) => Promise<void>;\n  batchUnsaveConfessions: (confessionIds: string[]) => Promise<void>;\n  isSaved: (confessionId: string) => boolean;\n  loadSavedConfessions: (refresh?: boolean) => Promise<void>;\n  loadMoreSavedConfessions: () => Promise<void>;\n  clearAllSaved: () => Promise<void>;\n  clearError: () => void;\n}\n\nconst ITEMS_PER_PAGE = 20;\n\nexport const useSavedStore = create<SavedState>()(\n  persist(\n    (set, get) => ({\n      savedConfessionIds: [],\n      savedConfessions: [],\n      isLoading: false,\n      isLoadingMore: false,\n      hasMore: true,\n      error: null,\n      lastFetchTime: null,\n\n      saveConfession: async (confessionId: string) => {\n        try {\n          const state = get();\n          if (state.savedConfessionIds.includes(confessionId)) return;\n\n          // Optimistically update the UI\n          set({\n            savedConfessionIds: [...state.savedConfessionIds, confessionId],\n            error: null,\n          });\n\n          // Check if online, if not queue the action\n          if (!offlineQueue.getNetworkStatus()) {\n            await offlineQueue.enqueue(OFFLINE_ACTIONS.SAVE_CONFESSION, { confessionId });\n            return;\n          }\n\n          // Try to save to backend\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (user) {\n            const { error } = await supabase\n              .from(\"user_saved_confessions\" as any)\n              .insert({ user_id: user.id, confession_id: confessionId });\n\n            if (error) {\n              // Only enqueue for retry if the error is retryable (not unique constraint violations, etc.)\n              const isRetryable = !error.code || ![\"23505\", \"23503\", \"23502\"].includes(error.code); // Common non-retryable Postgres error codes\n              if (isRetryable) {\n                await offlineQueue.enqueue(OFFLINE_ACTIONS.SAVE_CONFESSION, { confessionId });\n              }\n              throw error;\n            }\n          }\n        } catch (error) {\n          // Revert optimistic update on error only if not queued\n          if (offlineQueue.getNetworkStatus()) {\n            set((state) => ({\n              savedConfessionIds: state.savedConfessionIds.filter((id) => id !== confessionId),\n              error: error instanceof Error ? error.message : \"Failed to save confession\",\n            }));\n          }\n        }\n      },\n\n      unsaveConfession: async (confessionId: string) => {\n        try {\n          const state = get();\n\n          // Optimistically update the UI\n          set({\n            savedConfessionIds: state.savedConfessionIds.filter((id) => id !== confessionId),\n            savedConfessions: state.savedConfessions.filter((confession) => confession.id !== confessionId),\n            error: null,\n          });\n\n          // Check if online, if not queue the action\n          if (!offlineQueue.getNetworkStatus()) {\n            await offlineQueue.enqueue(OFFLINE_ACTIONS.UNSAVE_CONFESSION, { confessionId });\n            return;\n          }\n\n          // Try to remove from backend\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (user) {\n            const { error } = await supabase\n              .from(\"user_saved_confessions\" as any)\n              .delete()\n              .eq(\"user_id\", user.id)\n              .eq(\"confession_id\", confessionId);\n\n            if (error) {\n              // If online operation fails, queue it for retry\n              await offlineQueue.enqueue(OFFLINE_ACTIONS.UNSAVE_CONFESSION, { confessionId });\n              throw error;\n            }\n          }\n        } catch (error) {\n          // Revert optimistic update on error only if not queued\n          if (offlineQueue.getNetworkStatus()) {\n            set((state) => ({\n              savedConfessionIds: [...state.savedConfessionIds, confessionId],\n              error: error instanceof Error ? error.message : \"Failed to unsave confession\",\n            }));\n          }\n        }\n      },\n\n      batchSaveConfessions: async (confessionIds: string[]) => {\n        if (!confessionIds.length) return;\n        try {\n          const state = get();\n          const toSave = confessionIds.filter((id) => !state.savedConfessionIds.includes(id));\n          if (toSave.length === 0) return;\n          set({ savedConfessionIds: [...state.savedConfessionIds, ...toSave] });\n          if (!offlineQueue.getNetworkStatus()) {\n            await Promise.all(\n              toSave.map((id) => offlineQueue.enqueue(OFFLINE_ACTIONS.SAVE_CONFESSION, { confessionId: id })),\n            );\n            return;\n          }\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (user) {\n            const rows = toSave.map((id) => ({ user_id: user.id, confession_id: id }));\n            const { error } = await supabase.from(\"user_saved_confessions\" as any).insert(rows as any);\n            if (error) throw error;\n          }\n        } catch (err) {\n          set((state) => ({\n            savedConfessionIds: state.savedConfessionIds.filter((id) => !confessionIds.includes(id)),\n            error: err instanceof Error ? err.message : \"Failed to save confessions\",\n          }));\n        }\n      },\n\n      batchUnsaveConfessions: async (confessionIds: string[]) => {\n        if (!confessionIds.length) return;\n        try {\n          const state = get();\n          set({\n            savedConfessionIds: state.savedConfessionIds.filter((id) => !confessionIds.includes(id)),\n            savedConfessions: state.savedConfessions.filter((c) => !confessionIds.includes(c.id)),\n          });\n          if (!offlineQueue.getNetworkStatus()) {\n            await Promise.all(\n              confessionIds.map((id) => offlineQueue.enqueue(OFFLINE_ACTIONS.UNSAVE_CONFESSION, { confessionId: id })),\n            );\n            return;\n          }\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n          if (user) {\n            const { error } = await supabase\n              .from(\"user_saved_confessions\" as any)\n              .delete()\n              .eq(\"user_id\", user.id)\n              .in(\"confession_id\", confessionIds);\n            if (error) throw error;\n          }\n        } catch (err) {\n          // revert\n          set((state) => ({\n            savedConfessionIds: [...new Set([...state.savedConfessionIds, ...confessionIds])],\n            error: err instanceof Error ? err.message : \"Failed to unsave confessions\",\n          }));\n        }\n      },\n\n      isSaved: (confessionId: string) => {\n        const state = get();\n        return state.savedConfessionIds.includes(confessionId);\n      },\n\n      loadSavedConfessions: async (refresh = false) => {\n        const state = get();\n\n        // Skip if already loading or recently fetched (unless refreshing)\n        if (state.isLoading || (!refresh && state.lastFetchTime && Date.now() - state.lastFetchTime < 30000)) {\n          return;\n        }\n\n        set({ isLoading: true, error: null });\n\n        try {\n          if (state.savedConfessionIds.length === 0) {\n            set({\n              savedConfessions: [],\n              isLoading: false,\n              hasMore: false,\n              lastFetchTime: Date.now(),\n            });\n            return;\n          }\n\n          // Get current user first\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n\n          if (!user?.id) {\n            throw new Error(\"User not authenticated\");\n          }\n\n          // Fetch saved confessions from Supabase\n          const { data: confessions, error } = await supabase\n            .from(\"confessions\")\n            .select(\n              `\n              *,\n              confession_likes!left(user_id)\n            `,\n            )\n            .in(\"id\", state.savedConfessionIds)\n            .eq(\"confession_likes.user_id\", user.id)\n            .order(\"created_at\", { ascending: false })\n            .limit(ITEMS_PER_PAGE);\n\n          if (error) throw error;\n\n          // Process confessions using normalizer for consistent field mapping\n          let processedConfessions: Confession[] = [];\n          try {\n            const normalizedConfessions = await normalizeConfessions(confessions || []);\n\n            // Add like status from the join\n            processedConfessions = normalizedConfessions.map((confession) => {\n              const row = confessions?.find((r: any) => r.id === confession.id);\n              return {\n                ...confession,\n                isLiked: (row?.confession_likes?.length ?? 0) > 0,\n              };\n            });\n          } catch (normalizationError) {\n            if (__DEV__) {\n              console.error(\"Failed to normalize saved confessions:\", normalizationError);\n            }\n            // Fallback to basic processing if normalization fails\n            processedConfessions = (confessions || []).map((row: any) => ({\n              id: row.id,\n              type: row.type || \"text\",\n              content: row.content || \"\",\n              videoUri: row.video_uri ?? row.video_url ?? undefined,\n              transcription: row.transcription ?? undefined,\n              timestamp: row.created_at ? new Date(row.created_at).getTime() : Date.now(),\n              isAnonymous: !!row.is_anonymous,\n              likes: row.likes ?? 0,\n              views: row.views ?? 0,\n              isLiked: (row?.confession_likes?.length ?? 0) > 0,\n            }));\n          }\n\n          set({\n            savedConfessions: processedConfessions,\n            isLoading: false,\n            hasMore: processedConfessions.length === ITEMS_PER_PAGE,\n            lastFetchTime: Date.now(),\n          });\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to load saved confessions\",\n            isLoading: false,\n          });\n        }\n      },\n\n      loadMoreSavedConfessions: async () => {\n        const state = get();\n\n        if (state.isLoadingMore || !state.hasMore || state.savedConfessions.length === 0) {\n          return;\n        }\n\n        set({ isLoadingMore: true, error: null });\n\n        try {\n          const remainingIds = state.savedConfessionIds.filter(\n            (id) => !state.savedConfessions.some((confession) => confession.id === id),\n          );\n\n          if (remainingIds.length === 0) {\n            set({ isLoadingMore: false, hasMore: false });\n            return;\n          }\n\n          // Get current user first\n          const {\n            data: { user },\n          } = await supabase.auth.getUser();\n\n          if (!user?.id) {\n            throw new Error(\"User not authenticated\");\n          }\n\n          const { data: confessions, error } = await supabase\n            .from(\"confessions\")\n            .select(\n              `\n              *,\n              confession_likes!left(user_id)\n            `,\n            )\n            .in(\"id\", remainingIds.slice(0, ITEMS_PER_PAGE))\n            .eq(\"confession_likes.user_id\", user.id)\n            .order(\"created_at\", { ascending: false });\n\n          if (error) throw error;\n\n          // Process confessions using normalizer for consistent field mapping\n          let processedConfessions: Confession[] = [];\n          try {\n            const normalizedConfessions = await normalizeConfessions(confessions || []);\n\n            // Add like status from the join\n            processedConfessions = normalizedConfessions.map((confession) => {\n              const row = confessions?.find((r: any) => r.id === confession.id);\n              return {\n                ...confession,\n                isLiked: (row?.confession_likes?.length ?? 0) > 0,\n              };\n            });\n          } catch (normalizationError) {\n            if (__DEV__) {\n              console.error(\"Failed to normalize more saved confessions:\", normalizationError);\n            }\n            // Fallback to basic processing if normalization fails\n            processedConfessions = (confessions || []).map((row: any) => ({\n              id: row.id,\n              type: row.type || \"text\",\n              content: row.content || \"\",\n              videoUri: row.video_uri ?? row.video_url ?? undefined,\n              transcription: row.transcription ?? undefined,\n              timestamp: row.created_at ? new Date(row.created_at).getTime() : Date.now(),\n              isAnonymous: !!row.is_anonymous,\n              likes: row.likes ?? 0,\n              views: row.views ?? 0,\n              isLiked: (row?.confession_likes?.length ?? 0) > 0,\n            }));\n          }\n\n          set({\n            savedConfessions: [...state.savedConfessions, ...processedConfessions],\n            isLoadingMore: false,\n            hasMore: remainingIds.length > ITEMS_PER_PAGE,\n          });\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to load more saved confessions\",\n            isLoadingMore: false,\n          });\n        }\n      },\n\n      clearAllSaved: async () => {\n        try {\n          set({\n            savedConfessionIds: [],\n            savedConfessions: [],\n            hasMore: false,\n            error: null,\n          });\n\n          // TODO: Clear from backend when user accounts are implemented\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to clear saved confessions\",\n          });\n        }\n      },\n\n      clearError: () => {\n        set({ error: null });\n      },\n    }),\n    {\n      name: \"saved-storage\",\n      storage: createJSONStorage(() => AsyncStorage),\n      partialize: (state) => ({\n        savedConfessionIds: state.savedConfessionIds,\n      }),\n    },\n  ),\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/subscriptionStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/state/trendingStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalizeConfession' is defined but never used.","line":9,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from \"zustand\";\nimport { persist, createJSONStorage } from \"zustand/middleware\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { supabase } from \"../lib/supabase\";\nimport type { RealtimeChannel } from \"@supabase/supabase-js\";\nimport { Confession } from \"../types/confession\";\nimport { HashtagData, TrendingSecret } from \"../utils/trending\";\nimport { trackStoreOperation } from \"../utils/storePerformanceMonitor\";\nimport { normalizeConfessions, normalizeConfession } from \"../utils/confessionNormalizer\";\n\n// Memoized hashtag extraction with proper key generation\nconst hashtagRegex = /#[\\w\\u00c0-\\u024f\\u1e00-\\u1eff]+/gi;\nconst hashtagMemo = new Map<string, string[]>();\n\n// Simple hash function for generating consistent keys\nconst simpleHash = (str: string): string => {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return hash.toString();\n};\n\nconst extractHashtags = (text: string): string[] => {\n  if (!text) return [];\n\n  // Use full text for short strings, hash for longer ones\n  const key = text.length <= 200 ? text : simpleHash(text);\n\n  const cached = hashtagMemo.get(key);\n  if (cached) return cached;\n\n  const matches = text.match(hashtagRegex);\n  const lower = matches ? matches.map((t) => t.toLowerCase()) : [];\n\n  hashtagMemo.set(key, lower);\n  return lower;\n};\n\nasync function rpcWithRetry<T>(fn: () => Promise<{ data: T | null; error: any }>, attempts = 2) {\n  let lastErr: any;\n  for (let i = 0; i < attempts; i++) {\n    const { data, error } = await fn();\n    if (!error) return { data, error };\n    lastErr = error;\n  }\n  return { data: null as T | null, error: lastErr };\n}\n\ninterface LoadTrendingOptions {\n  force?: boolean;\n  skipRealtimeInit?: boolean;\n}\n\ninterface TrendingState {\n  // Data\n  trendingHashtags: HashtagData[];\n  trendingSecrets: TrendingSecret[];\n  searchResults: Confession[];\n\n  // UI State\n  isLoading: boolean;\n  isRefreshing: boolean;\n  error: string | null;\n  lastUpdated: number | null;\n  realtimeInitialized: boolean;\n  lastHashtagParams: { hours: number; limit: number } | null;\n  lastSecretParams: { hours: number; limit: number } | null;\n\n  // Cache settings\n  cacheExpiry: number; // 5 minutes in milliseconds\n\n  // Actions\n  loadTrendingHashtags: (hours?: number, limit?: number, options?: LoadTrendingOptions) => Promise<void>;\n  loadTrendingSecrets: (hours?: number, limit?: number, options?: LoadTrendingOptions) => Promise<void>;\n  searchByHashtag: (hashtag: string) => Promise<void>;\n  refreshAll: (hours?: number) => Promise<void>;\n  clearSearch: () => void;\n  clearError: () => void;\n}\n\nlet trendingRealtimeChannel: RealtimeChannel | null = null;\nlet trendingRefreshTimer: NodeJS.Timeout | null = null;\n\nconst initializeTrendingRealtime = (_set: (partial: Partial<TrendingState>) => void, get: () => TrendingState) => {\n  if (trendingRealtimeChannel) return;\n\n  trendingRealtimeChannel = supabase\n    .channel(\"trending-confessions\")\n    .on(\"postgres_changes\", { event: \"*\", schema: \"public\", table: \"confessions\" }, () => {\n      if (trendingRefreshTimer) return;\n\n      trendingRefreshTimer = setTimeout(async () => {\n        trendingRefreshTimer = null;\n        const state = get();\n        const { lastHashtagParams, lastSecretParams } = state;\n\n        try {\n          if (lastHashtagParams) {\n            await state.loadTrendingHashtags(lastHashtagParams.hours, lastHashtagParams.limit, {\n              force: true,\n              skipRealtimeInit: true,\n            });\n          }\n\n          if (lastSecretParams) {\n            await state.loadTrendingSecrets(lastSecretParams.hours, lastSecretParams.limit, {\n              force: true,\n              skipRealtimeInit: true,\n            });\n          }\n        } catch (error) {\n          if (__DEV__) {\n            console.warn(\"Trending realtime refresh failed:\", error);\n          }\n        }\n      }, 1200);\n    })\n    .subscribe((status) => {\n      if (__DEV__) {\n        console.log(\"Trending realtime channel status:\", status);\n      }\n    });\n};\n\nexport const useTrendingStore = create<TrendingState>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      trendingHashtags: [],\n      trendingSecrets: [],\n      searchResults: [],\n      isLoading: false,\n      isRefreshing: false,\n      error: null,\n      lastUpdated: null,\n      realtimeInitialized: false,\n      lastHashtagParams: null,\n      lastSecretParams: null,\n      cacheExpiry: 5 * 60 * 1000, // 5 minutes\n\n      loadTrendingHashtags: async (hours = 24, limit = 10, options: LoadTrendingOptions = {}) => {\n        const state = get();\n        const t0 = Date.now();\n\n        if (!options.skipRealtimeInit && !state.realtimeInitialized) {\n          initializeTrendingRealtime((partial) => set(partial), get);\n          set({ realtimeInitialized: true });\n        }\n\n        if (\n          !options.force &&\n          state.lastHashtagParams &&\n          state.lastHashtagParams.hours === hours &&\n          state.lastHashtagParams.limit === limit &&\n          state.lastUpdated &&\n          Date.now() - state.lastUpdated < state.cacheExpiry &&\n          state.trendingHashtags.length > 0\n        ) {\n          return;\n        }\n\n        set({\n          error: null,\n          ...(options.skipRealtimeInit ? {} : { isLoading: true }),\n        });\n\n        try {\n          // Try to use database function first\n          const { data: functionData, error: functionError } = await rpcWithRetry(\n            async () =>\n              await supabase.rpc(\"get_trending_hashtags\", {\n                hours_back: hours,\n                limit_count: limit,\n              }),\n          );\n\n          if (!functionError && functionData) {\n            const hashtags: HashtagData[] = (functionData as any[]).map((item: any) => ({\n              hashtag: item.hashtag,\n              count: parseInt(item.count),\n              percentage: parseFloat(item.percentage),\n            }));\n\n            set({\n              trendingHashtags: hashtags,\n              isLoading: false,\n              lastUpdated: Date.now(),\n              lastHashtagParams: { hours, limit },\n            });\n            return;\n          }\n\n          // Fallback to client-side calculation\n          if (__DEV__) {\n            console.log(\"Using client-side hashtag calculation\");\n          }\n          const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();\n\n          const { data: confessions, error } = await supabase\n            .from(\"confessions\")\n            .select(\"content, transcription\")\n            .gte(\"created_at\", cutoffTime)\n            .order(\"created_at\", { ascending: false });\n\n          if (error) throw error;\n\n          // Client-side hashtag extraction and counting\n          const hashtagCounts: Record<string, number> = {};\n\n          confessions?.forEach((confession) => {\n            const contentHashtags = extractHashtags(confession.content || \"\");\n            const transcriptionHashtags = confession.transcription ? extractHashtags(confession.transcription) : [];\n            [...contentHashtags, ...transcriptionHashtags].forEach((hashtag) => {\n              hashtagCounts[hashtag] = (hashtagCounts[hashtag] || 0) + 1;\n            });\n          });\n\n          const totalHashtags = Object.values(hashtagCounts).reduce((sum, count) => sum + count, 0);\n          const hashtags: HashtagData[] = Object.entries(hashtagCounts)\n            .map(([hashtag, count]) => ({\n              hashtag,\n              count,\n              percentage: totalHashtags > 0 ? (count / totalHashtags) * 100 : 0,\n            }))\n            .sort((a, b) => b.count - a.count)\n            .slice(0, limit);\n\n          set({\n            trendingHashtags: hashtags,\n            isLoading: false,\n            lastUpdated: Date.now(),\n            lastHashtagParams: { hours, limit },\n          });\n          trackStoreOperation(\"trendingStore\", \"loadTrendingHashtags\", Date.now() - t0);\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to load trending hashtags\",\n            isLoading: false,\n          });\n        }\n      },\n\n      loadTrendingSecrets: async (hours = 24, limit = 10, options: LoadTrendingOptions = {}) => {\n        const state = get();\n        const t0 = Date.now();\n\n        if (!options.skipRealtimeInit && !state.realtimeInitialized) {\n          initializeTrendingRealtime((partial) => set(partial), get);\n          set({ realtimeInitialized: true });\n        }\n\n        if (\n          !options.force &&\n          state.lastSecretParams &&\n          state.lastSecretParams.hours === hours &&\n          state.lastSecretParams.limit === limit &&\n          state.lastUpdated &&\n          Date.now() - state.lastUpdated < state.cacheExpiry &&\n          state.trendingSecrets.length > 0\n        ) {\n          return;\n        }\n\n        set({\n          error: null,\n          ...(options.skipRealtimeInit ? {} : { isLoading: true }),\n        });\n\n        try {\n          // Try to use database function first\n          const { data: functionData, error: functionError } = await rpcWithRetry(\n            async () =>\n              await supabase.rpc(\"get_trending_secrets\", {\n                hours_back: hours,\n                limit_count: limit,\n              }),\n          );\n\n          if (!functionError && functionData) {\n            // Process confessions using normalizer for consistent field mapping\n            let secrets: TrendingSecret[] = [];\n            try {\n              const normalizedConfessions = await normalizeConfessions(functionData as any[]);\n              secrets = normalizedConfessions.map((confession, index) => ({\n                confession: {\n                  ...confession,\n                  isLiked: false,\n                },\n                engagementScore: parseFloat((functionData as any[])[index].engagement_score),\n              }));\n            } catch (normalizationError) {\n              if (__DEV__) {\n                console.error(\"Failed to normalize trending secrets from RPC:\", normalizationError);\n              }\n              // Fallback to basic processing\n              secrets = (functionData as any[]).map((item: any) => ({\n                confession: {\n                  id: item.id,\n                  type: item.type as \"text\" | \"video\",\n                  content: item.content,\n                  videoUri: item.video_uri || item.video_url || undefined,\n                  transcription: item.transcription,\n                  timestamp: new Date(item.created_at).getTime(),\n                  isAnonymous: item.is_anonymous,\n                  likes: item.likes,\n                  views: item.views || 0,\n                  isLiked: false,\n                },\n                engagementScore: parseFloat(item.engagement_score),\n              }));\n            }\n\n            set({\n              trendingSecrets: secrets,\n              isLoading: false,\n              lastUpdated: Date.now(),\n              lastSecretParams: { hours, limit },\n            });\n            return;\n          }\n\n          // Fallback to client-side calculation\n          if (__DEV__) {\n            console.log(\"Using client-side trending calculation\");\n          }\n          const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();\n\n          const { data: confessions, error } = await supabase\n            .from(\"confessions\")\n            .select(\"*\")\n            .gte(\"created_at\", cutoffTime)\n            .order(\"likes\", { ascending: false })\n            .limit(limit * 2); // Get more to account for engagement scoring\n\n          if (error) throw error;\n\n          // Client-side engagement calculation\n          const calculateEngagementScore = (likes: number, createdAt: string): number => {\n            const hoursOld = (Date.now() - new Date(createdAt).getTime()) / (1000 * 60 * 60);\n            const decayFactor = Math.exp(-hoursOld / 24); // Half-life of 24 hours\n            return likes * decayFactor;\n          };\n\n          // Process confessions using normalizer for consistent field mapping\n          let secrets: TrendingSecret[] = [];\n          try {\n            const normalizedConfessions = await normalizeConfessions(confessions || []);\n            secrets = normalizedConfessions\n              .map((confession, index) => {\n                const originalRow = confessions?.[index];\n                return {\n                  confession: {\n                    ...confession,\n                    isLiked: false,\n                  },\n                  engagementScore: calculateEngagementScore(\n                    originalRow?.likes || 0,\n                    originalRow?.created_at || new Date().toISOString(),\n                  ),\n                };\n              })\n              .sort((a, b) => b.engagementScore - a.engagementScore)\n              .slice(0, limit);\n          } catch (normalizationError) {\n            if (__DEV__) {\n              console.error(\"Failed to normalize trending secrets fallback:\", normalizationError);\n            }\n            // Fallback to basic processing\n            secrets = (confessions || [])\n              .map((confession) => ({\n                confession: {\n                  id: confession.id,\n                  type: confession.type as \"text\" | \"video\",\n                  content: confession.content,\n                  videoUri: confession.video_uri || confession.video_url || undefined,\n                  transcription: confession.transcription || undefined,\n                  timestamp: new Date(confession.created_at).getTime(),\n                  isAnonymous: confession.is_anonymous,\n                  likes: confession.likes,\n                  views: confession.views || 0,\n                  isLiked: false,\n                },\n                engagementScore: calculateEngagementScore(confession.likes, confession.created_at),\n              }))\n              .sort((a, b) => b.engagementScore - a.engagementScore)\n              .slice(0, limit);\n          }\n\n          set({\n            trendingSecrets: secrets,\n            isLoading: false,\n            lastUpdated: Date.now(),\n            lastSecretParams: { hours, limit },\n          });\n          trackStoreOperation(\"trendingStore\", \"loadTrendingSecrets\", Date.now() - t0);\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to load trending secrets\",\n            isLoading: false,\n          });\n        }\n      },\n\n      searchByHashtag: async (hashtag: string) => {\n        set({ isLoading: true, error: null });\n        const t0 = Date.now();\n\n        try {\n          // Try to use database function first\n          const { data: functionData, error: functionError } = await supabase.rpc(\"search_confessions_by_hashtag\", {\n            search_hashtag: hashtag,\n          });\n\n          if (!functionError && functionData) {\n            // Process confessions using normalizer for consistent field mapping\n            let results: Confession[] = [];\n            try {\n              results = await normalizeConfessions(functionData as any[]);\n              results = results.map((confession) => ({ ...confession, isLiked: false }));\n            } catch (normalizationError) {\n              if (__DEV__) {\n                console.error(\"Failed to normalize hashtag search results from RPC:\", normalizationError);\n              }\n              // Fallback to basic processing\n              results = (functionData as any[]).map((item: any) => ({\n                id: item.id,\n                type: item.type as \"text\" | \"video\",\n                content: item.content,\n                videoUri: item.video_uri || item.video_url || undefined,\n                transcription: item.transcription,\n                timestamp: new Date(item.created_at).getTime(),\n                isAnonymous: item.is_anonymous,\n                likes: item.likes,\n                views: item.views || 0,\n                isLiked: false,\n              }));\n            }\n\n            set({\n              searchResults: results,\n              isLoading: false,\n            });\n            return;\n          }\n\n          // Fallback to client-side search\n          if (__DEV__) {\n            console.log(\"Using client-side hashtag search\");\n          }\n          const normalizedHashtag = hashtag.toLowerCase().startsWith(\"#\")\n            ? hashtag.toLowerCase()\n            : `#${hashtag.toLowerCase()}`;\n\n          const { data: confessions, error } = await supabase\n            .from(\"confessions\")\n            .select(\"*\")\n            .order(\"created_at\", { ascending: false });\n\n          if (error) throw error;\n\n          // Process confessions using normalizer for consistent field mapping\n          let results: Confession[] = [];\n          try {\n            const filteredConfessions = (confessions || []).filter((confession) => {\n              const contentHashtags = extractHashtags(confession.content || \"\");\n              const transcriptionHashtags = confession.transcription ? extractHashtags(confession.transcription) : [];\n              const allHashtags = [...contentHashtags, ...transcriptionHashtags];\n              return allHashtags.includes(normalizedHashtag);\n            });\n\n            results = await normalizeConfessions(filteredConfessions);\n            results = results.map((confession) => ({ ...confession, isLiked: false }));\n          } catch (normalizationError) {\n            if (__DEV__) {\n              console.error(\"Failed to normalize hashtag search results fallback:\", normalizationError);\n            }\n            // Fallback to basic processing\n            results = (confessions || [])\n              .filter((confession) => {\n                const contentHashtags = extractHashtags(confession.content || \"\");\n                const transcriptionHashtags = confession.transcription ? extractHashtags(confession.transcription) : [];\n                const allHashtags = [...contentHashtags, ...transcriptionHashtags];\n                return allHashtags.includes(normalizedHashtag);\n              })\n              .map((confession) => ({\n                id: confession.id,\n                type: confession.type as \"text\" | \"video\",\n                content: confession.content,\n                videoUri: confession.video_uri || confession.video_url || undefined,\n                transcription: confession.transcription || undefined,\n                timestamp: new Date(confession.created_at).getTime(),\n                isAnonymous: confession.is_anonymous,\n                likes: confession.likes,\n                views: confession.views || 0,\n                isLiked: false,\n              }));\n          }\n\n          set({\n            searchResults: results,\n            isLoading: false,\n          });\n          trackStoreOperation(\"trendingStore\", \"searchByHashtag\", Date.now() - t0);\n        } catch (error) {\n          set({\n            error: error instanceof Error ? error.message : \"Failed to search hashtag\",\n            isLoading: false,\n          });\n        }\n      },\n\n      refreshAll: async (hours = 24) => {\n        set({ isRefreshing: true });\n        try {\n          await Promise.all([\n            get().loadTrendingHashtags(hours, undefined, { force: true }),\n            get().loadTrendingSecrets(hours, undefined, { force: true }),\n          ]);\n        } finally {\n          set({ isRefreshing: false });\n        }\n      },\n\n      clearSearch: () => {\n        set({ searchResults: [] });\n      },\n\n      clearError: () => {\n        set({ error: null });\n      },\n    }),\n    {\n      name: \"trending-storage\",\n      storage: createJSONStorage(() => AsyncStorage),\n      // Only persist data, not loading states\n      partialize: (state) => ({\n        trendingHashtags: state.trendingHashtags,\n        trendingSecrets: state.trendingSecrets,\n        lastUpdated: state.lastUpdated,\n        lastHashtagParams: state.lastHashtagParams,\n        lastSecretParams: state.lastSecretParams,\n      }),\n    },\n  ),\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/__tests__/trendingUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/__tests__/videoSmokeTest.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uploadVideoToSupabase' is defined but never used.","line":10,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * End-to-end smoke test for video pipeline\n * Tests: record → process → upload → playback flow\n *\n * This is a development-only test that can be run manually to verify\n * the complete video processing pipeline works correctly.\n */\n\nimport { supabase } from \"../../lib/supabase\";\nimport { ensureSignedVideoUrl, uploadVideoToSupabase } from \"../storage\";\n\ninterface SmokeTestResult {\n  success: boolean;\n  step: string;\n  error?: string;\n  details?: any;\n}\n\n/**\n * Test signed URL generation for video paths\n */\nexport async function testSignedUrlGeneration(): Promise<SmokeTestResult> {\n  try {\n    // Test with a mock storage path\n    const mockPath = \"confessions/test-user/test-video.mp4\";\n    const signedUrl = await ensureSignedVideoUrl(mockPath);\n\n    if (!signedUrl) {\n      return {\n        success: false,\n        step: \"signed-url-generation\",\n        error: \"Failed to generate signed URL\",\n      };\n    }\n\n    // Verify URL format\n    const isValidUrl = signedUrl.signedUrl.startsWith(\"https://\") && signedUrl.signedUrl.includes(\"supabase\");\n    if (!isValidUrl) {\n      return {\n        success: false,\n        step: \"signed-url-generation\",\n        error: \"Generated URL format is invalid\",\n        details: { signedUrl: signedUrl.signedUrl },\n      };\n    }\n\n    return {\n      success: true,\n      step: \"signed-url-generation\",\n      details: { signedUrl: signedUrl.signedUrl.substring(0, 50) + \"...\" },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      step: \"signed-url-generation\",\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test Edge Function connectivity and response format\n */\nexport async function testEdgeFunctionConnectivity(): Promise<SmokeTestResult> {\n  try {\n    const { data, error } = await supabase.functions.invoke(\"process-video\", {\n      body: {\n        videoPath: \"confessions/test-user/test-video.mp4\",\n        options: {\n          enableFaceBlur: false,\n          enableVoiceChange: false,\n          enableTranscription: true,\n          quality: \"medium\",\n        },\n      },\n    });\n\n    if (error) {\n      return {\n        success: false,\n        step: \"edge-function-connectivity\",\n        error: error.message,\n      };\n    }\n\n    // Verify response format\n    if (!data || typeof data !== \"object\") {\n      return {\n        success: false,\n        step: \"edge-function-connectivity\",\n        error: \"Invalid response format from Edge Function\",\n        details: { data },\n      };\n    }\n\n    // Check for expected fields\n    const hasRequiredFields = \"success\" in data && \"storagePath\" in data;\n    if (!hasRequiredFields) {\n      return {\n        success: false,\n        step: \"edge-function-connectivity\",\n        error: \"Response missing required fields (success, storagePath)\",\n        details: { data },\n      };\n    }\n\n    return {\n      success: true,\n      step: \"edge-function-connectivity\",\n      details: {\n        success: data.success,\n        hasStoragePath: !!data.storagePath,\n        message: data.message,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      step: \"edge-function-connectivity\",\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test database connectivity and confession insertion\n */\nexport async function testDatabaseConnectivity(): Promise<SmokeTestResult> {\n  try {\n    // Get current user\n    const {\n      data: { user },\n      error: authError,\n    } = await supabase.auth.getUser();\n    if (authError || !user) {\n      return {\n        success: false,\n        step: \"database-connectivity\",\n        error: \"User not authenticated\",\n      };\n    }\n\n    // Test read access\n    const { data: confessions, error: readError } = await supabase\n      .from(\"confessions\")\n      .select(\"id, created_at\")\n      .limit(1);\n\n    if (readError) {\n      return {\n        success: false,\n        step: \"database-connectivity\",\n        error: `Read access failed: ${readError.message}`,\n      };\n    }\n\n    return {\n      success: true,\n      step: \"database-connectivity\",\n      details: {\n        userId: user.id,\n        canRead: true,\n        sampleCount: confessions?.length || 0,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      step: \"database-connectivity\",\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Run complete video pipeline smoke test\n */\nexport async function runVideoSmokeTest(): Promise<{\n  success: boolean;\n  results: SmokeTestResult[];\n  summary: string;\n}> {\n  if (!__DEV__) {\n    return {\n      success: false,\n      results: [],\n      summary: \"Smoke tests only run in development mode\",\n    };\n  }\n\n  const results: SmokeTestResult[] = [];\n\n  // Test 1: Database connectivity\n  const dbTest = await testDatabaseConnectivity();\n  results.push(dbTest);\n\n  // Test 2: Signed URL generation\n  const urlTest = await testSignedUrlGeneration();\n  results.push(urlTest);\n\n  // Test 3: Edge Function connectivity\n  const edgeTest = await testEdgeFunctionConnectivity();\n  results.push(edgeTest);\n\n  const successCount = results.filter((r) => r.success).length;\n  const totalCount = results.length;\n  const allPassed = successCount === totalCount;\n\n  const summary = `Video pipeline smoke test: ${successCount}/${totalCount} tests passed`;\n\n  return {\n    success: allPassed,\n    results,\n    summary,\n  };\n}\n\n/**\n * Log smoke test results to console (development only)\n */\nexport function logSmokeTestResults(testResults: Awaited<ReturnType<typeof runVideoSmokeTest>>): void {\n  if (!__DEV__) return;\n\n  console.log(\"\\n🧪 Video Pipeline Smoke Test Results\");\n  console.log(\"=====================================\");\n\n  testResults.results.forEach((result, index) => {\n    const icon = result.success ? \"✅\" : \"❌\";\n    console.log(`${icon} ${index + 1}. ${result.step}`);\n\n    if (result.error) {\n      console.log(`   Error: ${result.error}`);\n    }\n\n    if (result.details) {\n      console.log(`   Details:`, result.details);\n    }\n  });\n\n  console.log(\"\\n\" + testResults.summary);\n\n  if (testResults.success) {\n    console.log(\"🎉 All tests passed! Video pipeline is working correctly.\");\n  } else {\n    console.log(\"⚠️  Some tests failed. Check the details above.\");\n  }\n\n  console.log(\"=====================================\\n\");\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/accessibility.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hapticsError' is defined but never used.","line":386,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":386,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Accessibility utilities for consistent a11y implementation\n * Provides standardized accessibility props and helpers\n */\n\nimport { AccessibilityRole, AccessibilityState, AccessibilityProps, AccessibilityInfo } from \"react-native\";\n\nexport interface A11yProps extends AccessibilityProps {\n  accessibilityRole?: AccessibilityRole;\n  accessibilityLabel?: string;\n  accessibilityHint?: string;\n  accessibilityState?: AccessibilityState;\n  accessibilityValue?: {\n    min?: number;\n    max?: number;\n    now?: number;\n    text?: string;\n  };\n}\n\n/**\n * Common accessibility roles for different UI elements\n */\nexport const A11Y_ROLES = {\n  button: \"button\" as const,\n  link: \"link\" as const,\n  text: \"text\" as const,\n  image: \"image\" as const,\n  imagebutton: \"imagebutton\" as const,\n  header: \"header\" as const,\n  search: \"search\" as const,\n  tab: \"tab\" as const,\n  tablist: \"tablist\" as const,\n  menu: \"menu\" as const,\n  menuitem: \"menuitem\" as const,\n  switch: \"switch\" as const,\n  checkbox: \"checkbox\" as const,\n  radio: \"radio\" as const,\n  slider: \"slider\" as const,\n  progressbar: \"progressbar\" as const,\n  alert: \"alert\" as const,\n  combobox: \"combobox\" as const,\n  list: \"list\" as const,\n  listitem: \"listitem\" as const,\n} as const;\n\n/**\n * Generate accessibility props for buttons\n */\nexport const getButtonA11yProps = (label: string, hint?: string, disabled = false, pressed = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: label,\n  accessibilityHint: hint,\n  accessibilityState: {\n    disabled,\n    selected: pressed,\n  },\n});\n\n/**\n * Generate accessibility props for like/heart buttons\n */\nexport const getLikeButtonA11yProps = (isLiked: boolean, likeCount: number, disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: isLiked ? `Unlike. ${likeCount} likes` : `Like. ${likeCount} likes`,\n  accessibilityHint: isLiked ? \"Double tap to unlike this post\" : \"Double tap to like this post\",\n  accessibilityState: {\n    disabled,\n    selected: isLiked,\n  },\n});\n\n/**\n * Generate accessibility props for bookmark/save buttons\n */\nexport const getBookmarkButtonA11yProps = (isSaved: boolean, disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: isSaved ? \"Remove from saved\" : \"Save post\",\n  accessibilityHint: isSaved ? \"Double tap to remove from saved posts\" : \"Double tap to save this post\",\n  accessibilityState: {\n    disabled,\n    selected: isSaved,\n  },\n});\n\n/**\n * Generate accessibility props for share buttons\n */\nexport const getShareButtonA11yProps = (disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: \"Share post\",\n  accessibilityHint: \"Double tap to share this post\",\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for report buttons\n */\nexport const getReportButtonA11yProps = (disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: \"Report post\",\n  accessibilityHint: \"Double tap to report this post\",\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for navigation buttons\n */\nexport const getNavButtonA11yProps = (destination: string, disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: `Navigate to ${destination}`,\n  accessibilityHint: `Double tap to go to ${destination}`,\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for back buttons\n */\nexport const getBackButtonA11yProps = (disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: \"Go back\",\n  accessibilityHint: \"Double tap to go back to previous screen\",\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for close/dismiss buttons\n */\nexport const getCloseButtonA11yProps = (disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: \"Close\",\n  accessibilityHint: \"Double tap to close\",\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for menu/more options buttons\n */\nexport const getMenuButtonA11yProps = (disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.button,\n  accessibilityLabel: \"More options\",\n  accessibilityHint: \"Double tap to open menu with more options\",\n  accessibilityState: { disabled },\n});\n\n/**\n * Generate accessibility props for text inputs\n */\nexport const getTextInputA11yProps = (\n  label: string,\n  hint?: string,\n  required = false,\n  multiline = false,\n): A11yProps => ({\n  accessibilityRole: multiline ? \"none\" : \"text\",\n  accessibilityLabel: label,\n  accessibilityHint: hint,\n});\n\n/**\n * Generate accessibility props for search inputs\n */\nexport const getSearchInputA11yProps = (placeholder = \"Search\", hint?: string): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.search,\n  accessibilityLabel: placeholder,\n  accessibilityHint: hint || \"Enter text to search\",\n});\n\n/**\n * Generate accessibility props for switches/toggles\n */\nexport const getSwitchA11yProps = (label: string, isOn: boolean, disabled = false): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.switch,\n  accessibilityLabel: label,\n  accessibilityState: {\n    disabled,\n    checked: isOn,\n  },\n  accessibilityValue: {\n    text: isOn ? \"On\" : \"Off\",\n  },\n});\n\n/**\n * Generate accessibility props for tab buttons\n */\nexport const getTabA11yProps = (\n  label: string,\n  isSelected: boolean,\n  tabIndex: number,\n  totalTabs: number,\n): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.tab,\n  accessibilityLabel: label,\n  accessibilityState: {\n    selected: isSelected,\n  },\n  accessibilityHint: `Tab ${tabIndex + 1} of ${totalTabs}. Double tap to select.`,\n});\n\n/**\n * Generate accessibility props for progress indicators\n */\nexport const getProgressA11yProps = (label: string, current: number, max: number): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.progressbar,\n  accessibilityLabel: label,\n  accessibilityValue: {\n    min: 0,\n    max,\n    now: current,\n    text: max > 0 ? `${Math.round((current / max) * 100)}% complete` : \"0% complete\",\n  },\n});\n\n/**\n * Generate accessibility props for alerts/notifications\n */\nexport const getAlertA11yProps = (\n  message: string,\n  type: \"info\" | \"warning\" | \"error\" | \"success\" = \"info\",\n): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.alert,\n  accessibilityLabel: `${type}: ${message}`,\n  accessibilityLiveRegion: \"polite\",\n});\n\n/**\n * Generate accessibility props for lists\n */\nexport const getListA11yProps = (label: string, itemCount: number): A11yProps => ({\n  accessibilityRole: A11Y_ROLES.list,\n  accessibilityLabel: `${label}, ${itemCount} items`,\n});\n\n/**\n * Generate accessibility props for list items\n */\nexport const getListItemA11yProps = (label: string, index: number, total: number): A11yProps => ({\n  accessibilityRole: \"none\",\n  accessibilityLabel: `${label}, item ${index + 1} of ${total}`,\n});\n\n/**\n * Utility to combine multiple accessibility props\n */\nexport const combineA11yProps = (...props: (A11yProps | undefined)[]): A11yProps => {\n  const validProps = props.filter((p): p is A11yProps => !!p);\n  return validProps.reduce((combined, current) => {\n    return {\n      ...combined,\n      ...current,\n      accessibilityState: {\n        ...combined.accessibilityState,\n        ...current.accessibilityState,\n      },\n      accessibilityValue: {\n        ...combined.accessibilityValue,\n        ...current.accessibilityValue,\n      },\n    };\n  }, {} as A11yProps);\n};\n\n// Enhanced accessibility functions for screen reader support\nexport const isScreenReaderEnabled = async (): Promise<boolean> => {\n  try {\n    return await AccessibilityInfo.isScreenReaderEnabled();\n  } catch {\n    return false;\n  }\n};\n\nexport const isReduceMotionEnabled = async (): Promise<boolean> => {\n  try {\n    return await AccessibilityInfo.isReduceMotionEnabled();\n  } catch {\n    return false;\n  }\n};\n\nexport const announceForAccessibility = async (message: string): Promise<void> => {\n  try {\n    await AccessibilityInfo.announceForAccessibility(message);\n  } catch (error) {\n    console.error(\"Failed to announce for accessibility:\", error);\n  }\n};\n\n// Onboarding-specific accessibility announcements\nexport const announceSlideChange = (slideIndex: number, totalSlides: number, slideTitle: string) => {\n  const message = `Slide ${slideIndex + 1} of ${totalSlides}: ${slideTitle}`;\n  announceForAccessibility(message);\n};\n\nexport const announceOnboardingComplete = () => {\n  announceForAccessibility(\"Onboarding complete. Redirecting to sign up.\");\n};\n\nexport const announceOnboardingSkipped = () => {\n  announceForAccessibility(\"Onboarding skipped. Redirecting to sign up.\");\n};\n\n// Accessibility state management\nexport interface CustomAccessibilityState {\n  isScreenReaderEnabled: boolean;\n  isReduceMotionEnabled: boolean;\n  isReduceTransparencyEnabled: boolean;\n  prefersCrossFadeTransitions: boolean;\n}\n\n// Get current accessibility state\nexport const getAccessibilityState = async (): Promise<CustomAccessibilityState> => {\n  try {\n    const [isScreenReaderEnabled, isReduceMotionEnabled, isReduceTransparencyEnabled, prefersCrossFadeTransitions] =\n      await Promise.all([\n        AccessibilityInfo.isScreenReaderEnabled(),\n        AccessibilityInfo.isReduceMotionEnabled(),\n        AccessibilityInfo.isReduceTransparencyEnabled(),\n        AccessibilityInfo.prefersCrossFadeTransitions(),\n      ]);\n\n    return {\n      isScreenReaderEnabled,\n      isReduceMotionEnabled,\n      isReduceTransparencyEnabled,\n      prefersCrossFadeTransitions,\n    };\n  } catch (error) {\n    console.warn(\"Failed to get accessibility state:\", error);\n    return {\n      isScreenReaderEnabled: false,\n      isReduceMotionEnabled: false,\n      isReduceTransparencyEnabled: false,\n      prefersCrossFadeTransitions: false,\n    };\n  }\n};\n\n// Haptic feedback with accessibility consideration\nexport const accessibleHapticFeedback = async (\n  type: \"light\" | \"medium\" | \"heavy\" | \"success\" | \"warning\" | \"error\" = \"light\",\n) => {\n  try {\n    const { isReduceMotionEnabled } = await getAccessibilityState();\n\n    // Reduce haptic intensity if reduce motion is enabled\n    if (isReduceMotionEnabled) {\n      // Use lighter haptic feedback or skip entirely\n      if (type === \"heavy\") {\n        type = \"light\";\n      } else if (type === \"medium\") {\n        type = \"light\";\n      }\n      // Skip haptics for error/warning/success if reduce motion is enabled\n      if ([\"error\", \"warning\", \"success\"].includes(type)) {\n        return;\n      }\n    }\n\n    // Import and use expo-haptics for real haptic feedback\n    try {\n      const Haptics = await import(\"expo-haptics\");\n\n      switch (type) {\n        case \"light\":\n          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n          break;\n        case \"medium\":\n          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n          break;\n        case \"heavy\":\n          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n          break;\n        case \"success\":\n          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n          break;\n        case \"warning\":\n          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n          break;\n        case \"error\":\n          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n          break;\n        default:\n          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      }\n    } catch (hapticsError) {\n      // Fallback if expo-haptics is not available\n      console.log(`Haptic feedback (fallback): ${type}`);\n    }\n  } catch (error) {\n    console.warn(\"Haptic feedback failed:\", error);\n  }\n};\n\nexport const setAccessibilityFocus = async (reactTag: number): Promise<void> => {\n  try {\n    await AccessibilityInfo.setAccessibilityFocus(reactTag);\n  } catch (error) {\n    console.error(\"Failed to set accessibility focus:\", error);\n  }\n};\n\n// Accessibility helpers for common patterns\nexport const AccessibilityHelpers = {\n  formatCount: (count: number, singular: string, plural?: string): string => {\n    const pluralForm = plural || `${singular}s`;\n    return `${count} ${count === 1 ? singular : pluralForm}`;\n  },\n\n  formatTime: (timestamp: number): string => {\n    const now = Date.now();\n    const diff = now - timestamp;\n    const minutes = Math.floor(diff / 60000);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${days} ${days === 1 ? \"day\" : \"days\"} ago`;\n    if (hours > 0) return `${hours} ${hours === 1 ? \"hour\" : \"hours\"} ago`;\n    if (minutes > 0) return `${minutes} ${minutes === 1 ? \"minute\" : \"minutes\"} ago`;\n    return \"Just now\";\n  },\n\n  getLoadingMessage: (context: string): string => {\n    return `Loading ${context}, please wait`;\n  },\n\n  getErrorMessage: (error: string, context?: string): string => {\n    return context ? `Error in ${context}: ${error}` : `Error: ${error}`;\n  },\n\n  getSuccessMessage: (action: string): string => {\n    return `${action} completed successfully`;\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/adFrequency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/apiUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/buildMode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/cacheInvalidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/cn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/colorContrast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/confessionNormalizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/consolidatedUtils.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.","line":303,"column":14,"nodeType":"SpreadElement","endLine":303,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/debugConfessions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/environmentCheck.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/environmentDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/environmentValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/errorHandling.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":213,"column":37,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":213,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Standardized error handling utilities for Zustand stores\n * Provides consistent error processing, logging, and state management\n */\n\nimport {\n  isSupabaseError,\n  getSupabaseErrorCode,\n  getSupabaseErrorMessage,\n  isRetryableSupabaseError,\n  logSupabaseError,\n} from \"../types/supabaseError\";\n\nexport interface StandardError {\n  code: string;\n  message: string;\n  timestamp?: number;\n  context?: string;\n  isRetryable?: boolean;\n  originalError?: unknown;\n  details?: Record<string, any>;\n  statusCode?: number;\n}\n\nexport interface ErrorHandlingOptions {\n  /** Whether to throw the error after setting state (default: false) */\n  shouldThrow?: boolean;\n  /** Additional context for debugging */\n  context?: string;\n  /** Whether to log the error in development (default: true) */\n  shouldLog?: boolean;\n  /** Custom error message override */\n  customMessage?: string;\n}\n\n/**\n * Processes an error into a standardized format\n */\nexport const processError = (error: unknown, context?: string, customMessage?: string): StandardError => {\n  let code = \"UNKNOWN_ERROR\";\n  let message = customMessage || \"An unknown error occurred\";\n  let isRetryable = false;\n\n  // Handle Supabase errors first\n  if (isSupabaseError(error)) {\n    code = getSupabaseErrorCode(error) || \"SUPABASE_ERROR\";\n    const supabaseMessage = translateSupabaseError(code);\n    message = customMessage || supabaseMessage || getSupabaseErrorMessage(error);\n    isRetryable = isRetryableSupabaseError(error);\n\n    // Log Supabase error with context\n    if (context) {\n      logSupabaseError(error, context);\n    }\n  } else if (error instanceof Error) {\n    message = customMessage || error.message;\n\n    // Handle auth errors\n    if (error.name === \"AuthError\") {\n      // Preserve the specific auth error code\n      code = (error as any).code || \"AUTH_ERROR\";\n    }\n\n    // Handle network errors\n    if (\n      error.name === \"NetworkError\" ||\n      error.message.toLowerCase().includes(\"network\") ||\n      error.message.toLowerCase().includes(\"fetch\") ||\n      error.message.toLowerCase().includes(\"connection\") ||\n      error.message.toLowerCase().includes(\"unreachable\") ||\n      (error as any).code === \"NETWORK_ERROR\"\n    ) {\n      code = \"NETWORK_ERROR\";\n      message = customMessage || \"Network connection failed. Please check your internet connection.\";\n      isRetryable = true;\n    }\n\n    // Handle timeout errors\n    if (error.message.includes(\"timeout\")) {\n      code = \"TIMEOUT_ERROR\";\n      message = customMessage || \"Request timed out. Please try again.\";\n      isRetryable = true;\n    }\n  }\n\n  return {\n    code,\n    message,\n    timestamp: Date.now(),\n    context,\n    isRetryable,\n    originalError: error,\n  };\n};\n\n/**\n * Standardized error handler for Zustand stores\n * Sets error state and optionally throws based on configuration\n */\nexport const handleStoreError = <T extends { error: StandardError | null; isLoading?: boolean }>(\n  setState: (partial: Partial<T>) => void,\n  error: unknown,\n  options: ErrorHandlingOptions = {},\n): never | void => {\n  const { shouldThrow = false, context, shouldLog = true, customMessage } = options;\n\n  const processedError = processError(error, context, customMessage);\n\n  // Log error in development\n  if (__DEV__ && shouldLog) {\n    console.error(`[Store Error] ${context || \"Unknown context\"}:`, {\n      code: processedError.code,\n      message: processedError.message,\n      originalError: error,\n    });\n  }\n\n  // Set error state\n  setState({\n    error: processedError,\n    isLoading: false,\n  } as Partial<T>);\n\n  // Throw if requested\n  if (shouldThrow) {\n    throw error;\n  }\n};\n\n/**\n * Clears error state in a standardized way\n */\nexport const clearStoreError = <T extends { error: StandardError | null }>(\n  setState: (partial: Partial<T>) => void,\n): void => {\n  setState({ error: null } as Partial<T>);\n};\n\n/**\n * Wraps async store operations with standardized error handling\n */\nexport const withErrorHandling = async <T extends { error: StandardError | null; isLoading?: boolean }>(\n  setState: (partial: Partial<T>) => void,\n  operation: () => Promise<void>,\n  options: ErrorHandlingOptions = {},\n): Promise<void> => {\n  try {\n    // Clear previous errors and set loading\n    setState({ error: null, isLoading: true } as Partial<T>);\n\n    await operation();\n\n    // Clear loading state on success\n    setState({ isLoading: false } as Partial<T>);\n  } catch (error) {\n    handleStoreError(setState, error, options);\n  }\n};\n\n/**\n * Enhanced Supabase error code translations\n */\nexport function translateSupabaseError(code?: string): string | undefined {\n  switch (code) {\n    case \"invalid_login_credentials\":\n      return \"Incorrect email or password. Please try again.\";\n    case \"user_not_found\":\n      return \"No account found with this email address.\";\n    case \"user_already_exists\":\n      return \"An account with this email already exists.\";\n    case \"invalid_email\":\n      return \"Please enter a valid email address.\";\n    case \"weak_password\":\n      return \"Password must be at least 6 characters long.\";\n    case \"network_error\":\n      return \"Network error. Please check your connection and try again.\";\n    case \"email_not_confirmed\":\n      return \"Please verify your email address before signing in.\";\n    case \"too_many_requests\":\n      return \"Too many attempts. Please wait a moment and try again.\";\n    case \"signup_disabled\":\n      return \"New registrations are temporarily disabled.\";\n    case \"invalid_credentials\":\n      return \"Invalid email or password. Please check your credentials.\";\n    case \"email_address_invalid\":\n      return \"Please enter a valid email address.\";\n    case \"password_too_short\":\n      return \"Password must be at least 6 characters long.\";\n    case \"email_address_not_authorized\":\n      return \"This email address is not authorized to sign up.\";\n    case \"captcha_failed\":\n      return \"Security verification failed. Please try again.\";\n    case \"over_email_send_rate_limit\":\n      return \"Too many emails sent. Please wait before requesting another.\";\n    case \"invalid_request\":\n      return \"Invalid request. Please check your information and try again.\";\n    case \"session_not_found\":\n      return \"Your session has expired. Please sign in again.\";\n    case \"refresh_token_not_found\":\n      return \"Session expired. Please sign in again.\";\n    case \"invalid_refresh_token\":\n      return \"Session expired. Please sign in again.\";\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Get screen-specific error message with fallback to generic messages\n */\nexport const getScreenSpecificMessage = (error: StandardError, screenName: string): string => {\n  // Import screen error messages\n  const { getScreenErrorMessage } = require(\"./screenErrorMessages\");\n\n  const screenError = getScreenErrorMessage(error, screenName);\n  if (screenError.message !== error.message) {\n    // Include suggestion if available\n    return screenError.suggestion ? `${screenError.message} ${screenError.suggestion}` : screenError.message;\n  }\n\n  // Fall back to generic user-friendly message\n  return getUserFriendlyMessage(error);\n};\n\n/**\n * User-friendly error messages for common error codes\n */\nexport const getUserFriendlyMessage = (error: StandardError, screenContext?: string): string => {\n  // If screen context provided, try screen-specific messages first\n  if (screenContext) {\n    return getScreenSpecificMessage(error, screenContext);\n  }\n\n  // First try to get Supabase-specific error message\n  const supabaseMessage = translateSupabaseError(error.code);\n  if (supabaseMessage) {\n    return supabaseMessage;\n  }\n\n  // Fall back to generic error codes\n  switch (error.code) {\n    case \"NETWORK_ERROR\":\n      return \"Please check your internet connection and try again.\";\n    case \"TIMEOUT_ERROR\":\n      return \"The request took too long. Please try again.\";\n    case \"AUTH_ERROR\":\n      return \"Authentication failed. Please sign in again.\";\n    case \"PERMISSION_DENIED\":\n      return \"You don't have permission to perform this action.\";\n    case \"NOT_FOUND\":\n      return \"The requested item could not be found.\";\n    case \"VALIDATION_ERROR\":\n      return \"Please check your input and try again.\";\n    case \"RATE_LIMIT_EXCEEDED\":\n      return \"Too many requests. Please wait a moment and try again.\";\n    case \"INVALID_CREDENTIALS\":\n      return \"Invalid email or password. Please check your credentials and try again.\";\n    case \"EMAIL_NOT_CONFIRMED\":\n      return \"Please check your email and click the confirmation link before signing in.\";\n    case \"TOO_MANY_REQUESTS\":\n      return \"Too many sign-in attempts. Please wait a moment and try again.\";\n    case \"USER_EXISTS\":\n      return \"An account with this email already exists. Please sign in instead.\";\n    case \"WEAK_PASSWORD\":\n      return \"Password must be at least 6 characters long.\";\n    case \"INVALID_EMAIL\":\n      return \"Please enter a valid email address.\";\n    case \"PASSWORD_MISMATCH\":\n      return \"Passwords do not match.\";\n    case \"MISSING_PASSWORD\":\n      return \"Please enter your password.\";\n    case \"SIGNIN_ERROR\":\n      return \"Sign in failed. Please try again.\";\n    default:\n      return error.message;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/haptics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/healthMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":339,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":339,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * App health monitoring system\n * Tracks performance, errors, and user experience metrics\n */\n\nimport * as React from \"react\";\nimport { AppState, AppStateStatus } from \"react-native\";\nimport * as Device from \"expo-device\";\nimport * as Application from \"expo-application\";\nimport NetInfo from \"@react-native-community/netinfo\";\n\nexport interface HealthMetrics {\n  performance: {\n    appStartTime: number;\n    screenLoadTimes: Record<string, number>;\n    apiResponseTimes: Record<string, number[]>;\n    memoryUsage: number[];\n    crashCount: number;\n  };\n  user: {\n    sessionDuration: number;\n    screenViews: Record<string, number>;\n    interactions: Record<string, number>;\n    errors: {\n      timestamp: number;\n      error: string;\n      screen: string;\n      userId?: string;\n    }[];\n  };\n  system: {\n    deviceInfo: any;\n    appVersion: string;\n    networkStatus: string;\n    batteryLevel?: number;\n    storageUsage: number;\n  };\n}\n\nclass HealthMonitor {\n  private metrics: HealthMetrics;\n  private sessionStartedAt: number;\n  private lastScreenChangeAt: number | null = null;\n  private currentScreen: string = \"Unknown\";\n  private isMonitoring: boolean = false;\n  private reportingInterval: NodeJS.Timeout | null = null;\n  private appStateListener: ReturnType<typeof AppState.addEventListener> | null = null;\n  private netInfoUnsubscribe: (() => void) | null = null;\n\n  constructor() {\n    this.sessionStartedAt = Date.now();\n    this.metrics = this.initializeMetrics();\n  }\n\n  private initializeMetrics(): HealthMetrics {\n    return {\n      performance: {\n        appStartTime: Date.now(),\n        screenLoadTimes: {},\n        apiResponseTimes: {},\n        memoryUsage: [],\n        crashCount: 0,\n      },\n      user: {\n        sessionDuration: 0,\n        screenViews: {},\n        interactions: {},\n        errors: [],\n      },\n      system: {\n        deviceInfo: {},\n        appVersion: Application.nativeApplicationVersion || \"unknown\",\n        networkStatus: \"unknown\",\n        storageUsage: 0,\n      },\n    };\n  }\n\n  /**\n   * Start monitoring app health\n   */\n  async startMonitoring() {\n    if (this.isMonitoring) return;\n\n    this.isMonitoring = true;\n\n    // Collect initial system info\n    await this.collectSystemInfo();\n\n    // Set up periodic monitoring\n    this.setupPeriodicMonitoring();\n\n    // Set up app state monitoring\n    this.setupAppStateMonitoring();\n\n    // Set up network monitoring\n    this.setupNetworkMonitoring();\n\n    if (__DEV__) {\n      console.log(\"🏥 Health monitoring started\");\n    }\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring() {\n    this.isMonitoring = false;\n\n    if (this.reportingInterval) {\n      clearInterval(this.reportingInterval);\n      this.reportingInterval = null;\n    }\n\n    if (this.appStateListener) {\n      this.appStateListener.remove();\n      this.appStateListener = null;\n    }\n\n    if (this.netInfoUnsubscribe) {\n      this.netInfoUnsubscribe();\n      this.netInfoUnsubscribe = null;\n    }\n\n    if (__DEV__) {\n      console.log(\"🏥 Health monitoring stopped\");\n    }\n  }\n\n  /**\n   * Track screen navigation\n   */\n  trackScreenView(screenName: string) {\n    const now = Date.now();\n\n    // Record screen load time if we have a previous screen change\n    if (this.lastScreenChangeAt !== null) {\n      const loadTime = now - this.lastScreenChangeAt;\n      this.metrics.performance.screenLoadTimes[screenName] = loadTime;\n    }\n\n    // Update last screen change time for next screen\n    this.lastScreenChangeAt = now;\n\n    // Update screen view count\n    this.metrics.user.screenViews[screenName] = (this.metrics.user.screenViews[screenName] || 0) + 1;\n\n    this.currentScreen = screenName;\n\n    if (__DEV__) {\n      console.log(`📱 Screen view: ${screenName}`);\n    }\n  }\n\n  /**\n   * Track user interactions\n   */\n  trackInteraction(action: string, details?: any) {\n    this.metrics.user.interactions[action] = (this.metrics.user.interactions[action] || 0) + 1;\n\n    if (__DEV__ && details) {\n      console.log(`👆 Interaction: ${action}`, details);\n    }\n  }\n\n  /**\n   * Track API performance\n   */\n  trackApiCall(endpoint: string, responseTime: number, success: boolean) {\n    if (!this.metrics.performance.apiResponseTimes[endpoint]) {\n      this.metrics.performance.apiResponseTimes[endpoint] = [];\n    }\n\n    this.metrics.performance.apiResponseTimes[endpoint].push(responseTime);\n\n    // Keep only last 100 response times per endpoint\n    if (this.metrics.performance.apiResponseTimes[endpoint].length > 100) {\n      this.metrics.performance.apiResponseTimes[endpoint].shift();\n    }\n\n    if (__DEV__) {\n      console.log(`🌐 API ${success ? \"✅\" : \"❌\"}: ${endpoint} (${responseTime}ms)`);\n    }\n  }\n\n  /**\n   * Track errors\n   */\n  trackError(error: Error, screen?: string, userId?: string) {\n    this.metrics.user.errors.push({\n      timestamp: Date.now(),\n      error: error.message,\n      screen: screen || this.currentScreen,\n      userId,\n    });\n\n    // Keep only last 50 errors\n    if (this.metrics.user.errors.length > 50) {\n      this.metrics.user.errors.shift();\n    }\n\n    if (__DEV__) {\n      console.error(\"🚨 Error tracked:\", error.message, \"on\", screen || this.currentScreen);\n    }\n  }\n\n  /**\n   * Track app crashes\n   */\n  trackCrash() {\n    this.metrics.performance.crashCount++;\n\n    if (__DEV__) {\n      console.error(\"💥 Crash tracked\");\n    }\n  }\n\n  /**\n   * Get current health metrics\n   */\n  getMetrics(): HealthMetrics {\n    // Update session duration\n    this.metrics.user.sessionDuration = Date.now() - this.sessionStartedAt;\n\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get health summary\n   */\n  getHealthSummary() {\n    const metrics = this.getMetrics();\n\n    // Calculate averages\n    const avgApiResponseTimes: Record<string, number> = {};\n    for (const [endpoint, times] of Object.entries(metrics.performance.apiResponseTimes)) {\n      avgApiResponseTimes[endpoint] = times.reduce((a, b) => a + b, 0) / times.length;\n    }\n\n    const avgMemoryUsage =\n      metrics.performance.memoryUsage.length > 0\n        ? metrics.performance.memoryUsage.reduce((a, b) => a + b, 0) / metrics.performance.memoryUsage.length\n        : 0;\n\n    return {\n      sessionDuration: metrics.user.sessionDuration,\n      totalScreenViews: Object.values(metrics.user.screenViews).reduce((a, b) => a + b, 0),\n      totalInteractions: Object.values(metrics.user.interactions).reduce((a, b) => a + b, 0),\n      totalErrors: metrics.user.errors.length,\n      crashCount: metrics.performance.crashCount,\n      avgApiResponseTime:\n        Object.values(avgApiResponseTimes).reduce((a, b) => a + b, 0) / Object.keys(avgApiResponseTimes).length || 0,\n      avgMemoryUsage,\n      networkStatus: metrics.system.networkStatus,\n      appVersion: metrics.system.appVersion,\n    };\n  }\n\n  /**\n   * Export metrics for reporting\n   */\n  exportMetrics() {\n    const metrics = this.getMetrics();\n    const summary = this.getHealthSummary();\n\n    return {\n      timestamp: new Date().toISOString(),\n      summary,\n      detailed: metrics,\n    };\n  }\n\n  private async collectSystemInfo() {\n    try {\n      // Device info\n      this.metrics.system.deviceInfo = {\n        deviceName: Device.deviceName,\n        deviceType: Device.deviceType,\n        osName: Device.osName,\n        osVersion: Device.osVersion,\n        modelName: Device.modelName,\n        totalMemory: Device.totalMemory,\n      };\n\n      // Network status\n      const netInfo = await NetInfo.fetch();\n      this.metrics.system.networkStatus = `${netInfo.type}-${netInfo.isConnected ? \"connected\" : \"disconnected\"}`;\n    } catch (error) {\n      console.error(\"Failed to collect system info:\", error);\n    }\n  }\n\n  private setupPeriodicMonitoring() {\n    this.reportingInterval = setInterval(() => {\n      this.collectMemoryUsage();\n\n      // Log health summary in development\n      if (__DEV__) {\n        const summary = this.getHealthSummary();\n        console.log(\"🏥 Health Summary:\", summary);\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  private onAppStateChange = (nextAppState: AppStateStatus) => {\n    this.trackInteraction(\"app_state_change\", { state: nextAppState });\n\n    if (nextAppState === \"background\") {\n      // App went to background - good time to report metrics\n      void this.reportMetrics();\n    }\n  };\n\n  private setupAppStateMonitoring() {\n    this.appStateListener = AppState.addEventListener(\"change\", this.onAppStateChange);\n  }\n\n  private setupNetworkMonitoring() {\n    this.netInfoUnsubscribe = NetInfo.addEventListener((state) => {\n      const status = `${state.type}-${state.isConnected ? \"connected\" : \"disconnected\"}`;\n      this.metrics.system.networkStatus = status;\n      this.trackInteraction(\"network_change\", { status });\n    });\n  }\n\n  private collectMemoryUsage() {\n    try {\n      if (global.performance && (global.performance as any).memory) {\n        const memory = (global.performance as any).memory;\n        const usedMB = memory.usedJSHeapSize / 1024 / 1024;\n\n        this.metrics.performance.memoryUsage.push(usedMB);\n\n        // Keep only last 100 memory readings\n        if (this.metrics.performance.memoryUsage.length > 100) {\n          this.metrics.performance.memoryUsage.shift();\n        }\n      }\n    } catch (error) {\n      // Memory API not available, skip silently\n    }\n  }\n\n  private async reportMetrics() {\n    if (!this.isMonitoring) return;\n\n    try {\n      const report = this.exportMetrics();\n\n      // In a real app, you would send this to your analytics service\n      if (__DEV__) {\n        console.log(\"📊 Health Report:\", report);\n      }\n\n      // TODO: Send to analytics service\n      // await analyticsService.reportHealth(report);\n    } catch (error) {\n      console.error(\"Failed to report metrics:\", error);\n    }\n  }\n}\n\n// Singleton instance\nexport const healthMonitor = new HealthMonitor();\n\n/**\n * React hook for health monitoring\n */\nexport function useHealthMonitor() {\n  React.useEffect(() => {\n    healthMonitor.startMonitoring();\n\n    return () => {\n      healthMonitor.stopMonitoring();\n    };\n  }, []);\n\n  return {\n    trackScreenView: healthMonitor.trackScreenView.bind(healthMonitor),\n    trackInteraction: healthMonitor.trackInteraction.bind(healthMonitor),\n    trackApiCall: healthMonitor.trackApiCall.bind(healthMonitor),\n    trackError: healthMonitor.trackError.bind(healthMonitor),\n    getMetrics: healthMonitor.getMetrics.bind(healthMonitor),\n    getHealthSummary: healthMonitor.getHealthSummary.bind(healthMonitor),\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/hermesPolyfill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/hermesTestUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":97,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":155,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Platform } from \"react-native\";\n\n/**\n * Hermes compatibility test utilities\n * These functions help verify that Hermes-specific fixes are working correctly\n */\n\nexport interface HermesTestResult {\n  constructorTest: boolean;\n  errorBoundaryTest: boolean;\n  videoDisposalTest: boolean;\n  timestamp: string;\n}\n\n/**\n * Test constructor handling in Hermes\n */\nexport function testConstructorHandling(): boolean {\n  try {\n    // Test class constructor that previously failed in Hermes\n    class TestClass {\n      private testProp: string;\n\n      constructor(props: { test: string }) {\n        // This pattern was causing issues in Hermes\n        this.testProp = props.test;\n      }\n\n      getTestProp(): string {\n        return this.testProp;\n      }\n    }\n\n    const instance = new TestClass({ test: \"hermes-test\" });\n    return instance.getTestProp() === \"hermes-test\";\n  } catch (error) {\n    if (__DEV__) {\n      console.warn(\"Constructor test failed:\", error);\n    }\n    return false;\n  }\n}\n\n/**\n * Test error boundary functionality\n */\nexport function testErrorBoundaryHandling(): boolean {\n  try {\n    // Simulate error boundary state management\n    const errorBoundaryState = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      errorId: \"\",\n    };\n\n    // Test state updates that were problematic\n    const updatedState = {\n      ...errorBoundaryState,\n      hasError: true,\n      error: new Error(\"Test error\"),\n      errorId: `error_${Date.now()}`,\n    };\n\n    return updatedState.hasError && updatedState.error !== null;\n  } catch (error) {\n    if (__DEV__) {\n      console.warn(\"Error boundary test failed:\", error);\n    }\n    return false;\n  }\n}\n\n/**\n * Test video disposal patterns\n */\nexport function testVideoDisposalHandling(): boolean {\n  try {\n    // Mock video player object\n    const mockPlayer = {\n      playing: false,\n      pause: () => Promise.resolve(),\n      unload: () => Promise.resolve(),\n    };\n\n    // Test disposal pattern that was causing warnings\n    const disposePlayer = async () => {\n      try {\n        if (mockPlayer.playing !== undefined && typeof mockPlayer.pause === \"function\") {\n          await mockPlayer.pause();\n\n          if (typeof mockPlayer.unload === \"function\") {\n            await mockPlayer.unload();\n          }\n        }\n        return true;\n      } catch (error) {\n        // Should handle errors gracefully\n        return false;\n      }\n    };\n\n    // Execute disposal test\n    disposePlayer();\n    return true;\n  } catch (error) {\n    if (__DEV__) {\n      console.warn(\"Video disposal test failed:\", error);\n    }\n    return false;\n  }\n}\n\n/**\n * Run all Hermes compatibility tests\n */\nexport function runHermesCompatibilityTests(): HermesTestResult {\n  const result: HermesTestResult = {\n    constructorTest: testConstructorHandling(),\n    errorBoundaryTest: testErrorBoundaryHandling(),\n    videoDisposalTest: testVideoDisposalHandling(),\n    timestamp: new Date().toISOString(),\n  };\n\n  if (__DEV__) {\n    console.group(\"🧪 Hermes Compatibility Test Results\");\n    console.log(\"Constructor Test:\", result.constructorTest ? \"✅ PASS\" : \"❌ FAIL\");\n    console.log(\"Error Boundary Test:\", result.errorBoundaryTest ? \"✅ PASS\" : \"❌ FAIL\");\n    console.log(\"Video Disposal Test:\", result.videoDisposalTest ? \"✅ PASS\" : \"❌ FAIL\");\n    console.log(\"Timestamp:\", result.timestamp);\n    console.groupEnd();\n  }\n\n  return result;\n}\n\n/**\n * Log Hermes engine information\n */\nexport function logHermesInfo(): void {\n  if (__DEV__) {\n    console.group(\"🔧 Hermes Engine Information\");\n\n    // Check if Hermes is enabled\n    const isHermes = typeof HermesInternal === \"object\" && HermesInternal !== null;\n    console.log(\"Hermes Enabled:\", isHermes ? \"✅ YES\" : \"❌ NO\");\n\n    if (isHermes) {\n      try {\n        // @ts-ignore - HermesInternal is not typed\n        const hermesVersion = HermesInternal?.getRuntimeProperties?.()?.[\"OSS Release Version\"];\n        if (hermesVersion) {\n          console.log(\"Hermes Version:\", hermesVersion);\n        }\n      } catch (error) {\n        console.log(\"Hermes Version: Unable to determine\");\n      }\n    }\n\n    // Log JavaScript engine info\n    console.log(\"JavaScript Engine:\", isHermes ? \"Hermes\" : \"JSC/V8\");\n    console.log(\"Platform:\", Platform.OS);\n\n    console.groupEnd();\n  }\n}\n\n// Auto-run tests in development\nif (__DEV__) {\n  // Run tests after a short delay to ensure app is initialized\n  setTimeout(() => {\n    logHermesInfo();\n    runHermesCompatibilityTests();\n  }, 2000);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/keyboardUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_insets' is assigned a value but never used.","line":119,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Keyboard utilities for improved keyboard handling across the app\n * Provides consistent keyboard behavior and proper cleanup\n */\n\nimport { Keyboard, Platform, Dimensions } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useEffect, useState } from \"react\";\n\nexport interface KeyboardInfo {\n  isVisible: boolean;\n  height: number;\n  duration: number;\n  easing: string;\n}\n\n/**\n * Hook to track keyboard visibility and height\n */\nexport const useKeyboard = () => {\n  const [keyboardInfo, setKeyboardInfo] = useState<KeyboardInfo>({\n    isVisible: false,\n    height: 0,\n    duration: 0,\n    easing: \"\",\n  });\n\n  useEffect(() => {\n    const showEvent = Platform.OS === \"ios\" ? \"keyboardWillShow\" : \"keyboardDidShow\";\n    const hideEvent = Platform.OS === \"ios\" ? \"keyboardWillHide\" : \"keyboardDidHide\";\n\n    const onKeyboardShow = (event: any) => {\n      setKeyboardInfo({\n        isVisible: true,\n        height: event.endCoordinates.height,\n        duration: event.duration || 250,\n        easing: event.easing || \"keyboard\",\n      });\n    };\n\n    const onKeyboardHide = (event: any) => {\n      setKeyboardInfo({\n        isVisible: false,\n        height: 0,\n        duration: event.duration || 250,\n        easing: event.easing || \"keyboard\",\n      });\n    };\n\n    const showSubscription = Keyboard.addListener(showEvent, onKeyboardShow);\n    const hideSubscription = Keyboard.addListener(hideEvent, onKeyboardHide);\n\n    return () => {\n      showSubscription?.remove();\n      hideSubscription?.remove();\n    };\n  }, []);\n\n  return keyboardInfo;\n};\n\n/**\n * Enhanced keyboard dismiss function with haptic feedback\n */\nexport const dismissKeyboard = (withHaptics = false) => {\n  Keyboard.dismiss();\n\n  if (withHaptics && Platform.OS === \"ios\") {\n    // Add subtle haptic feedback on keyboard dismiss\n    import(\"expo-haptics\")\n      .then(({ impactAsync, ImpactFeedbackStyle }) => {\n        impactAsync(ImpactFeedbackStyle.Light);\n      })\n      .catch(() => {\n        // Haptics not available - silently fail\n      });\n  }\n};\n\n/**\n * Get appropriate KeyboardAvoidingView behavior for platform\n */\nexport const getKeyboardBehavior = () => {\n  return Platform.OS === \"ios\" ? \"padding\" : \"height\";\n};\n\n/**\n * Get keyboard vertical offset for different screen types\n */\nexport const getKeyboardVerticalOffset = (screenType: \"modal\" | \"screen\" | \"bottomSheet\" = \"screen\") => {\n  if (Platform.OS === \"android\") return 0;\n\n  switch (screenType) {\n    case \"modal\":\n      return 0;\n    case \"bottomSheet\":\n      return 0;\n    case \"screen\":\n    default:\n      return 0; // Let SafeAreaView handle the offset\n  }\n};\n\n/**\n * Hook for keyboard-aware bottom padding\n */\nexport const useKeyboardPadding = (additionalPadding = 0) => {\n  const keyboard = useKeyboard();\n  const insets = useSafeAreaInsets();\n\n  return keyboard.isVisible ? keyboard.height + additionalPadding : insets.bottom + additionalPadding;\n};\n\n/**\n * Calculate safe keyboard height considering safe area\n */\nexport const useSafeKeyboardHeight = () => {\n  const keyboard = useKeyboard();\n  const _insets = useSafeAreaInsets();\n\n  if (!keyboard.isVisible) return 0;\n\n  // On iOS, keyboard height already accounts for safe area\n  if (Platform.OS === \"ios\") {\n    return keyboard.height;\n  }\n\n  // On Android, we might need to adjust\n  return keyboard.height;\n};\n\n/**\n * Keyboard configuration for different input types\n */\nexport const KEYBOARD_CONFIGS = {\n  text: {\n    keyboardType: \"default\" as const,\n    autoCapitalize: \"sentences\" as const,\n    autoCorrect: true,\n    spellCheck: true,\n  },\n  email: {\n    keyboardType: \"email-address\" as const,\n    autoCapitalize: \"none\" as const,\n    autoCorrect: false,\n    spellCheck: false,\n  },\n  password: {\n    keyboardType: \"default\" as const,\n    autoCapitalize: \"none\" as const,\n    autoCorrect: false,\n    spellCheck: false,\n    secureTextEntry: true,\n  },\n  numeric: {\n    keyboardType: \"numeric\" as const,\n    autoCapitalize: \"none\" as const,\n    autoCorrect: false,\n    spellCheck: false,\n  },\n  search: {\n    keyboardType: \"default\" as const,\n    autoCapitalize: \"none\" as const,\n    autoCorrect: false,\n    spellCheck: false,\n    returnKeyType: \"search\" as const,\n  },\n  comment: {\n    keyboardType: \"default\" as const,\n    autoCapitalize: \"sentences\" as const,\n    autoCorrect: true,\n    spellCheck: true,\n    returnKeyType: \"send\" as const,\n  },\n} as const;\n\n/**\n * Enhanced TextInput props with keyboard optimizations\n */\nexport const getOptimizedTextInputProps = (type: keyof typeof KEYBOARD_CONFIGS) => {\n  const config = KEYBOARD_CONFIGS[type];\n\n  return {\n    ...config,\n    blurOnSubmit: type === \"search\" || type === \"comment\",\n    enablesReturnKeyAutomatically: true,\n    keyboardAppearance: \"dark\" as const,\n    selectionColor: \"#1D9BF0\",\n    underlineColorAndroid: \"transparent\",\n  };\n};\n\n/**\n * Keyboard-aware scroll view props\n */\nexport const getKeyboardAwareScrollProps = () => {\n  return {\n    keyboardShouldPersistTaps: \"handled\" as const,\n    keyboardDismissMode: Platform.OS === \"ios\" ? (\"interactive\" as const) : (\"on-drag\" as const),\n    showsVerticalScrollIndicator: false,\n    contentInsetAdjustmentBehavior: \"automatic\" as const,\n  };\n};\n\n/**\n * Hook for keyboard-aware modal positioning\n */\nexport const useKeyboardAwareModal = () => {\n  const keyboard = useKeyboard();\n  const screenHeight = Dimensions.get(\"window\").height;\n\n  const modalOffset = keyboard.isVisible ? Math.max(0, (keyboard.height - screenHeight * 0.3) / 2) : 0;\n\n  return {\n    isKeyboardVisible: keyboard.isVisible,\n    keyboardHeight: keyboard.height,\n    modalOffset,\n    animationDuration: keyboard.duration,\n  };\n};\n\n/**\n * Utility to handle keyboard events in components\n */\nexport const createKeyboardHandler = (onShow?: (height: number) => void, onHide?: () => void) => {\n  const showEvent = Platform.OS === \"ios\" ? \"keyboardWillShow\" : \"keyboardDidShow\";\n  const hideEvent = Platform.OS === \"ios\" ? \"keyboardWillHide\" : \"keyboardDidHide\";\n\n  const showSubscription = Keyboard.addListener(showEvent, (event) => {\n    onShow?.(event.endCoordinates.height);\n  });\n\n  const hideSubscription = Keyboard.addListener(hideEvent, () => {\n    onHide?.();\n  });\n\n  return () => {\n    showSubscription?.remove();\n    hideSubscription?.remove();\n  };\n};\n\n/**\n * Debounced keyboard dismiss for rapid interactions\n */\nlet dismissTimeout: NodeJS.Timeout;\n\nexport const debouncedKeyboardDismiss = (delay = 100) => {\n  clearTimeout(dismissTimeout);\n  dismissTimeout = setTimeout(() => {\n    Keyboard.dismiss();\n  }, delay);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/legacyFileSystem.ts","messages":[{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'getInfoAsync'.","line":1,"column":1,"nodeType":"ExportAllDeclaration","endLine":1,"endColumn":34},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'uploadAsync'.","line":1,"column":1,"nodeType":"ExportAllDeclaration","endLine":1,"endColumn":34},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'getInfoAsync'.","line":2,"column":10,"nodeType":"Identifier","endLine":2,"endColumn":22},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'uploadAsync'.","line":2,"column":24,"nodeType":"Identifier","endLine":2,"endColumn":35}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export * from \"expo-file-system\";\nexport { getInfoAsync, uploadAsync } from \"expo-file-system/legacy\";\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/links.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/loadingTransitions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'duration' is assigned a value but never used.","line":243,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":243,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemCount' is assigned a value but never used.","line":263,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":263,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  withTiming,\n  withSpring,\n  withSequence,\n  withDelay,\n  withRepeat,\n  Easing,\n  cancelAnimation,\n  runOnJS,\n  SharedValue,\n  AnimatedStyle,\n  WithTimingConfig,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\nimport { AccessibilityInfo } from \"react-native\";\nimport * as Haptics from \"expo-haptics\";\n\nexport type TransitionPreset =\n  | \"fade\"\n  | \"slide\"\n  | \"scale\"\n  | \"fadeSlide\"\n  | \"bounce\"\n  | \"smooth\"\n  | \"error\"\n  | \"success\"\n  | \"loading\";\n\nexport type TransitionScenario =\n  | \"initialLoad\"\n  | \"refresh\"\n  | \"loadMore\"\n  | \"errorRecovery\"\n  | \"contentReady\"\n  | \"networkReconnect\";\n\ninterface TransitionConfig {\n  duration?: number;\n  delay?: number;\n  easing?: typeof Easing.linear;\n  springConfig?: WithSpringConfig;\n  reducedMotion?: boolean;\n}\n\ninterface StaggerConfig {\n  itemCount: number;\n  baseDelay?: number;\n  staggerDelay?: number;\n  reverse?: boolean;\n}\n\ninterface AnimationPerformance {\n  startTime: number;\n  endTime?: number;\n  frameCount: number;\n  averageFPS?: number;\n}\n\nexport class LoadingTransitions {\n  private static performanceMetrics: Map<string, AnimationPerformance> = new Map();\n  private static activeAnimations: Set<string> = new Set();\n  private static reducedMotionEnabled: boolean = false;\n\n  static {\n    AccessibilityInfo.isReduceMotionEnabled().then((enabled) => {\n      this.reducedMotionEnabled = enabled || false;\n    });\n\n    AccessibilityInfo.addEventListener(\"reduceMotionChanged\", (enabled) => {\n      this.reducedMotionEnabled = enabled;\n    });\n  }\n\n  static getPresetConfig(preset: TransitionPreset): Required<TransitionConfig> {\n    const configs: Record<TransitionPreset, Required<TransitionConfig>> = {\n      fade: {\n        duration: 300,\n        delay: 0,\n        easing: Easing.out(Easing.quad),\n        springConfig: { damping: 15, stiffness: 100 },\n        reducedMotion: false,\n      },\n      slide: {\n        duration: 400,\n        delay: 0,\n        easing: Easing.out(Easing.cubic),\n        springConfig: { damping: 20, stiffness: 90 },\n        reducedMotion: false,\n      },\n      scale: {\n        duration: 350,\n        delay: 0,\n        easing: Easing.out(Easing.back(1.2)),\n        springConfig: { damping: 12, stiffness: 180 },\n        reducedMotion: false,\n      },\n      fadeSlide: {\n        duration: 450,\n        delay: 0,\n        easing: Easing.out(Easing.cubic),\n        springConfig: { damping: 18, stiffness: 100 },\n        reducedMotion: false,\n      },\n      bounce: {\n        duration: 500,\n        delay: 0,\n        easing: Easing.bounce,\n        springConfig: { damping: 8, stiffness: 200, overshootClamping: false },\n        reducedMotion: false,\n      },\n      smooth: {\n        duration: 600,\n        delay: 0,\n        easing: Easing.inOut(Easing.ease),\n        springConfig: { damping: 25, stiffness: 80 },\n        reducedMotion: false,\n      },\n      error: {\n        duration: 300,\n        delay: 0,\n        easing: Easing.out(Easing.exp),\n        springConfig: { damping: 10, stiffness: 150 },\n        reducedMotion: false,\n      },\n      success: {\n        duration: 400,\n        delay: 0,\n        easing: Easing.out(Easing.elastic(1.2)),\n        springConfig: { damping: 15, stiffness: 120 },\n        reducedMotion: false,\n      },\n      loading: {\n        duration: 1000,\n        delay: 0,\n        easing: Easing.linear,\n        springConfig: { damping: 20, stiffness: 100 },\n        reducedMotion: false,\n      },\n    };\n\n    const config = configs[preset];\n\n    if (this.reducedMotionEnabled) {\n      config.duration = Math.min(config.duration, 200);\n      config.easing = Easing.linear;\n    }\n\n    return config;\n  }\n\n  static getScenarioConfig(scenario: TransitionScenario): TransitionConfig {\n    const configs: Record<TransitionScenario, TransitionConfig> = {\n      initialLoad: {\n        duration: 500,\n        delay: 100,\n        easing: Easing.out(Easing.cubic),\n      },\n      refresh: {\n        duration: 400,\n        delay: 0,\n        easing: Easing.out(Easing.quad),\n      },\n      loadMore: {\n        duration: 300,\n        delay: 50,\n        easing: Easing.out(Easing.ease),\n      },\n      errorRecovery: {\n        duration: 350,\n        delay: 200,\n        easing: Easing.out(Easing.exp),\n      },\n      contentReady: {\n        duration: 450,\n        delay: 0,\n        easing: Easing.out(Easing.cubic),\n      },\n      networkReconnect: {\n        duration: 600,\n        delay: 100,\n        easing: Easing.inOut(Easing.ease),\n      },\n    };\n\n    return configs[scenario];\n  }\n\n  static fadeIn(value: SharedValue<number>, config?: TransitionConfig, onComplete?: () => void): void {\n    const { duration, delay, easing } = {\n      ...this.getPresetConfig(\"fade\"),\n      ...config,\n    };\n\n    const animationId = `fade-${Date.now()}`;\n    this.startPerformanceTracking(animationId);\n\n    value.value = withDelay(\n      delay,\n      withTiming(1, { duration, easing }, (finished) => {\n        if (finished) {\n          this.endPerformanceTracking(animationId);\n          if (onComplete) runOnJS(onComplete)();\n        }\n      }),\n    );\n  }\n\n  static fadeOut(value: SharedValue<number>, config?: TransitionConfig, onComplete?: () => void): void {\n    const { duration, delay, easing } = {\n      ...this.getPresetConfig(\"fade\"),\n      ...config,\n    };\n\n    value.value = withDelay(\n      delay,\n      withTiming(0, { duration, easing }, (finished) => {\n        if (finished && onComplete) runOnJS(onComplete)();\n      }),\n    );\n  }\n\n  static slideIn(\n    value: SharedValue<number>,\n    from: number = 100,\n    config?: TransitionConfig,\n    onComplete?: () => void,\n  ): void {\n    const { duration, delay, easing } = {\n      ...this.getPresetConfig(\"slide\"),\n      ...config,\n    };\n\n    value.value = from;\n    value.value = withDelay(\n      delay,\n      withTiming(0, { duration, easing }, (finished) => {\n        if (finished && onComplete) runOnJS(onComplete)();\n      }),\n    );\n  }\n\n  static scaleIn(value: SharedValue<number>, config?: TransitionConfig, onComplete?: () => void): void {\n    const { duration, delay, springConfig } = {\n      ...this.getPresetConfig(\"scale\"),\n      ...config,\n    };\n\n    value.value = 0.8;\n    value.value = withDelay(\n      delay,\n      withSpring(1, springConfig, (finished) => {\n        if (finished && onComplete) runOnJS(onComplete)();\n      }),\n    );\n  }\n\n  static createStaggeredAnimation(\n    values: SharedValue<number>[],\n    targetValue: number,\n    config: StaggerConfig & TransitionConfig,\n  ): void {\n    const {\n      itemCount,\n      baseDelay = 0,\n      staggerDelay = 50,\n      reverse = false,\n      duration = 400,\n      easing = Easing.out(Easing.cubic),\n    } = config;\n\n    const items = reverse ? values.slice().reverse() : values;\n\n    items.forEach((value, index) => {\n      const delay = baseDelay + index * staggerDelay;\n      value.value = withDelay(delay, withTiming(targetValue, { duration, easing }));\n    });\n  }\n\n  static createSequentialAnimation(value: SharedValue<number>, sequence: number[], config?: TransitionConfig): void {\n    const { duration = 300, easing = Easing.linear } = config || {};\n\n    const animations = sequence.map((target) => withTiming(target, { duration: duration / sequence.length, easing }));\n\n    value.value = withSequence(...animations);\n  }\n\n  static createLoadingPulse(value: SharedValue<number>, config?: TransitionConfig): () => void {\n    const { duration = 1000 } = config || {};\n\n    value.value = withRepeat(\n      withSequence(withTiming(0.6, { duration: duration / 2 }), withTiming(0.3, { duration: duration / 2 })),\n      -1,\n      false,\n    );\n\n    return () => cancelAnimation(value);\n  }\n\n  static createShimmerEffect(\n    translateX: SharedValue<number>,\n    screenWidth: number,\n    config?: TransitionConfig,\n  ): () => void {\n    const { duration = 1500 } = config || {};\n\n    translateX.value = withRepeat(\n      withTiming(screenWidth * 2, {\n        duration,\n        easing: Easing.linear,\n      }),\n      -1,\n      false,\n    );\n\n    return () => cancelAnimation(translateX);\n  }\n\n  static createErrorShake(value: SharedValue<number>, config?: TransitionConfig, onComplete?: () => void): void {\n    const amplitude = 10;\n\n    value.value = withSequence(\n      withTiming(-amplitude, { duration: 50 }),\n      withTiming(amplitude, { duration: 100 }),\n      withTiming(-amplitude, { duration: 100 }),\n      withTiming(amplitude, { duration: 100 }),\n      withTiming(0, { duration: 50 }, (finished) => {\n        if (finished && onComplete) {\n          runOnJS(onComplete)();\n          runOnJS(() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium))();\n        }\n      }),\n    );\n  }\n\n  static createSuccessBounce(value: SharedValue<number>, config?: TransitionConfig, onComplete?: () => void): void {\n    const { springConfig } = {\n      ...this.getPresetConfig(\"success\"),\n      ...config,\n    };\n\n    value.value = 0.8;\n    value.value = withSpring(1, springConfig, (finished) => {\n      if (finished && onComplete) {\n        runOnJS(onComplete)();\n        runOnJS(() => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light))();\n      }\n    });\n  }\n\n  static cleanupAnimation(value: SharedValue<any>): void {\n    cancelAnimation(value);\n  }\n\n  static cleanupAllAnimations(): void {\n    this.activeAnimations.clear();\n    this.performanceMetrics.clear();\n  }\n\n  private static startPerformanceTracking(id: string): void {\n    if (__DEV__) {\n      this.activeAnimations.add(id);\n      this.performanceMetrics.set(id, {\n        startTime: Date.now(),\n        frameCount: 0,\n      });\n    }\n  }\n\n  private static endPerformanceTracking(id: string): void {\n    if (__DEV__) {\n      this.activeAnimations.delete(id);\n      const metrics = this.performanceMetrics.get(id);\n      if (metrics) {\n        metrics.endTime = Date.now();\n        const duration = metrics.endTime - metrics.startTime;\n        metrics.averageFPS = (metrics.frameCount / duration) * 1000;\n\n        if (metrics.averageFPS < 50) {\n          console.warn(`[LoadingTransitions] Low FPS detected: ${metrics.averageFPS.toFixed(2)} for animation ${id}`);\n        }\n      }\n    }\n  }\n\n  static getPerformanceMetrics(): Map<string, AnimationPerformance> {\n    return new Map(this.performanceMetrics);\n  }\n\n  static createOptimizedWorklet(animationFn: () => void): void {\n    \"worklet\";\n    animationFn();\n  }\n\n  static shouldUseReducedMotion(): boolean {\n    return this.reducedMotionEnabled;\n  }\n\n  static async triggerHapticForTransition(type: TransitionPreset): Promise<void> {\n    const hapticMap: Partial<Record<TransitionPreset, Haptics.ImpactFeedbackStyle>> = {\n      error: Haptics.ImpactFeedbackStyle.Medium,\n      success: Haptics.ImpactFeedbackStyle.Light,\n      bounce: Haptics.ImpactFeedbackStyle.Light,\n    };\n\n    const hapticStyle = hapticMap[type];\n    if (hapticStyle) {\n      await Haptics.impactAsync(hapticStyle);\n    }\n  }\n}\n\nexport function withSmartEasing(value: number, config: WithTimingConfig & { smart?: boolean }): number {\n  \"worklet\";\n\n  if (config.smart && LoadingTransitions.shouldUseReducedMotion()) {\n    return withTiming(value, {\n      ...config,\n      duration: Math.min(config.duration || 300, 200),\n      easing: Easing.linear,\n    });\n  }\n\n  return withTiming(value, config);\n}\n\nexport function createAnimatedStyleForTransition(\n  preset: TransitionPreset,\n  value: SharedValue<number>,\n): AnimatedStyle<any> {\n  \"worklet\";\n\n  const styles: Record<TransitionPreset, AnimatedStyle<any>> = {\n    fade: { opacity: value.value },\n    slide: { transform: [{ translateY: value.value }] },\n    scale: { transform: [{ scale: value.value }] },\n    fadeSlide: {\n      opacity: value.value,\n      transform: [{ translateY: (1 - value.value) * 20 }],\n    },\n    bounce: {\n      transform: [{ scale: value.value }],\n    },\n    smooth: {\n      opacity: value.value,\n    },\n    error: {\n      transform: [{ translateX: value.value }],\n    },\n    success: {\n      transform: [{ scale: value.value }],\n    },\n    loading: {\n      opacity: value.value,\n    },\n  };\n\n  return styles[preset] || styles.fade;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/lruCache.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_now' is assigned a value but never used.","line":227,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":227,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_now' is assigned a value but never used.","line":311,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":311,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Generic LRU (Least Recently Used) Cache implementation\n * Supports both memory and size-based eviction policies\n */\n\nexport interface CacheEntry<T> {\n  key: string;\n  value: T;\n  timestamp: number;\n  accessCount: number;\n  size?: number;\n  lastAccessTime?: number;\n  score?: number;\n  compressed?: boolean;\n  metadata?: Record<string, any>;\n}\n\nexport interface CacheOptions {\n  maxSize?: number; // Maximum number of entries\n  maxMemory?: number; // Maximum memory usage in bytes\n  ttl?: number; // Time to live in milliseconds\n  onEvict?: (key: string, value: any) => void | Promise<void>;\n  getSizeOf?: (value: any) => number;\n  enableCompression?: boolean;\n  enableStatistics?: boolean;\n  scoreFunction?: (entry: CacheEntry<any>) => number;\n  persistToDisk?: boolean;\n  warmupEntries?: string[];\n}\n\nexport class LRUCache<T> {\n  private cache = new Map<string, CacheEntry<T>>();\n  private accessOrder: string[] = [];\n  private currentMemoryUsage = 0;\n  private readonly options: Required<CacheOptions>;\n  private statistics = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    compressions: 0,\n    avgAccessTime: 0,\n    totalAccessTime: 0,\n    accessCount: 0,\n  };\n  private batchOperationQueue: Map<string, { operation: \"set\" | \"delete\"; value?: T }> = new Map();\n  private batchTimer?: ReturnType<typeof setTimeout>;\n  private cleanupScheduled = false;\n\n  constructor(options: CacheOptions = {}) {\n    this.options = {\n      maxSize: options.maxSize ?? 100,\n      maxMemory: options.maxMemory ?? 50 * 1024 * 1024, // 50MB default\n      ttl: options.ttl ?? 30 * 60 * 1000, // 30 minutes default\n      onEvict: options.onEvict ?? (() => {}),\n      getSizeOf:\n        options.getSizeOf ??\n        ((value: any) => {\n          if (typeof value === \"string\") return value.length * 2; // UTF-16\n          if (typeof value === \"object\") return JSON.stringify(value).length * 2;\n          return 64; // Default size for primitives\n        }),\n      enableCompression: options.enableCompression ?? false,\n      enableStatistics: options.enableStatistics ?? true,\n      scoreFunction: options.scoreFunction ?? this.defaultScoreFunction,\n      persistToDisk: options.persistToDisk ?? false,\n      warmupEntries: options.warmupEntries ?? [],\n    };\n\n    // Warm up cache with predefined entries\n    if (this.options.warmupEntries.length > 0) {\n      this.warmupCache();\n    }\n  }\n\n  /**\n   * Get a value from the cache\n   */\n  get(key: string): T | undefined {\n    const startTime = Date.now();\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      if (this.options.enableStatistics) {\n        this.statistics.misses++;\n      }\n      return undefined;\n    }\n\n    // Check if entry has expired\n    if (this.isExpired(entry)) {\n      this.delete(key);\n      if (this.options.enableStatistics) {\n        this.statistics.misses++;\n      }\n      return undefined;\n    }\n\n    // Update access information\n    const now = Date.now();\n    entry.timestamp = now;\n    entry.lastAccessTime = now;\n    entry.accessCount++;\n    entry.score = this.options.scoreFunction(entry);\n\n    // Move to end of access order (most recently used)\n    this.updateAccessOrder(key);\n\n    // Update statistics\n    if (this.options.enableStatistics) {\n      this.statistics.hits++;\n      const accessTime = Date.now() - startTime;\n      this.statistics.totalAccessTime += accessTime;\n      this.statistics.accessCount++;\n      this.statistics.avgAccessTime = this.statistics.totalAccessTime / this.statistics.accessCount;\n    }\n\n    return entry.value;\n  }\n\n  /**\n   * Set a value in the cache\n   */\n  set(key: string, value: T): void {\n    const existingEntry = this.cache.get(key);\n    let size = this.options.getSizeOf(value);\n    let compressedValue = value;\n\n    // Apply compression if enabled and beneficial\n    if (this.options.enableCompression && size > 1024) {\n      const compressed = this.compress(value);\n      if (compressed.size < size * 0.8) {\n        compressedValue = compressed.value as T;\n        size = compressed.size;\n        if (this.options.enableStatistics) {\n          this.statistics.compressions++;\n        }\n      }\n    }\n\n    // If updating existing entry, adjust memory usage\n    if (existingEntry) {\n      this.currentMemoryUsage -= existingEntry.size || 0;\n    }\n\n    // Check if we need to evict before adding new entry\n    const tempMemoryUsage = this.currentMemoryUsage + size;\n    if (tempMemoryUsage > this.options.maxMemory || this.cache.size >= this.options.maxSize) {\n      this.evictIfNecessary();\n    }\n\n    // Create new entry\n    const now = Date.now();\n    const entry: CacheEntry<T> = {\n      key,\n      value: compressedValue,\n      timestamp: now,\n      lastAccessTime: now,\n      accessCount: 1,\n      size,\n      compressed: compressedValue !== value,\n      score: 0,\n    };\n    entry.score = this.options.scoreFunction(entry);\n\n    // Update memory usage and add to cache\n    this.currentMemoryUsage += size;\n    this.cache.set(key, entry);\n    this.updateAccessOrder(key);\n  }\n\n  /**\n   * Delete a specific key from the cache\n   */\n  delete(key: string): boolean {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      return false;\n    }\n\n    // Update memory usage\n    this.currentMemoryUsage -= entry.size || 0;\n\n    // Remove from cache and access order\n    this.cache.delete(key);\n    this.removeFromAccessOrder(key);\n\n    // Call eviction callback\n    const evictResult = this.options.onEvict(key, entry.value);\n    if (evictResult instanceof Promise) {\n      evictResult.catch((err) => console.error(\"Eviction callback error:\", err));\n    }\n\n    if (this.options.enableStatistics) {\n      this.statistics.evictions++;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if a key exists in the cache\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    return entry !== undefined && !this.isExpired(entry);\n  }\n\n  /**\n   * Clear all entries from the cache\n   */\n  clear(): void {\n    // Call eviction callback for all entries\n    this.cache.forEach((entry, key) => {\n      this.options.onEvict(key, entry.value);\n    });\n\n    this.cache.clear();\n    this.accessOrder = [];\n    this.currentMemoryUsage = 0;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    const _now = Date.now();\n    let expiredCount = 0;\n\n    this.cache.forEach((entry) => {\n      if (this.isExpired(entry)) {\n        expiredCount++;\n      }\n    });\n\n    const hitRate =\n      this.statistics.hits + this.statistics.misses > 0\n        ? this.statistics.hits / (this.statistics.hits + this.statistics.misses)\n        : 0;\n\n    return {\n      size: this.cache.size,\n      memoryUsage: this.currentMemoryUsage,\n      maxSize: this.options.maxSize,\n      maxMemory: this.options.maxMemory,\n      expiredCount,\n      hitRate,\n      hits: this.statistics.hits,\n      misses: this.statistics.misses,\n      evictions: this.statistics.evictions,\n      compressions: this.statistics.compressions,\n      avgAccessTime: this.statistics.avgAccessTime,\n      memoryEfficiency: this.cache.size > 0 ? this.currentMemoryUsage / (this.cache.size * 1024) : 0,\n    };\n  }\n\n  /**\n   * Get all keys in the cache (excluding expired ones)\n   */\n  keys(): string[] {\n    const validKeys: string[] = [];\n\n    this.cache.forEach((entry, key) => {\n      if (!this.isExpired(entry)) {\n        validKeys.push(key);\n      }\n    });\n\n    return validKeys;\n  }\n\n  /**\n   * Get all values in the cache (excluding expired ones)\n   */\n  values(): T[] {\n    const validValues: T[] = [];\n\n    this.cache.forEach((entry) => {\n      if (!this.isExpired(entry)) {\n        validValues.push(entry.value);\n      }\n    });\n\n    return validValues;\n  }\n\n  /**\n   * Cleanup expired entries - now with lazy cleanup option\n   */\n  cleanup(): number {\n    if (this.cleanupScheduled) {\n      return 0; // Cleanup already scheduled\n    }\n\n    // Schedule lazy cleanup\n    if (this.cache.size < this.options.maxSize * 0.9) {\n      this.cleanupScheduled = true;\n      setImmediate(() => {\n        this.performCleanup();\n        this.cleanupScheduled = false;\n      });\n      return 0;\n    }\n\n    // Immediate cleanup for high usage\n    return this.performCleanup();\n  }\n\n  private performCleanup(): number {\n    let removedCount = 0;\n    const _now = Date.now();\n\n    const keysToDelete: string[] = [];\n    this.cache.forEach((entry, key) => {\n      if (this.isExpired(entry)) {\n        keysToDelete.push(key);\n      }\n    });\n\n    keysToDelete.forEach((key) => {\n      this.delete(key);\n      removedCount++;\n    });\n\n    return removedCount;\n  }\n\n  private isExpired(entry: CacheEntry<T>): boolean {\n    return Date.now() - entry.timestamp > this.options.ttl;\n  }\n\n  private updateAccessOrder(key: string): void {\n    // Remove from current position\n    this.removeFromAccessOrder(key);\n    // Add to end (most recently used)\n    this.accessOrder.push(key);\n  }\n\n  private removeFromAccessOrder(key: string): void {\n    const index = this.accessOrder.indexOf(key);\n    if (index > -1) {\n      this.accessOrder.splice(index, 1);\n    }\n  }\n\n  private evictIfNecessary(): void {\n    // Use intelligent eviction with scoring\n    const entries = Array.from(this.cache.entries());\n\n    // Sort by score (lower score = more likely to evict)\n    entries.sort((a, b) => {\n      const scoreA = a[1].score || this.options.scoreFunction(a[1]);\n      const scoreB = b[1].score || this.options.scoreFunction(b[1]);\n      return scoreA - scoreB;\n    });\n\n    // Evict by size limit\n    while (this.cache.size >= this.options.maxSize && entries.length > 0) {\n      const [key] = entries.shift()!;\n      this.delete(key);\n    }\n\n    // Evict by memory limit\n    while (this.currentMemoryUsage > this.options.maxMemory && entries.length > 0) {\n      const [key] = entries.shift()!;\n      this.delete(key);\n    }\n\n    // Clean up expired entries\n    this.cleanup();\n  }\n\n  private calculateHitRate(): number {\n    if (this.cache.size === 0) return 0;\n\n    let totalRequests = 0;\n    let cacheHits = 0;\n\n    this.cache.forEach((entry) => {\n      totalRequests += entry.accessCount;\n      // Every access after the first is a cache hit\n      if (entry.accessCount > 1) {\n        cacheHits += entry.accessCount - 1;\n      }\n    });\n\n    return totalRequests > 0 ? cacheHits / totalRequests : 0;\n  }\n\n  /**\n   * Batch operations for better performance\n   */\n  batchSet(entries: [string, T][]): void {\n    entries.forEach(([key, value]) => {\n      this.batchOperationQueue.set(key, { operation: \"set\", value });\n    });\n    this.processBatchOperations();\n  }\n\n  batchDelete(keys: string[]): void {\n    keys.forEach((key) => {\n      this.batchOperationQueue.set(key, { operation: \"delete\" });\n    });\n    this.processBatchOperations();\n  }\n\n  private processBatchOperations(): void {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n    }\n\n    this.batchTimer = setTimeout(() => {\n      this.batchOperationQueue.forEach(({ operation, value }, key) => {\n        if (operation === \"set\" && value !== undefined) {\n          this.set(key, value);\n        } else if (operation === \"delete\") {\n          this.delete(key);\n        }\n      });\n      this.batchOperationQueue.clear();\n    }, 10); // Process batch after 10ms\n  }\n\n  /**\n   * Warm up cache with predefined entries\n   */\n  async warmup(keys: string[], loadFunction: (key: string) => Promise<T>): Promise<void> {\n    const warmupPromises = keys.map(async (key) => {\n      try {\n        const value = await loadFunction(key);\n        this.set(key, value);\n      } catch (error) {\n        console.error(`Failed to warm up cache for key ${key}:`, error);\n      }\n    });\n\n    await Promise.allSettled(warmupPromises);\n  }\n\n  private warmupCache(): void {\n    // Implementation for initial warmup from options\n    console.log(\"Cache warmup initiated with\", this.options.warmupEntries.length, \"entries\");\n  }\n\n  /**\n   * Default scoring function for intelligent eviction\n   */\n  private defaultScoreFunction(entry: CacheEntry<any>): number {\n    const now = Date.now();\n    const age = now - entry.timestamp;\n    const recency = now - (entry.lastAccessTime || entry.timestamp);\n    const frequency = entry.accessCount;\n    const size = entry.size || 1;\n\n    // Higher score = keep in cache\n    // Consider frequency, recency, and size\n    const frequencyScore = Math.log(frequency + 1) * 100;\n    const recencyScore = Math.max(0, 1000 - recency / 1000);\n    const sizeScore = Math.max(0, 100 - size / 10000);\n    const ageScore = Math.max(0, 1000 - age / 10000);\n\n    return frequencyScore + recencyScore + sizeScore + ageScore;\n  }\n\n  /**\n   * Simple compression for text data\n   */\n  private compress(value: any): { value: any; size: number } {\n    // Compression disabled for React Native - Buffer not available\n    // In production, use a RN-compatible compression library\n    if (this.options.enableCompression && typeof value === \"string\" && value.length > 1024) {\n      // For now, just return the original value\n      // TODO: Integrate react-native-compression or similar\n      if (__DEV__) {\n        console.log(\"Compression requested but not available in React Native\");\n      }\n    }\n    return {\n      value,\n      size: this.options.getSizeOf(value),\n    };\n  }\n\n  /**\n   * Debug utilities\n   */\n  debug(): void {\n    if (__DEV__) {\n      console.log(\"Cache Debug Info:\");\n      console.log(\"- Size:\", this.cache.size, \"/\", this.options.maxSize);\n      console.log(\n        \"- Memory:\",\n        (this.currentMemoryUsage / 1024 / 1024).toFixed(2),\n        \"MB /\",\n        (this.options.maxMemory / 1024 / 1024).toFixed(2),\n        \"MB\",\n      );\n      console.log(\"- Statistics:\", this.statistics);\n      console.log(\"- Top 5 by score:\");\n\n      const entries = Array.from(this.cache.entries())\n        .map(([key, entry]) => ({ key, score: entry.score || 0 }))\n        .sort((a, b) => b.score - a.score)\n        .slice(0, 5);\n\n      entries.forEach(({ key, score }) => {\n        console.log(`  ${key}: ${score.toFixed(2)}`);\n      });\n    }\n  }\n}\n\n/**\n * Create a specialized cache for different data types\n */\nexport const createImageCache = (\n  maxMemory = 100 * 1024 * 1024, // 100MB\n) =>\n  new LRUCache<string>({\n    maxSize: 200,\n    maxMemory,\n    ttl: 60 * 60 * 1000, // 1 hour\n    getSizeOf: (uri: string) => {\n      // More accurate image size estimation\n      const baseSize = uri.length * 2; // URI string size\n      // Estimate typical image sizes based on URI patterns\n      if (uri.includes(\"thumb\") || uri.includes(\"small\")) {\n        return baseSize + 50 * 1024; // 50KB for thumbnails\n      }\n      if (uri.includes(\"large\") || uri.includes(\"full\")) {\n        return baseSize + 500 * 1024; // 500KB for large images\n      }\n      return baseSize + 200 * 1024; // 200KB default estimate\n    },\n  });\n\nexport const createDataCache = <T>(\n  maxSize = 100,\n  ttl = 15 * 60 * 1000, // 15 minutes\n) =>\n  new LRUCache<T>({\n    maxSize,\n    maxMemory: 10 * 1024 * 1024, // 10MB\n    ttl,\n  });\n\nexport const createVideoCache = (\n  maxMemory = 500 * 1024 * 1024, // 500MB\n) =>\n  new LRUCache<string>({\n    maxSize: 50,\n    maxMemory,\n    ttl: 2 * 60 * 60 * 1000, // 2 hours\n    getSizeOf: (uri: string) => {\n      // More accurate video size estimation based on URI patterns\n      const baseSize = uri.length * 2;\n      if (uri.includes(\"preview\") || uri.includes(\"thumb\")) {\n        return baseSize + 2 * 1024 * 1024; // 2MB for previews\n      }\n      if (uri.includes(\"720p\") || uri.includes(\"hd\")) {\n        return baseSize + 25 * 1024 * 1024; // 25MB for HD videos\n      }\n      if (uri.includes(\"1080p\") || uri.includes(\"fhd\")) {\n        return baseSize + 50 * 1024 * 1024; // 50MB for Full HD\n      }\n      return baseSize + 15 * 1024 * 1024; // 15MB default estimate\n    },\n  });\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/networkProfiler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":279,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":279,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":307,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":307,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import NetInfo, { NetInfoState, NetInfoSubscription } from \"@react-native-community/netinfo\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { healthMonitor } from \"./healthMonitor\";\n\nexport type ConnectionType = \"wifi\" | \"4g\" | \"5g\" | \"3g\" | \"2g\" | \"ethernet\" | \"unknown\";\nexport type NetworkQuality = \"excellent\" | \"good\" | \"fair\" | \"poor\";\n\nexport interface NetworkProfile {\n  bandwidth: number; // Mbps\n  latency: number; // ms\n  jitter: number; // ms\n  packetLoss: number; // percentage\n  connectionType: ConnectionType;\n  quality: NetworkQuality;\n  stability: number; // 0-1 score\n  timestamp: number;\n  isMetered: boolean;\n  signalStrength?: number;\n}\n\nexport interface NetworkPattern {\n  hour: number;\n  dayOfWeek: number;\n  averageBandwidth: number;\n  averageLatency: number;\n  quality: NetworkQuality;\n  samples: number;\n}\n\ninterface NetworkMeasurement {\n  bandwidth: number;\n  latency: number;\n  timestamp: number;\n  connectionType: ConnectionType;\n}\n\ninterface NetworkConditionOptions {\n  enableAdaptiveMeasurement?: boolean;\n  enablePatternLearning?: boolean;\n  enableDataUsageTracking?: boolean;\n  measurementInterval?: number;\n  historySize?: number;\n}\n\nclass NetworkProfiler {\n  private currentProfile: NetworkProfile | null = null;\n  private measurementHistory: NetworkMeasurement[] = [];\n  private networkPatterns: Map<string, NetworkPattern> = new Map();\n  private stabilityHistory: number[] = [];\n  private dataUsage = {\n    wifi: 0,\n    cellular: 0,\n    total: 0,\n    resetDate: Date.now(),\n  };\n  private networkSubscription: NetInfoSubscription | null = null;\n  private measurementInterval: NodeJS.Timeout | null = null;\n  private options: Required<NetworkConditionOptions>;\n  private readonly CACHE_KEY_PREFIX = \"network_profiler_\";\n  private readonly STABILITY_WINDOW = 10;\n  private readonly PATTERN_SAMPLE_THRESHOLD = 5;\n  private testUrls = [\n    \"https://www.gstatic.com/generate_204\",\n    \"https://api.github.com\",\n    \"https://www.cloudflare.com/cdn-cgi/trace\",\n  ];\n\n  constructor(options: NetworkConditionOptions = {}) {\n    this.options = {\n      enableAdaptiveMeasurement: options.enableAdaptiveMeasurement ?? true,\n      enablePatternLearning: options.enablePatternLearning ?? true,\n      enableDataUsageTracking: options.enableDataUsageTracking ?? true,\n      measurementInterval: options.measurementInterval ?? 30000, // 30 seconds\n      historySize: options.historySize ?? 100,\n    };\n\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load persisted data\n    await this.loadPersistedData();\n\n    // Start network monitoring\n    this.startNetworkMonitoring();\n\n    // Start periodic measurements\n    if (this.options.enableAdaptiveMeasurement) {\n      this.startAdaptiveMeasurement();\n    }\n\n    // Initial measurement\n    await this.measureNetworkCondition();\n  }\n\n  private async loadPersistedData(): Promise<void> {\n    try {\n      // Load network patterns\n      const patternsData = await AsyncStorage.getItem(`${this.CACHE_KEY_PREFIX}patterns`);\n      if (patternsData) {\n        const patterns = JSON.parse(patternsData);\n        this.networkPatterns = new Map(Object.entries(patterns));\n      }\n\n      // Load data usage\n      const dataUsageData = await AsyncStorage.getItem(`${this.CACHE_KEY_PREFIX}data_usage`);\n      if (dataUsageData) {\n        this.dataUsage = JSON.parse(dataUsageData);\n\n        // Reset monthly\n        const monthDiff = new Date().getMonth() - new Date(this.dataUsage.resetDate).getMonth();\n        if (monthDiff !== 0) {\n          this.resetDataUsage();\n        }\n      }\n\n      // Load last profile\n      const profileData = await AsyncStorage.getItem(`${this.CACHE_KEY_PREFIX}last_profile`);\n      if (profileData) {\n        this.currentProfile = JSON.parse(profileData);\n      }\n    } catch (error) {\n      console.error(\"Failed to load persisted network data:\", error);\n    }\n  }\n\n  private startNetworkMonitoring(): void {\n    this.networkSubscription = NetInfo.addEventListener((state) => {\n      this.handleNetworkChange(state);\n    });\n  }\n\n  private async handleNetworkChange(state: NetInfoState): Promise<void> {\n    const wasConnected = this.currentProfile !== null;\n    const isConnected = state.isConnected;\n\n    if (isConnected && !wasConnected) {\n      // Connection restored - measure immediately\n      await this.measureNetworkCondition();\n    } else if (!isConnected && wasConnected) {\n      // Connection lost\n      this.currentProfile = {\n        bandwidth: 0,\n        latency: Infinity,\n        jitter: Infinity,\n        packetLoss: 100,\n        connectionType: \"unknown\",\n        quality: \"poor\",\n        stability: 0,\n        timestamp: Date.now(),\n        isMetered: false,\n      };\n    }\n\n    // Update health monitor\n    healthMonitor.trackInteraction(\"network_status\", { connected: isConnected });\n  }\n\n  private startAdaptiveMeasurement(): void {\n    const performMeasurement = async () => {\n      const profile = await this.measureNetworkCondition();\n\n      if (profile) {\n        // Adjust measurement frequency based on stability\n        let nextInterval = this.options.measurementInterval;\n\n        if (profile.stability < 0.5) {\n          // Unstable network - measure more frequently\n          nextInterval = Math.max(10000, nextInterval / 2);\n        } else if (profile.stability > 0.9) {\n          // Very stable - measure less frequently\n          nextInterval = Math.min(60000, nextInterval * 1.5);\n        }\n\n        // Schedule next measurement\n        this.measurementInterval = setTimeout(performMeasurement, nextInterval);\n      }\n    };\n\n    performMeasurement();\n  }\n\n  public async measureNetworkCondition(): Promise<NetworkProfile | null> {\n    const netInfo = await NetInfo.fetch();\n\n    if (!netInfo.isConnected) {\n      return null;\n    }\n\n    const connectionType = this.detectConnectionType(netInfo);\n    const bandwidth = await this.measureBandwidth();\n    const latency = await this.measureLatency();\n    const jitter = this.calculateJitter();\n    const packetLoss = await this.estimatePacketLoss();\n    const stability = this.calculateStability(bandwidth);\n\n    const profile: NetworkProfile = {\n      bandwidth,\n      latency,\n      jitter,\n      packetLoss,\n      connectionType,\n      quality: this.classifyNetworkQuality(bandwidth, latency, stability),\n      stability,\n      timestamp: Date.now(),\n      isMetered: netInfo.details?.isConnectionExpensive ?? false,\n      signalStrength: this.getSignalStrength(netInfo),\n    };\n\n    // Update history\n    this.addMeasurement({\n      bandwidth,\n      latency,\n      timestamp: Date.now(),\n      connectionType,\n    });\n\n    // Learn patterns\n    if (this.options.enablePatternLearning) {\n      this.learnNetworkPattern(profile);\n    }\n\n    // Track data usage\n    if (this.options.enableDataUsageTracking) {\n      this.trackDataUsage(connectionType);\n    }\n\n    this.currentProfile = profile;\n    await this.persistProfile(profile);\n\n    return profile;\n  }\n\n  private detectConnectionType(netInfo: NetInfoState): ConnectionType {\n    const type = netInfo.type.toLowerCase();\n\n    if (type === \"wifi\") return \"wifi\";\n    if (type === \"ethernet\") return \"ethernet\";\n\n    if (type === \"cellular\") {\n      const cellularGeneration = (netInfo.details as any)?.cellularGeneration;\n\n      if (cellularGeneration) {\n        const gen = cellularGeneration.toLowerCase();\n        if (gen.includes(\"5g\")) return \"5g\";\n        if (gen.includes(\"4g\") || gen.includes(\"lte\")) return \"4g\";\n        if (gen.includes(\"3g\")) return \"3g\";\n        if (gen.includes(\"2g\")) return \"2g\";\n      }\n\n      return \"4g\"; // Default to 4G for cellular\n    }\n\n    return \"unknown\";\n  }\n\n  private async measureBandwidth(): Promise<number> {\n    const measurements: number[] = [];\n\n    for (const url of this.testUrls.slice(0, 2)) {\n      try {\n        const size = 1024; // Approximate response size in bytes\n        const startTime = Date.now();\n\n        const response = await fetch(url, {\n          method: \"GET\",\n          cache: \"no-cache\",\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Pragma: \"no-cache\",\n          },\n        });\n\n        if (response.ok) {\n          const duration = Date.now() - startTime;\n          const bandwidth = (size * 8) / (duration / 1000) / 1000000; // Mbps\n          measurements.push(bandwidth);\n        }\n      } catch (error) {\n        // Continue with other URLs\n      }\n    }\n\n    if (measurements.length === 0) {\n      return this.estimateBandwidthFromConnection();\n    }\n\n    // Return median\n    measurements.sort((a, b) => a - b);\n    return measurements[Math.floor(measurements.length / 2)];\n  }\n\n  private async measureLatency(): Promise<number> {\n    const measurements: number[] = [];\n\n    for (const url of this.testUrls) {\n      try {\n        const startTime = Date.now();\n\n        await fetch(url, {\n          method: \"HEAD\",\n          cache: \"no-cache\",\n        });\n\n        const latency = Date.now() - startTime;\n        measurements.push(latency);\n      } catch (error) {\n        // Continue with other URLs\n      }\n    }\n\n    if (measurements.length === 0) {\n      return 100; // Default latency\n    }\n\n    // Return minimum (best case)\n    return Math.min(...measurements);\n  }\n\n  private calculateJitter(): number {\n    if (this.measurementHistory.length < 2) return 0;\n\n    const recentLatencies = this.measurementHistory.slice(-10).map((m) => m.latency);\n\n    if (recentLatencies.length < 2) return 0;\n\n    let sumDifferences = 0;\n    for (let i = 1; i < recentLatencies.length; i++) {\n      sumDifferences += Math.abs(recentLatencies[i] - recentLatencies[i - 1]);\n    }\n\n    return sumDifferences / (recentLatencies.length - 1);\n  }\n\n  private async estimatePacketLoss(): Promise<number> {\n    // Simplified packet loss estimation\n    // In a real implementation, this would use ICMP or specialized protocols\n    let successCount = 0;\n    const attempts = 5;\n\n    for (let i = 0; i < attempts; i++) {\n      try {\n        const response = await fetch(this.testUrls[0], {\n          method: \"HEAD\",\n          signal: AbortSignal.timeout(1000),\n        });\n\n        if (response.ok) {\n          successCount++;\n        }\n      } catch {\n        // Counted as packet loss\n      }\n    }\n\n    return ((attempts - successCount) / attempts) * 100;\n  }\n\n  private calculateStability(currentBandwidth: number): number {\n    this.stabilityHistory.push(currentBandwidth);\n\n    if (this.stabilityHistory.length > this.STABILITY_WINDOW) {\n      this.stabilityHistory.shift();\n    }\n\n    if (this.stabilityHistory.length < 2) return 1;\n\n    // Calculate coefficient of variation\n    const mean = this.stabilityHistory.reduce((a, b) => a + b, 0) / this.stabilityHistory.length;\n    const variance =\n      this.stabilityHistory.reduce((sum, val) => {\n        return sum + Math.pow(val - mean, 2);\n      }, 0) / this.stabilityHistory.length;\n\n    const coefficientOfVariation = Math.sqrt(variance) / mean;\n\n    // Convert to 0-1 stability score (lower variation = higher stability)\n    return Math.max(0, Math.min(1, 1 - coefficientOfVariation));\n  }\n\n  private classifyNetworkQuality(bandwidth: number, latency: number, stability: number): NetworkQuality {\n    // Weighted scoring\n    const bandwidthScore = Math.min(1, bandwidth / 20); // 20 Mbps = perfect\n    const latencyScore = Math.max(0, 1 - latency / 200); // 0ms = perfect, 200ms+ = 0\n    const stabilityScore = stability;\n\n    const totalScore = bandwidthScore * 0.4 + latencyScore * 0.3 + stabilityScore * 0.3;\n\n    if (totalScore >= 0.8) return \"excellent\";\n    if (totalScore >= 0.6) return \"good\";\n    if (totalScore >= 0.4) return \"fair\";\n    return \"poor\";\n  }\n\n  private getSignalStrength(netInfo: NetInfoState): number | undefined {\n    // This would need platform-specific implementation\n    // For now, return undefined\n    return undefined;\n  }\n\n  private addMeasurement(measurement: NetworkMeasurement): void {\n    this.measurementHistory.push(measurement);\n\n    // Keep history size limited\n    if (this.measurementHistory.length > this.options.historySize) {\n      this.measurementHistory.shift();\n    }\n  }\n\n  private learnNetworkPattern(profile: NetworkProfile): void {\n    const now = new Date();\n    const hour = now.getHours();\n    const dayOfWeek = now.getDay();\n    const key = `${dayOfWeek}_${hour}`;\n\n    const existing = this.networkPatterns.get(key);\n\n    if (existing) {\n      // Update existing pattern\n      const samples = existing.samples + 1;\n      const avgBandwidth = (existing.averageBandwidth * existing.samples + profile.bandwidth) / samples;\n      const avgLatency = (existing.averageLatency * existing.samples + profile.latency) / samples;\n\n      this.networkPatterns.set(key, {\n        hour,\n        dayOfWeek,\n        averageBandwidth: avgBandwidth,\n        averageLatency: avgLatency,\n        quality: this.classifyNetworkQuality(avgBandwidth, avgLatency, profile.stability),\n        samples,\n      });\n    } else {\n      // Create new pattern\n      this.networkPatterns.set(key, {\n        hour,\n        dayOfWeek,\n        averageBandwidth: profile.bandwidth,\n        averageLatency: profile.latency,\n        quality: profile.quality,\n        samples: 1,\n      });\n    }\n\n    // Persist patterns periodically\n    if (Math.random() < 0.1) {\n      this.persistPatterns();\n    }\n  }\n\n  private trackDataUsage(connectionType: ConnectionType): void {\n    const estimatedBytes = 1024; // Rough estimate per measurement\n\n    if (connectionType === \"wifi\") {\n      this.dataUsage.wifi += estimatedBytes;\n    } else if ([\"4g\", \"5g\", \"3g\", \"2g\"].includes(connectionType)) {\n      this.dataUsage.cellular += estimatedBytes;\n    }\n\n    this.dataUsage.total += estimatedBytes;\n\n    // Persist periodically\n    if (Math.random() < 0.1) {\n      this.persistDataUsage();\n    }\n  }\n\n  private resetDataUsage(): void {\n    this.dataUsage = {\n      wifi: 0,\n      cellular: 0,\n      total: 0,\n      resetDate: Date.now(),\n    };\n    this.persistDataUsage();\n  }\n\n  private async estimateBandwidthFromConnection(): Promise<number> {\n    const netInfo = await NetInfo.fetch();\n    const connectionType = this.detectConnectionType(netInfo);\n\n    const bandwidthMap: Record<ConnectionType, number> = {\n      \"5g\": 20,\n      \"4g\": 10,\n      \"3g\": 2,\n      \"2g\": 0.1,\n      wifi: 15,\n      ethernet: 100,\n      unknown: 5,\n    };\n\n    return bandwidthMap[connectionType];\n  }\n\n  private async persistProfile(profile: NetworkProfile): Promise<void> {\n    try {\n      await AsyncStorage.setItem(`${this.CACHE_KEY_PREFIX}last_profile`, JSON.stringify(profile));\n    } catch (error) {\n      console.error(\"Failed to persist network profile:\", error);\n    }\n  }\n\n  private async persistPatterns(): Promise<void> {\n    try {\n      const patterns = Object.fromEntries(this.networkPatterns);\n      await AsyncStorage.setItem(`${this.CACHE_KEY_PREFIX}patterns`, JSON.stringify(patterns));\n    } catch (error) {\n      console.error(\"Failed to persist network patterns:\", error);\n    }\n  }\n\n  private async persistDataUsage(): Promise<void> {\n    try {\n      await AsyncStorage.setItem(`${this.CACHE_KEY_PREFIX}data_usage`, JSON.stringify(this.dataUsage));\n    } catch (error) {\n      console.error(\"Failed to persist data usage:\", error);\n    }\n  }\n\n  public getCurrentProfile(): NetworkProfile | null {\n    return this.currentProfile;\n  }\n\n  public getPredictedQuality(): NetworkQuality | null {\n    const now = new Date();\n    const hour = now.getHours();\n    const dayOfWeek = now.getDay();\n    const key = `${dayOfWeek}_${hour}`;\n\n    const pattern = this.networkPatterns.get(key);\n\n    if (pattern && pattern.samples >= this.PATTERN_SAMPLE_THRESHOLD) {\n      return pattern.quality;\n    }\n\n    return this.currentProfile?.quality ?? null;\n  }\n\n  public getDataUsage(): typeof this.dataUsage {\n    return { ...this.dataUsage };\n  }\n\n  public shouldReduceDataUsage(): boolean {\n    if (!this.currentProfile) return false;\n\n    // Reduce data usage on metered connections or poor quality\n    return this.currentProfile.isMetered || this.currentProfile.quality === \"poor\";\n  }\n\n  public async testConnectivity(url?: string): Promise<boolean> {\n    try {\n      const testUrl = url || this.testUrls[0];\n      const response = await fetch(testUrl, {\n        method: \"HEAD\",\n        signal: AbortSignal.timeout(5000),\n      });\n\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  public destroy(): void {\n    if (this.networkSubscription) {\n      this.networkSubscription();\n      this.networkSubscription = null;\n    }\n\n    if (this.measurementInterval) {\n      clearTimeout(this.measurementInterval);\n      this.measurementInterval = null;\n    }\n\n    // Persist final state\n    this.persistPatterns();\n    this.persistDataUsage();\n  }\n}\n\nexport const networkProfiler = new NetworkProfiler();\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/offlineActionProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/offlineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/onboardingHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/progressiveEnhancement.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Constants' is defined but never used.","line":9,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":17},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":70,"column":21,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":70,"endColumn":78},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":71,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":71,"endColumn":77},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":72,"column":25,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":72,"endColumn":77},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":73,"column":27,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":73,"endColumn":81},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":74,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":74,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":79,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":17},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":81,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":81,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Progressive Enhancement System\n *\n * This utility provides capability detection and graceful degradation\n * for features that require native modules or advanced hardware.\n */\n\nimport React, { useState, useEffect, useCallback } from \"react\";\nimport Constants from \"expo-constants\";\nimport { IS_EXPO_GO } from \"./environmentCheck\";\nimport { Platform } from \"react-native\";\nimport Device from \"expo-device\";\n\n// Define capability interfaces\nexport interface DeviceCapabilities {\n  hasVisionAPI: boolean;\n  hasAudioProcessing: boolean;\n  hasSpeechRecognition: boolean;\n  hasGPUAcceleration: boolean;\n  hasHighPerformanceCPU: boolean;\n  hasAdvancedCamera: boolean;\n  hasVideoProcessing: boolean;\n  hasFaceDetection: boolean;\n  hasVoiceModulation: boolean;\n  platform: string;\n  deviceType: string;\n}\n\nexport interface FeatureFallbacks {\n  faceBlur: () => React.ComponentType<any>;\n  voiceChange: () => React.ComponentType<any>;\n  liveCaptions: () => React.ComponentType<any>;\n  advancedCamera: () => React.ComponentType<any>;\n  videoEditor: () => React.ComponentType<any>;\n}\n\n/**\n * Detect device capabilities for progressive enhancement\n */\nexport const detectCapabilities = async (): Promise<DeviceCapabilities> => {\n  const deviceType = await Device.getDeviceTypeAsync();\n  const platform = Platform.OS;\n\n  const capabilities: DeviceCapabilities = {\n    hasVisionAPI: !IS_EXPO_GO,\n    hasAudioProcessing: !IS_EXPO_GO,\n    hasSpeechRecognition: !IS_EXPO_GO,\n    hasGPUAcceleration: !IS_EXPO_GO,\n    hasHighPerformanceCPU: deviceType === Device.DeviceType.TABLET || deviceType === Device.DeviceType.DESKTOP,\n    hasAdvancedCamera: !IS_EXPO_GO,\n    hasVideoProcessing: !IS_EXPO_GO,\n    hasFaceDetection: !IS_EXPO_GO,\n    hasVoiceModulation: !IS_EXPO_GO,\n    platform,\n    deviceType: Device.DeviceType[deviceType] || \"UNKNOWN\",\n  };\n\n  if (__DEV__) {\n    console.log(\"🔍 Device Capabilities Detected:\", capabilities);\n  }\n\n  return capabilities;\n};\n\n/**\n * Get fallback UI components for unsupported features\n */\nexport const getFallbackUI = (feature: keyof FeatureFallbacks): React.ComponentType<any> => {\n  const fallbacks: FeatureFallbacks = {\n    faceBlur: () => require(\"../components/fallbacks/ServerProcessingNotice\").default,\n    voiceChange: () => require(\"../components/fallbacks/BasicAudioControls\").default,\n    liveCaptions: () => require(\"../components/fallbacks/TextInputFallback\").default,\n    advancedCamera: () => require(\"../components/fallbacks/BasicCameraControls\").default,\n    videoEditor: () => require(\"../components/fallbacks/SimpleVideoEditor\").default,\n  };\n\n  try {\n    return fallbacks[feature]();\n  } catch (error) {\n    console.warn(`Fallback component for ${feature} not found, using default`);\n    return require(\"../components/fallbacks/FeatureUnavailableNotice\").default;\n  }\n};\n\n/**\n * Hook for using progressive enhancement in components\n */\nexport const useProgressiveEnhancement = () => {\n  const [capabilities, setCapabilities] = useState<DeviceCapabilities | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    detectCapabilities().then((caps) => {\n      setCapabilities(caps);\n      setLoading(false);\n    });\n  }, []);\n\n  const getComponent = useCallback(\n    <T extends React.ComponentType<any>>(\n      advancedComponent: T,\n      feature: keyof FeatureFallbacks,\n    ): T | React.ComponentType<any> => {\n      if (loading || !capabilities) {\n        return getFallbackUI(feature);\n      }\n\n      // Map features to capabilities\n      const featureCapabilityMap: Record<\n        keyof FeatureFallbacks,\n        keyof Pick<\n          DeviceCapabilities,\n          | \"hasFaceDetection\"\n          | \"hasVoiceModulation\"\n          | \"hasSpeechRecognition\"\n          | \"hasAdvancedCamera\"\n          | \"hasVideoProcessing\"\n        >\n      > = {\n        faceBlur: \"hasFaceDetection\",\n        voiceChange: \"hasVoiceModulation\",\n        liveCaptions: \"hasSpeechRecognition\",\n        advancedCamera: \"hasAdvancedCamera\",\n        videoEditor: \"hasVideoProcessing\",\n      };\n\n      const requiredCapability = featureCapabilityMap[feature];\n      const booleanCapabilities = capabilities as Pick<\n        DeviceCapabilities,\n        \"hasFaceDetection\" | \"hasVoiceModulation\" | \"hasSpeechRecognition\" | \"hasAdvancedCamera\" | \"hasVideoProcessing\"\n      >;\n      return booleanCapabilities[requiredCapability] ? advancedComponent : getFallbackUI(feature);\n    },\n    [capabilities, loading],\n  );\n\n  return {\n    capabilities,\n    loading,\n    getComponent,\n    isFeatureAvailable: (feature: keyof DeviceCapabilities) => capabilities?.[feature] ?? false,\n  };\n};\n\n// Singleton instance for global access\nlet globalCapabilities: DeviceCapabilities | null = null;\n\nexport const getGlobalCapabilities = async (): Promise<DeviceCapabilities> => {\n  if (!globalCapabilities) {\n    globalCapabilities = await detectCapabilities();\n  }\n  return globalCapabilities;\n};\n\nexport const isFeatureGloballyAvailable = (feature: keyof DeviceCapabilities): boolean => {\n  const value = globalCapabilities?.[feature];\n  return typeof value === \"boolean\" ? value : false;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/pushNotifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/refreshErrorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/retryLogic.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_startTime' is assigned a value but never used.","line":126,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":126,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Retry logic utilities with exponential backoff\n * Provides robust error handling for transient network errors\n */\n\nimport { isRetryableSupabaseError } from \"../types/supabaseError\";\n// Global retry event subscription for lightweight UX signals\nexport type RetryEventSource = \"supabase\" | \"api\" | \"unknown\";\nexport interface RetryEvent {\n  source: RetryEventSource;\n  attempt: number;\n  delay: number;\n  error: unknown;\n}\n\nconst retryListeners = new Set<(e: RetryEvent) => void>();\nexport const subscribeRetryEvents = (listener: (e: RetryEvent) => void) => {\n  retryListeners.add(listener);\n  return () => retryListeners.delete(listener);\n};\nconst emitRetryEvent = (event: RetryEvent) => {\n  retryListeners.forEach((l) => {\n    try {\n      l(event);\n    } catch {\n      // ignore listener errors\n    }\n  });\n};\n\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxAttempts?: number;\n  /** Initial delay in milliseconds (default: 1000) */\n  initialDelay?: number;\n  /** Maximum delay in milliseconds (default: 10000) */\n  maxDelay?: number;\n  /** Backoff multiplier (default: 2) */\n  backoffMultiplier?: number;\n  /** Jitter factor to add randomness (default: 0.1) */\n  jitterFactor?: number;\n  /** Function to determine if error should trigger retry */\n  shouldRetry?: (error: unknown, attempt: number) => boolean;\n  /** Callback for retry attempts */\n  onRetry?: (error: unknown, attempt: number, delay: number) => void;\n}\n\nexport interface RetryResult<T> {\n  success: boolean;\n  data?: T;\n  error?: unknown;\n  attempts: number;\n  totalTime: number;\n}\n\n/**\n * Default retry condition - retries on network errors and 5xx status codes\n */\nconst defaultShouldRetry = (error: unknown, attempt: number): boolean => {\n  if (attempt >= 3) return false;\n\n  // Use Supabase error checking first\n  if (isRetryableSupabaseError(error)) {\n    return true;\n  }\n\n  // Retry on network errors\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    if (\n      message.includes(\"network\") ||\n      message.includes(\"fetch\") ||\n      message.includes(\"timeout\") ||\n      message.includes(\"connection\")\n    ) {\n      return true;\n    }\n  }\n\n  // Retry on HTTP 5xx errors\n  if (typeof error === \"object\" && error !== null && \"status\" in error) {\n    const status = (error as any).status;\n    return status >= 500 && status < 600;\n  }\n\n  return false;\n};\n\n/**\n * Calculate delay with exponential backoff and jitter\n */\nconst calculateDelay = (\n  attempt: number,\n  initialDelay: number,\n  maxDelay: number,\n  backoffMultiplier: number,\n  jitterFactor: number,\n): number => {\n  const exponentialDelay = initialDelay * Math.pow(backoffMultiplier, attempt - 1);\n  const cappedDelay = Math.min(exponentialDelay, maxDelay);\n\n  // Add jitter to prevent thundering herd\n  const jitter = cappedDelay * jitterFactor * Math.random();\n  return Math.floor(cappedDelay + jitter);\n};\n\n/**\n * Sleep utility for delays\n */\nconst sleep = (ms: number): Promise<void> => new Promise((resolve) => setTimeout(resolve, ms));\n\n/**\n * Retry an async operation with exponential backoff\n */\nexport const withRetry = async <T>(operation: () => Promise<T>, options: RetryOptions = {}): Promise<T> => {\n  const {\n    maxAttempts = 3,\n    initialDelay = 1000,\n    maxDelay = 10000,\n    backoffMultiplier = 2,\n    jitterFactor = 0.1,\n    shouldRetry = defaultShouldRetry,\n    onRetry,\n  } = options;\n\n  const _startTime = Date.now();\n  let lastError: unknown;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      const result = await operation();\n      return result;\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry on last attempt or if shouldn't retry\n      if (attempt === maxAttempts || !shouldRetry(error, attempt)) {\n        break;\n      }\n\n      const delay = calculateDelay(attempt, initialDelay, maxDelay, backoffMultiplier, jitterFactor);\n\n      if (__DEV__) {\n        console.warn(`[Retry] Attempt ${attempt}/${maxAttempts} failed, retrying in ${delay}ms:`, error);\n      }\n\n      onRetry?.(error, attempt, delay);\n      await sleep(delay);\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Retry with detailed result information\n */\nexport const withRetryResult = async <T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {},\n): Promise<RetryResult<T>> => {\n  const startTime = Date.now();\n  let attempts = 0;\n\n  try {\n    const data = await withRetry(async () => {\n      attempts++;\n      return await operation();\n    }, options);\n\n    return {\n      success: true,\n      data,\n      attempts,\n      totalTime: Date.now() - startTime,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error,\n      attempts,\n      totalTime: Date.now() - startTime,\n    };\n  }\n};\n\n/**\n * Create a retry wrapper for Supabase operations\n */\nexport const createSupabaseRetry = (options: RetryOptions = {}) => {\n  const onRetryCombined = (error: unknown, attempt: number, delay: number) => {\n    emitRetryEvent({ source: \"supabase\", attempt, delay, error });\n    options.onRetry?.(error, attempt, delay);\n  };\n\n  const supabaseOptions: RetryOptions = {\n    maxAttempts: 3,\n    initialDelay: 1000,\n    maxDelay: 8000,\n    shouldRetry: (error, attempt) => {\n      // Custom Supabase retry logic\n      if (attempt >= 3) return false;\n\n      if (typeof error === \"object\" && error !== null) {\n        const errorObj = error as any;\n\n        // Retry on connection errors\n        if (\n          errorObj.message?.includes(\"Failed to fetch\") ||\n          errorObj.message?.includes(\"NetworkError\") ||\n          errorObj.message?.includes(\"timeout\")\n        ) {\n          return true;\n        }\n\n        // Retry on specific Supabase error codes\n        if (errorObj.code && [\"PGRST301\", \"PGRST302\", \"08000\", \"08003\", \"08006\"].includes(errorObj.code)) {\n          return true;\n        }\n\n        // Retry on 5xx HTTP errors\n        if (errorObj.status >= 500 && errorObj.status < 600) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    onRetry: onRetryCombined,\n    ...options,\n  };\n\n  return <T>(operation: () => Promise<T>) => withRetry(operation, supabaseOptions);\n};\n\n/**\n * Create a retry wrapper for API calls\n */\nexport const createApiRetry = (options: RetryOptions = {}) => {\n  const onRetryCombined = (error: unknown, attempt: number, delay: number) => {\n    emitRetryEvent({ source: \"api\", attempt, delay, error });\n    options.onRetry?.(error, attempt, delay);\n  };\n\n  const apiOptions: RetryOptions = {\n    maxAttempts: 3,\n    initialDelay: 500,\n    maxDelay: 5000,\n    shouldRetry: (error, attempt) => {\n      if (attempt >= 3) return false;\n\n      // Retry on network errors\n      if (error instanceof Error) {\n        const message = error.message.toLowerCase();\n        if (message.includes(\"network\") || message.includes(\"fetch\") || message.includes(\"timeout\")) {\n          return true;\n        }\n      }\n\n      // Retry on 5xx and some 4xx errors\n      if (typeof error === \"object\" && error !== null && \"status\" in error) {\n        const status = (error as any).status;\n        return status >= 500 || status === 408 || status === 429;\n      }\n\n      return false;\n    },\n    onRetry: onRetryCombined,\n    ...options,\n  };\n\n  return <T>(operation: () => Promise<T>) => withRetry(operation, apiOptions);\n};\n\n// Additional exports for video retry functionality\nexport interface RetryConfig {\n  maxAttempts?: number;\n  maxRetries?: number;\n  backoffMs?: number[];\n  initialDelay?: number;\n  maxDelay?: number;\n  backoffFactor?: number;\n  shouldRetry?: (error: unknown, attempt: number) => boolean;\n  onRetry?: (attempt: number, delay: number) => void;\n}\n\nexport function createRetryableOperation<T>(operation: () => Promise<T>, config: RetryConfig): Promise<T> {\n  const attempts = config.maxAttempts ?? config.maxRetries ?? config.backoffMs?.length ?? 3;\n  const delays = config.backoffMs ?? [];\n  const initialDelay = config.initialDelay ?? delays[0] ?? 1000;\n  const maxDelay = config.maxDelay ?? delays[delays.length - 1] ?? Math.max(initialDelay * 4, initialDelay);\n  const backoffMultiplier = config.backoffFactor ?? 2;\n\n  return withRetry(operation, {\n    maxAttempts: attempts,\n    initialDelay,\n    maxDelay,\n    backoffMultiplier,\n    shouldRetry: config.shouldRetry,\n    onRetry: (error, attempt, delay) => config.onRetry?.(attempt, delay),\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/reviewPrompt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/runReportsMigration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is assigned a value but never used.","line":37,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase } from \"../lib/supabase\";\n\n/**\n * Run the reports table migration directly from the app\n * This function can be called from your app to create the reports table\n */\nexport async function runReportsMigration(): Promise<boolean> {\n  if (__DEV__) {\n    console.warn(\n      \"[runReportsMigration] Client-side migrations are disabled. Please run SQL migrations via Supabase migrations or the Dashboard.\",\n    );\n  }\n  return false;\n}\n\n/**\n * Alternative migration approach using direct SQL execution\n * Use this if the exec_sql RPC function is not available\n */\nexport async function runReportsMigrationDirect(): Promise<boolean> {\n  if (__DEV__) {\n    console.warn(\n      \"[runReportsMigrationDirect] Disabled. Use server-side migrations instead (SQL files / Supabase Dashboard).\",\n    );\n  }\n  return false;\n}\n\n/**\n * Test the reports table setup\n */\nexport async function testReportsTable(): Promise<boolean> {\n  console.log(\"🧪 Testing reports table...\");\n\n  try {\n    // Test if we can query the reports table\n    const { data, error } = await supabase.from(\"reports\").select(\"id\").limit(1);\n\n    if (error) {\n      console.error(\"❌ Reports table test failed:\", error);\n      return false;\n    }\n\n    console.log(\"✅ Reports table is accessible!\");\n    return true;\n  } catch (error) {\n    console.error(\"❌ Reports table test error:\", error);\n    return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/screenErrorMessages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/screenValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/storeCleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/storePerformanceMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/storeTestingFramework.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/supabaseWithRetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/testDatabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/testReportSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/testTikTokVideoFeed.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":59,"column":25,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":59,"endColumn":46},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":68,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":68,"endColumn":69},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":77,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":77,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mockTapEvent' is assigned a value but never used.","line":105,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { VideoDataService } from \"../services/VideoDataService\";\nimport type { Confession } from \"../types/confession\";\n\n/**\n * Test utilities for the TikTok-style video feed\n * Validates functionality and performance\n */\nexport class TikTokVideoFeedTester {\n  /**\n   * Test video data loading\n   */\n  static async testVideoDataLoading(): Promise<boolean> {\n    try {\n      console.log(\"🧪 Testing video data loading...\");\n\n      // Test regular video loading\n      const regularVideos = await VideoDataService.fetchVideoConfessions(10);\n      console.log(`✅ Loaded ${regularVideos.length} regular videos`);\n\n      // Test trending video loading\n      const trendingVideos = await VideoDataService.fetchTrendingVideos(24, 5);\n      console.log(`✅ Loaded ${trendingVideos.length} trending videos`);\n\n      // Validate video structure\n      const isValidVideo = (video: Confession): boolean => {\n        return !!(\n          video.id &&\n          video.type === \"video\" &&\n          video.videoUri &&\n          typeof video.likes === \"number\" &&\n          typeof video.views === \"number\" &&\n          typeof video.timestamp === \"number\"\n        );\n      };\n\n      const allVideosValid = [...regularVideos, ...trendingVideos].every(isValidVideo);\n\n      if (allVideosValid) {\n        console.log(\"✅ All videos have valid structure\");\n        return true;\n      } else {\n        console.error(\"❌ Some videos have invalid structure\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"❌ Video data loading test failed:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Test video player functionality\n   */\n  static testVideoPlayerFunctionality(): boolean {\n    try {\n      console.log(\"🧪 Testing video player functionality...\");\n\n      // Check if expo-video is available\n      const expoVideo = require(\"expo-video\");\n      if (!expoVideo.VideoView || !expoVideo.useVideoPlayer) {\n        console.error(\"❌ expo-video components not available\");\n        return false;\n      }\n\n      console.log(\"✅ expo-video components available\");\n\n      // Check if gesture handler is available\n      const gestureHandler = require(\"react-native-gesture-handler\");\n      if (!gestureHandler.Gesture || !gestureHandler.GestureDetector) {\n        console.error(\"❌ react-native-gesture-handler not available\");\n        return false;\n      }\n\n      console.log(\"✅ react-native-gesture-handler available\");\n\n      // Check if reanimated is available\n      const reanimated = require(\"react-native-reanimated\");\n      if (!reanimated.useSharedValue || !reanimated.useAnimatedStyle) {\n        console.error(\"❌ react-native-reanimated not available\");\n        return false;\n      }\n\n      console.log(\"✅ react-native-reanimated available\");\n\n      return true;\n    } catch (error) {\n      console.error(\"❌ Video player functionality test failed:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Test gesture handling\n   */\n  static testGestureHandling(): boolean {\n    try {\n      console.log(\"🧪 Testing gesture handling...\");\n\n      // Mock gesture events\n      const mockPanEvent = {\n        translationY: -100,\n        velocityY: -800,\n      };\n\n      const mockTapEvent = {\n        x: 200,\n        y: 400,\n      };\n\n      // Test swipe threshold logic\n      const SWIPE_THRESHOLD = 50;\n      const SWIPE_VELOCITY_THRESHOLD = 500;\n\n      const shouldSwipe =\n        Math.abs(mockPanEvent.translationY) > SWIPE_THRESHOLD ||\n        Math.abs(mockPanEvent.velocityY) > SWIPE_VELOCITY_THRESHOLD;\n\n      if (!shouldSwipe) {\n        console.error(\"❌ Swipe detection logic failed\");\n        return false;\n      }\n\n      console.log(\"✅ Swipe detection logic working\");\n\n      // Test navigation logic\n      const currentIndex = 2;\n      const totalVideos = 5;\n\n      let newIndex = currentIndex;\n      if (mockPanEvent.translationY < 0 && currentIndex < totalVideos - 1) {\n        newIndex = currentIndex + 1; // Swipe up - next video\n      }\n\n      if (newIndex !== 3) {\n        console.error(\"❌ Navigation logic failed\");\n        return false;\n      }\n\n      console.log(\"✅ Navigation logic working\");\n\n      return true;\n    } catch (error) {\n      console.error(\"❌ Gesture handling test failed:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Test database integration\n   */\n  static async testDatabaseIntegration(): Promise<boolean> {\n    try {\n      console.log(\"🧪 Testing database integration...\");\n\n      // Test video likes update\n      const testVideoId = \"test-video-id\";\n      const likeResult = await VideoDataService.updateVideoLikes(testVideoId, true);\n\n      if (typeof likeResult !== \"boolean\") {\n        console.error(\"❌ Video likes update returned invalid type\");\n        return false;\n      }\n\n      console.log(\"✅ Video likes update function working\");\n\n      // Test video views update\n      const viewResult = await VideoDataService.updateVideoViews(testVideoId);\n\n      if (typeof viewResult !== \"boolean\") {\n        console.error(\"❌ Video views update returned invalid type\");\n        return false;\n      }\n\n      console.log(\"✅ Video views update function working\");\n\n      return true;\n    } catch (error) {\n      console.error(\"❌ Database integration test failed:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Test performance metrics\n   */\n  static testPerformanceMetrics(): boolean {\n    try {\n      console.log(\"🧪 Testing performance metrics...\");\n\n      // Test memory usage simulation\n      const mockVideoCount = 100;\n      const estimatedMemoryPerVideo = 50; // MB\n      const totalEstimatedMemory = mockVideoCount * estimatedMemoryPerVideo;\n\n      if (totalEstimatedMemory > 1000) {\n        // 1GB limit\n        console.warn(\"⚠️ High memory usage estimated for large video counts\");\n      }\n\n      // Test render performance simulation\n      const mockRenderTime = 16; // 16ms for 60fps\n      const targetFPS = 60;\n      const maxRenderTime = 1000 / targetFPS;\n\n      if (mockRenderTime <= maxRenderTime) {\n        console.log(\"✅ Render performance within target\");\n      } else {\n        console.warn(\"⚠️ Render performance may be below target\");\n      }\n\n      // Test gesture response time\n      const mockGestureResponseTime = 50; // 50ms\n      const maxGestureResponseTime = 100; // 100ms for good UX\n\n      if (mockGestureResponseTime <= maxGestureResponseTime) {\n        console.log(\"✅ Gesture response time within target\");\n      } else {\n        console.warn(\"⚠️ Gesture response time may be too slow\");\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\"❌ Performance metrics test failed:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Run all tests\n   */\n  static async runAllTests(): Promise<boolean> {\n    console.log(\"🚀 Starting TikTok Video Feed Tests...\\n\");\n\n    const tests = [\n      { name: \"Video Data Loading\", test: () => this.testVideoDataLoading() },\n      { name: \"Video Player Functionality\", test: () => this.testVideoPlayerFunctionality() },\n      { name: \"Gesture Handling\", test: () => this.testGestureHandling() },\n      { name: \"Database Integration\", test: () => this.testDatabaseIntegration() },\n      { name: \"Performance Metrics\", test: () => this.testPerformanceMetrics() },\n    ];\n\n    let passedTests = 0;\n\n    for (const { name, test } of tests) {\n      try {\n        const result = await test();\n        if (result) {\n          passedTests++;\n          console.log(`✅ ${name} - PASSED\\n`);\n        } else {\n          console.log(`❌ ${name} - FAILED\\n`);\n        }\n      } catch (error) {\n        console.log(`❌ ${name} - ERROR: ${error}\\n`);\n      }\n    }\n\n    const allTestsPassed = passedTests === tests.length;\n\n    console.log(\"📊 Test Results:\");\n    console.log(`Passed: ${passedTests}/${tests.length}`);\n    console.log(`Success Rate: ${((passedTests / tests.length) * 100).toFixed(1)}%`);\n\n    if (allTestsPassed) {\n      console.log(\"🎉 All tests passed! TikTok Video Feed is ready for use.\");\n    } else {\n      console.log(\"⚠️ Some tests failed. Please review the implementation.\");\n    }\n\n    return allTestsPassed;\n  }\n}\n\n/**\n * Quick test function for development\n */\nexport const testTikTokVideoFeed = async (): Promise<void> => {\n  if (__DEV__) {\n    await TikTokVideoFeedTester.runAllTests();\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/testVideoFeedIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/trending.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/uploadVideo.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_fileName' is assigned a value but never used.","line":62,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as FileSystem from \"./legacyFileSystem\";\nimport { supabase } from \"../lib/supabase\";\n\nimport { uploadVideoToSupabase } from \"./storage\";\n\nexport interface UploadResult {\n  uploadId: string;\n  status: \"uploading\" | \"processing\" | \"completed\" | \"failed\";\n  processedVideoUrl?: string;\n  thumbnailUrl?: string;\n  transcription?: string;\n  error?: string;\n}\n\nexport interface UploadOptions {\n  onProgress?: (progress: number, message: string) => void;\n  enableFaceBlur?: boolean;\n  enableVoiceChange?: boolean;\n  enableTranscription?: boolean;\n  quality?: \"high\" | \"medium\" | \"low\";\n  voiceEffect?: \"deep\" | \"light\";\n}\n\n/**\n * Upload video anonymously to Supabase storage and initiate processing\n */\nexport const uploadVideoAnonymously = async (videoUri: string, options: UploadOptions = {}): Promise<UploadResult> => {\n  const {\n    onProgress,\n    enableFaceBlur = true,\n    enableVoiceChange = true,\n    enableTranscription = true,\n    quality = \"medium\",\n    voiceEffect = \"deep\",\n  } = options;\n\n  try {\n    onProgress?.(5, \"Validating video file...\");\n\n    // Validate input file\n    try {\n      const fileInfo = await FileSystem.getInfoAsync(videoUri);\n      if (!fileInfo.exists) {\n        throw new Error(\"Video file does not exist\");\n      }\n\n      if (fileInfo.size && fileInfo.size > 100 * 1024 * 1024) {\n        // 100MB limit\n        throw new Error(\"Video file is too large (max 100MB)\");\n      }\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"too large\")) {\n        throw error;\n      }\n      throw new Error(\"Video file does not exist\");\n    }\n\n    onProgress?.(10, \"Preparing upload...\");\n\n    // Generate unique upload ID\n    const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substring(7)}`;\n    const _fileName = `${uploadId}.mp4`;\n\n    onProgress?.(20, \"Uploading video...\");\n\n    // Require auth for private bucket upload; use streaming helper\n    const { data: userData, error: userErr } = await supabase.auth.getUser();\n    if (userErr || !userData?.user) {\n      throw new Error(\"You must be signed in to upload video\");\n    }\n\n    const upload = await uploadVideoToSupabase(videoUri, userData.user.id, {\n      onProgress: (p: number) => onProgress?.(20 + (p * 0.2) / 100, \"Uploading video...\"),\n    });\n\n    onProgress?.(40, \"Initiating processing...\");\n\n    // Call Edge Function for processing using storage path (no public URL)\n    const { data: processData, error: processError } = await supabase.functions.invoke(\"process-video\", {\n      body: {\n        uploadId,\n        videoPath: upload.path,\n        options: {\n          enableFaceBlur,\n          enableVoiceChange,\n          enableTranscription,\n          quality,\n          voiceEffect,\n        },\n      },\n    });\n\n    if (processError) {\n      console.error(\"Edge Function error:\", processError);\n      throw new Error(`Processing initiation failed: ${processError.message}`);\n    }\n\n    if (!processData) {\n      throw new Error(\"No response data from Edge Function\");\n    }\n\n    if (!processData.success) {\n      throw new Error(`Processing initiation failed: ${processData.error || \"Unknown error\"}`);\n    }\n\n    onProgress?.(50, \"Upload and processing initiated successfully\");\n\n    return {\n      uploadId,\n      status: \"processing\",\n    };\n  } catch (error) {\n    console.error(\"Anonymous upload failed:\", error);\n    return {\n      uploadId: \"\",\n      status: \"failed\",\n      error: error instanceof Error ? error.message : \"Unknown upload error\",\n    };\n  }\n};\n\n/**\n * Poll for processing status of an uploaded video\n * Uses storage-based status tracking for anonymous uploads\n */\nexport const pollProcessingStatus = async (\n  uploadId: string,\n  onProgress?: (progress: number, message: string) => void,\n): Promise<UploadResult> => {\n  const maxRetries = 60; // 5 minutes with 5-second intervals\n  const pollInterval = 5000; // 5 seconds\n\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      onProgress?.(50 + (attempt / maxRetries) * 40, `Checking status... (${attempt + 1}/${maxRetries})`);\n\n      // Check for status file in storage\n      const statusFileName = `status_${uploadId}.json`;\n      const { data: statusData, error } = await supabase.storage.from(\"confessions\").download(statusFileName);\n\n      if (error) {\n        if (error.message.includes(\"not found\")) {\n          // Status file doesn't exist yet, continue polling\n          await new Promise((resolve) => setTimeout(resolve, pollInterval));\n          continue;\n        }\n        throw error;\n      }\n\n      // Parse status from JSON file\n      const statusText = await statusData.text();\n      const status = JSON.parse(statusText);\n\n      if (status.status === \"completed\") {\n        onProgress?.(95, \"Processing completed, downloading results...\");\n\n        return {\n          uploadId,\n          status: \"completed\",\n          processedVideoUrl: status.processedVideoUrl,\n          thumbnailUrl: status.thumbnailUrl,\n          transcription: status.transcription,\n        };\n      } else if (status.status === \"failed\") {\n        return {\n          uploadId,\n          status: \"failed\",\n          error: status.error || \"Processing failed\",\n        };\n      }\n\n      // Wait before next poll\n      await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    } catch (error) {\n      console.error(`Polling attempt ${attempt + 1} failed:`, error);\n      // Continue polling on error\n    }\n  }\n\n  return {\n    uploadId,\n    status: \"failed\",\n    error: \"Processing timeout - video processing took too long\",\n  };\n};\n\n/**\n * Download processed video and save locally\n */\nexport const downloadProcessedVideo = async (\n  processedVideoUrl: string,\n  onProgress?: (progress: number, message: string) => void,\n): Promise<string> => {\n  try {\n    onProgress?.(5, \"Starting download...\");\n\n    const { data: videoData, error: downloadError } = await supabase.storage\n      .from(\"confessions\")\n      .download(processedVideoUrl);\n\n    if (downloadError) {\n      throw new Error(`Download failed: ${downloadError.message}`);\n    }\n\n    onProgress?.(50, \"Saving video locally...\");\n\n    // Save to local filesystem\n    const localUri = `${FileSystem.Paths.cache.uri}processed_${Date.now()}.mp4`;\n    const arrayBuffer = await videoData.arrayBuffer();\n    const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n\n    await FileSystem.writeAsStringAsync(localUri, base64, {\n      encoding: \"base64\",\n    });\n\n    onProgress?.(100, \"Download complete\");\n\n    return localUri;\n  } catch (error) {\n    console.error(\"Download failed:\", error);\n    throw new Error(`Failed to download processed video: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n  }\n};\n\n/**\n * Complete workflow: upload, poll, and download\n */\nexport const uploadAndProcessVideo = async (\n  videoUri: string,\n  options: UploadOptions = {},\n): Promise<{ localUri: string; transcription?: string; thumbnailUrl?: string }> => {\n  const { onProgress } = options;\n\n  // Step 1: Upload video\n  const uploadResult = await uploadVideoAnonymously(videoUri, options);\n\n  if (uploadResult.status === \"failed\") {\n    throw new Error(uploadResult.error || \"Upload failed\");\n  }\n\n  // Step 2: Poll for completion\n  const finalResult = await pollProcessingStatus(uploadResult.uploadId, onProgress);\n\n  if (finalResult.status === \"failed\") {\n    throw new Error(finalResult.error || \"Processing failed\");\n  }\n\n  if (!finalResult.processedVideoUrl) {\n    throw new Error(\"No processed video URL received\");\n  }\n\n  // Step 3: Download processed video\n  const localUri = await downloadProcessedVideo(finalResult.processedVideoUrl, onProgress);\n\n  return {\n    localUri,\n    transcription: finalResult.transcription,\n    thumbnailUrl: finalResult.thumbnailUrl,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoAnalyticsStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoCacheManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":130,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":130,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":144,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":169,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":397,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":397,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":416,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":416,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":489,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":489,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is assigned a value but never used.","line":694,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":694,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is assigned a value but never used.","line":769,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":769,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":806,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":806,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lruStats' is assigned a value but never used.","line":842,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":842,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_expiredRemoved' is assigned a value but never used.","line":957,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":957,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deviceInfo' is assigned a value but never used.","line":985,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":985,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as FileSystem from \"./legacyFileSystem\";\nimport { Directory } from \"expo-file-system\";\nimport { LRUCache } from \"./lruCache\";\nimport { videoQualitySelector } from \"../services/VideoQualitySelector\";\nimport type { VideoQuality } from \"../services/VideoQualitySelector\";\nimport { videoPerformanceConfig, DevicePerformanceTier, NetworkQualityTier } from \"../config/videoPerformance\";\nimport NetInfo from \"@react-native-community/netinfo\";\nimport { environmentDetector } from \"./environmentDetector\";\n\nconst resolveCacheDirectory = (): string => {\n  const fsAny = FileSystem as unknown as {\n    cacheDirectory?: string | null;\n    documentDirectory?: string | null;\n    temporaryDirectory?: string | null;\n    Paths?: { cache?: { uri?: string }; document?: { uri?: string } };\n  };\n\n  const candidate =\n    fsAny.cacheDirectory ??\n    fsAny.documentDirectory ??\n    fsAny.temporaryDirectory ??\n    fsAny.Paths?.cache?.uri ??\n    fsAny.Paths?.document?.uri ??\n    null;\n\n  if (typeof candidate === \"string\" && candidate.length > 0) {\n    return candidate.endsWith(\"/\") ? candidate : `${candidate}/`;\n  }\n\n  throw new Error(\"Unable to resolve cache directory for video cache manager\");\n};\n\ninterface CacheEntry {\n  uri: string;\n  localPath: string;\n  timestamp: number;\n  size: number;\n  accessCount: number;\n  priority: \"high\" | \"normal\" | \"low\";\n  lastAccessTime: number;\n  predictedNextAccess?: number;\n  quality?: \"high\" | \"medium\" | \"low\";\n  contentType?: \"thumbnail\" | \"preview\" | \"full\";\n  compressionRatio?: number;\n  videoQuality?: \"360p\" | \"720p\" | \"1080p\";\n  networkQuality?: NetworkQualityTier;\n  deviceTier?: DevicePerformanceTier;\n  variantUris?: Map<VideoQuality, string>;\n}\n\ninterface CacheConfig {\n  maxCacheSize: number;\n  maxEntries: number;\n  preloadLimit: number;\n  cleanupThreshold: number;\n  memoryPressureThreshold: number;\n  compressionEnabled: boolean;\n  intelligentPreload: boolean;\n  cachePartitioning: boolean;\n  idleCleanupInterval: number;\n}\n\nclass VideoCacheManager {\n  private cache: Map<string, CacheEntry> = new Map();\n  private lruCache: LRUCache<CacheEntry>;\n  private config: CacheConfig = {\n    maxCacheSize: 500 * 1024 * 1024, // 500MB\n    maxEntries: 100,\n    preloadLimit: 5,\n    cleanupThreshold: 0.9, // Start cleanup at 90% capacity\n    memoryPressureThreshold: 0.8, // Reduce cache when memory usage > 80%\n    compressionEnabled: true,\n    intelligentPreload: true,\n    cachePartitioning: true,\n    idleCleanupInterval: 30000, // 30 seconds\n  };\n  private currentCacheSize = 0;\n  private cacheDir = `${resolveCacheDirectory()}video_cache/`;\n  private isCleaningUp = false;\n  private viewingPatterns: Map<string, number[]> = new Map();\n  private cacheHitRate = 0;\n  private totalRequests = 0;\n  private totalHits = 0;\n  private idleCleanupTimer?: ReturnType<typeof setInterval>;\n  private memoryMonitorTimer?: ReturnType<typeof setInterval>;\n  private cachePartitions: Map<string, Map<string, CacheEntry>> = new Map();\n  private deviceTier: DevicePerformanceTier = DevicePerformanceTier.MID;\n  private networkQuality: NetworkQualityTier = NetworkQualityTier.FAIR;\n  private qualityVariantCache: Map<string, Map<VideoQuality, string>> = new Map();\n  private bandwidthAdaptiveDownloading = true;\n  private networkListener: any = null;\n\n  constructor(config?: Partial<CacheConfig>) {\n    this.config = { ...this.config, ...config };\n\n    // Initialize LRU cache for metadata\n    this.lruCache = new LRUCache<CacheEntry>({\n      maxSize: this.config.maxEntries,\n      ttl: 24 * 60 * 60 * 1000, // 24 hours\n      onEvict: (key, entry) => this.handleEviction(key, entry),\n      getSizeOf: (entry) => entry.size,\n    });\n\n    // Initialize cache partitions with quality-aware partitioning\n    this.cachePartitions.set(\"thumbnail\", new Map());\n    this.cachePartitions.set(\"preview\", new Map());\n    this.cachePartitions.set(\"full\", new Map());\n    this.cachePartitions.set(\"low_quality\", new Map());\n    this.cachePartitions.set(\"medium_quality\", new Map());\n    this.cachePartitions.set(\"high_quality\", new Map());\n\n    this.initializeCache();\n    this.startBackgroundTasks();\n    this.initializeDeviceAndNetwork();\n  }\n\n  async initialize() {\n    await this.initializeCache();\n    await this.initializeDeviceAndNetwork();\n  }\n\n  private async initializeCache() {\n    try {\n      // Create cache directory if it doesn't exist\n      try {\n        const dirInfo = await FileSystem.getInfoAsync(this.cacheDir);\n        if (!dirInfo.exists) {\n          new Directory(this.cacheDir).create({ intermediates: true });\n        }\n      } catch (error) {\n        // Directory doesn't exist, create it\n        new Directory(this.cacheDir).create({ intermediates: true });\n      }\n\n      // Create partition directories including quality-based partitions\n      if (this.config.cachePartitioning) {\n        for (const partition of [\"thumbnail\", \"preview\", \"full\", \"low_quality\", \"medium_quality\", \"high_quality\"]) {\n          const partitionDir = `${this.cacheDir}${partition}/`;\n          try {\n            const partitionInfo = await FileSystem.getInfoAsync(partitionDir);\n            if (!partitionInfo.exists) {\n              new Directory(partitionDir).create({ intermediates: true });\n            }\n          } catch (error) {\n            // Directory doesn't exist, create it\n            new Directory(partitionDir).create({ intermediates: true });\n          }\n        }\n      }\n\n      // Load existing cache entries\n      await this.loadCacheIndex();\n\n      // Load viewing patterns\n      await this.loadViewingPatterns();\n    } catch (error) {\n      console.error(\"Failed to initialize video cache:\", error);\n    }\n  }\n\n  private async loadCacheIndex() {\n    try {\n      const indexPath = `${this.cacheDir}index.json`;\n      let indexExists = false;\n\n      try {\n        const indexInfo = await FileSystem.getInfoAsync(indexPath);\n        indexExists = indexInfo.exists;\n      } catch (error) {\n        indexExists = false;\n      }\n\n      if (indexExists) {\n        const indexContent = await FileSystem.readAsStringAsync(indexPath);\n        const cacheData = JSON.parse(indexContent);\n\n        for (const [key, entry] of Object.entries(cacheData)) {\n          const cacheEntry = entry as any;\n\n          // Restore Map from array if present\n          if (cacheEntry.variantUris && Array.isArray(cacheEntry.variantUris)) {\n            cacheEntry.variantUris = new Map<VideoQuality, string>(cacheEntry.variantUris as any);\n          }\n\n          this.cache.set(key, cacheEntry as CacheEntry);\n          this.currentCacheSize += cacheEntry.size;\n        }\n      }\n    } catch (error) {\n      console.error(\"Failed to load cache index:\", error);\n    }\n  }\n\n  private async saveCacheIndex() {\n    try {\n      const indexPath = `${this.cacheDir}index.json`;\n      const cacheData: Record<string, any> = {};\n\n      for (const [key, entry] of this.cache) {\n        // Convert Map to array for serialization\n        const serializedEntry = {\n          ...entry,\n          variantUris: entry.variantUris ? Array.from(entry.variantUris.entries()) : undefined,\n        };\n        cacheData[key] = serializedEntry;\n      }\n\n      await FileSystem.writeAsStringAsync(indexPath, JSON.stringify(cacheData));\n    } catch (error) {\n      console.error(\"Failed to save cache index:\", error);\n    }\n  }\n\n  private generateCacheKey(uri: string): string {\n    // Simple hash function for cache key\n    let hash = 0;\n    for (let i = 0; i < uri.length; i++) {\n      const char = uri.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString();\n  }\n\n  private async handleEviction(key: string, entry: CacheEntry) {\n    try {\n      await FileSystem.deleteAsync(entry.localPath, { idempotent: true });\n\n      // Also evict quality variants if they exist\n      if (entry.variantUris) {\n        for (const [quality, variantPath] of entry.variantUris) {\n          try {\n            await FileSystem.deleteAsync(variantPath, { idempotent: true });\n          } catch (error) {\n            console.error(`Failed to evict variant ${quality}:`, error);\n          }\n        }\n      }\n\n      this.cache.delete(key);\n      this.currentCacheSize -= entry.size;\n\n      if (__DEV__) {\n        console.log(`[VideoCache] Evicted ${key}, freed ${(entry.size / 1024 / 1024).toFixed(2)}MB`);\n      }\n    } catch (error) {\n      console.error(\"Failed to evict cache entry:\", error);\n    }\n  }\n\n  private async evictLeastRecentlyUsed() {\n    if (this.isCleaningUp) return;\n    this.isCleaningUp = true;\n\n    try {\n      // Use smart eviction strategy\n      await this.smartEviction();\n    } finally {\n      this.isCleaningUp = false;\n    }\n\n    await this.saveCacheIndex();\n  }\n\n  private async smartEviction() {\n    const perfConfig = videoPerformanceConfig.getCacheConfig();\n    const targetSize = perfConfig.maxCacheSize * 0.7; // Target 70% capacity based on device tier\n    const entries = Array.from(this.cache.entries());\n\n    // Sort by priority, quality, and access patterns\n    const sortedEntries = entries.sort(([, a], [, b]) => {\n      // Priority-based sorting\n      const priorityWeight = { high: 3, normal: 2, low: 1 };\n      const aPriority = priorityWeight[a.priority];\n      const bPriority = priorityWeight[b.priority];\n\n      if (aPriority !== bPriority) {\n        return bPriority - aPriority; // Higher priority first (keep)\n      }\n\n      // Quality-based sorting (keep higher quality for high-tier devices)\n      if (this.deviceTier === DevicePerformanceTier.HIGH && a.videoQuality && b.videoQuality) {\n        const qualityOrder = { \"1080p\": 3, \"720p\": 2, \"360p\": 1 };\n        const aQuality = qualityOrder[a.videoQuality] || 0;\n        const bQuality = qualityOrder[b.videoQuality] || 0;\n        if (aQuality !== bQuality) {\n          return bQuality - aQuality;\n        }\n      }\n\n      // Calculate normalized recency score (0-1, where 1 is most recent)\n      const now = Date.now();\n      const maxAge = Math.max(...entries.map(([, entry]) => now - entry.timestamp), 1);\n      const aRecency = 1 - (now - a.timestamp) / maxAge;\n      const bRecency = 1 - (now - b.timestamp) / maxAge;\n\n      // Calculate normalized access frequency score (0-1)\n      const maxAccess = Math.max(...entries.map(([, entry]) => entry.accessCount), 1);\n      const aFrequency = a.accessCount / maxAccess;\n      const bFrequency = b.accessCount / maxAccess;\n\n      // Combined score with proper weighting\n      const aScore = aFrequency * 0.6 + aRecency * 0.4;\n      const bScore = bFrequency * 0.6 + bRecency * 0.4;\n\n      return aScore - bScore; // Lower score first (evict)\n    });\n\n    // Evict entries until we reach target size\n    for (const [key, entry] of sortedEntries) {\n      if (this.currentCacheSize <= targetSize) break;\n\n      // Evict lower quality variants first for popular videos\n      if (entry.variantUris && entry.accessCount > 5) {\n        const variants = Array.from(entry.variantUris.entries());\n        for (const [quality, path] of variants) {\n          if (quality === \"360p\" && this.deviceTier !== DevicePerformanceTier.LOW) {\n            try {\n              const fileInfo = await FileSystem.getInfoAsync(path);\n              if (fileInfo.exists) {\n                await FileSystem.deleteAsync(path, { idempotent: true });\n                entry.variantUris.delete(quality);\n                this.currentCacheSize -= (fileInfo as any).size || 0;\n              }\n            } catch (error) {\n              console.error(\"Failed to evict quality variant:\", error);\n            }\n          }\n        }\n      }\n\n      if (this.currentCacheSize <= targetSize) break;\n      await this.handleEviction(key, entry);\n    }\n  }\n\n  async getCachedVideo(uri: string, priority: \"high\" | \"normal\" | \"low\" = \"normal\"): Promise<string | null> {\n    const originalKey = this.generateCacheKey(uri);\n    let entry = this.cache.get(originalKey);\n    let cacheKey = originalKey;\n    let selectedQuality: VideoQuality | null = null;\n\n    if (!entry) {\n      const qualityResult = await videoQualitySelector.selectVideoQuality(uri);\n      selectedQuality = qualityResult.selectedQuality as VideoQuality;\n      const qualityUri = videoQualitySelector.getQualityForUri(uri, selectedQuality);\n      const qualityKey = this.generateCacheKey(qualityUri);\n      entry = this.cache.get(qualityKey);\n      if (entry) {\n        cacheKey = qualityKey;\n      }\n    }\n\n    this.totalRequests++;\n\n    if (entry) {\n      // Update access information\n      const now = Date.now();\n      entry.timestamp = now;\n      entry.lastAccessTime = now;\n      entry.accessCount++;\n      entry.priority = priority; // Update priority based on current usage\n      entry.deviceTier = this.deviceTier;\n      entry.networkQuality = this.networkQuality;\n\n      // Track hit rate\n      this.totalHits++;\n      this.cacheHitRate = this.totalHits / this.totalRequests;\n\n      // Update viewing patterns for intelligent preloading\n      if (this.config.intelligentPreload) {\n        this.updateViewingPattern(uri, now);\n      }\n\n      // Update existing entry, don't create duplicate under new key\n      const existingKey = Array.from(this.cache.entries()).find(([_, e]) => e.localPath === entry!.localPath)?.[0];\n\n      if (existingKey) {\n        cacheKey = existingKey;\n        this.cache.set(existingKey, entry);\n        this.lruCache.set(existingKey, entry);\n      } else {\n        cacheKey = this.generateCacheKey(uri);\n        this.cache.set(cacheKey, entry);\n        this.lruCache.set(cacheKey, entry);\n      }\n\n      // Check for quality variant if available\n      const desiredQuality = selectedQuality ?? (videoPerformanceConfig.getQualitySelection().quality as VideoQuality);\n      if (entry.variantUris && entry.variantUris.has(desiredQuality)) {\n        const variantPath = entry.variantUris.get(desiredQuality)!;\n        try {\n          const variantInfo = await FileSystem.getInfoAsync(variantPath);\n          if (variantInfo.exists) {\n            return variantPath;\n          }\n        } catch (error) {\n          // Variant file doesn't exist, continue to original\n        }\n      }\n\n      // Verify original file still exists\n      try {\n        const fileInfo = await FileSystem.getInfoAsync(entry.localPath);\n        if (fileInfo.exists) {\n          // Trigger cleanup if we're approaching capacity\n          if (this.currentCacheSize > this.config.maxCacheSize * this.config.cleanupThreshold) {\n            // Don't await - run cleanup in background\n            this.evictLeastRecentlyUsed().catch((error) => {\n              console.error(\"Background cleanup failed:\", error);\n            });\n          }\n\n          return entry.localPath;\n        }\n      } catch (error) {\n        // File was deleted externally, remove from cache\n        this.cache.delete(cacheKey);\n        this.lruCache.delete(cacheKey);\n        this.currentCacheSize -= entry.size;\n      }\n    }\n\n    return null;\n  }\n\n  async cacheVideo(uri: string, priority: \"high\" | \"normal\" | \"low\" = \"normal\"): Promise<string> {\n    // Get quality selection for this video\n    const qualityResult = await videoQualitySelector.selectVideoQuality(uri);\n    const targetQuality = qualityResult.selectedQuality;\n    const variants = qualityResult.variants;\n\n    // Use quality-specific URI if available\n    const targetUri = variants.find((v) => v.quality === targetQuality)?.uri || uri;\n    const cacheKey = this.generateCacheKey(targetUri);\n    const existingEntry = await this.getCachedVideo(targetUri, priority);\n\n    if (existingEntry) {\n      return existingEntry;\n    }\n\n    try {\n      const fileName = `${cacheKey}_${targetQuality}.mp4`;\n      const qualityPartition = this.getQualityPartition(targetQuality);\n      const localPath = `${this.cacheDir}${qualityPartition}/${fileName}`;\n\n      // Apply bandwidth-adaptive downloading\n      if (this.bandwidthAdaptiveDownloading && this.networkQuality === NetworkQualityTier.POOR) {\n        // Use lower quality for poor networks\n        const fallbackUri = variants.find((v) => v.quality === \"360p\")?.uri || targetUri;\n        const downloadResult = await FileSystem.downloadAsync(fallbackUri, localPath);\n\n        if (downloadResult.status === 200) {\n          return await this.processCachedVideo(fallbackUri, localPath, priority, \"360p\", qualityResult);\n        }\n      }\n\n      // Download the video with retry logic for quality fallback\n      let downloadResult = await FileSystem.downloadAsync(targetUri, localPath);\n\n      if (downloadResult.status !== 200 && qualityResult.fallbackQuality) {\n        // Try fallback quality\n        const fallbackUri = variants.find((v) => v.quality === qualityResult.fallbackQuality)?.uri || uri;\n        downloadResult = await FileSystem.downloadAsync(fallbackUri, localPath);\n      }\n\n      if (downloadResult.status === 200) {\n        return await this.processCachedVideo(targetUri, localPath, priority, targetQuality, qualityResult);\n      } else {\n        throw new Error(`Download failed with status: ${downloadResult.status}`);\n      }\n    } catch (error) {\n      console.error(\"Failed to cache video:\", error);\n      return uri; // Return original URI as fallback\n    }\n  }\n\n  private async processCachedVideo(\n    uri: string,\n    localPath: string,\n    priority: \"high\" | \"normal\" | \"low\",\n    quality: \"360p\" | \"720p\" | \"1080p\",\n    qualityResult: any,\n  ): Promise<string> {\n    let fileSize = 0;\n    try {\n      const fileInfo = await FileSystem.getInfoAsync(localPath);\n      fileSize = fileInfo.exists && !fileInfo.isDirectory ? (fileInfo as any).size || 0 : 0;\n    } catch (error) {\n      fileSize = 0;\n    }\n\n    // Check if we need to evict old entries\n    if (this.currentCacheSize + fileSize > this.config.maxCacheSize) {\n      await this.evictLeastRecentlyUsed();\n    }\n\n    const cacheKey = this.generateCacheKey(uri);\n\n    // Add to cache with quality information\n    const entry: CacheEntry = {\n      uri,\n      localPath,\n      timestamp: Date.now(),\n      size: fileSize,\n      accessCount: 1,\n      priority,\n      lastAccessTime: Date.now(),\n      videoQuality: quality,\n      deviceTier: this.deviceTier,\n      networkQuality: this.networkQuality,\n      variantUris: new Map<VideoQuality, string>(),\n    };\n\n    // Store quality variants if caching multiple qualities\n    if (videoPerformanceConfig.shouldEnableFeature(\"multiQualityCaching\")) {\n      for (const variant of qualityResult.variants) {\n        if (variant.quality !== quality) {\n          // Queue background caching of other variants\n          this.cacheQualityVariant(uri, variant.quality, variant.uri, cacheKey);\n        }\n      }\n    }\n\n    this.cache.set(cacheKey, entry);\n    this.lruCache.set(cacheKey, entry);\n    this.currentCacheSize += fileSize;\n    await this.saveCacheIndex();\n\n    return localPath;\n  }\n\n  private getQualityPartition(quality: \"360p\" | \"720p\" | \"1080p\"): string {\n    const qualityMap = {\n      \"360p\": \"low_quality\",\n      \"720p\": \"medium_quality\",\n      \"1080p\": \"high_quality\",\n    };\n    return qualityMap[quality] || \"medium_quality\";\n  }\n\n  private async cacheQualityVariant(\n    originalUri: string,\n    quality: \"360p\" | \"720p\" | \"1080p\",\n    variantUri: string,\n    parentCacheKey: string,\n  ): Promise<void> {\n    try {\n      const variantKey = `${parentCacheKey}_${quality}`;\n      const fileName = `${variantKey}.mp4`;\n      const qualityPartition = this.getQualityPartition(quality);\n      const localPath = `${this.cacheDir}${qualityPartition}/${fileName}`;\n\n      // Use background queue for variant caching\n      import(\"../services/VideoBackgroundQueue\")\n        .then(({ videoBackgroundQueue, JobType, JobPriority }) => {\n          videoBackgroundQueue.enqueueJob(\n            JobType.QUALITY_VARIANT_GENERATION,\n            {\n              originalUri,\n              quality,\n              variantUri,\n              parentCacheKey,\n              localPath,\n            },\n            JobPriority.LOW,\n            {\n              onComplete: async (result) => {\n                if (result.success) {\n                  try {\n                    const downloadResult = await FileSystem.downloadAsync(variantUri, localPath);\n                    if (downloadResult.status === 200) {\n                      const entry = this.cache.get(parentCacheKey);\n                      if (entry && entry.variantUris) {\n                        entry.variantUris.set(quality as VideoQuality, localPath);\n                        this.cache.set(parentCacheKey, entry);\n                      }\n                    }\n                  } catch (error) {\n                    console.error(`Failed to cache quality variant ${quality}:`, error);\n                  }\n                }\n              },\n            },\n          );\n        })\n        .catch((error) => {\n          console.error(\"Failed to load background queue:\", error);\n        });\n    } catch (error) {\n      console.error(\"Failed to queue quality variant caching:\", error);\n    }\n  }\n\n  async clearCache(): Promise<void> {\n    try {\n      await FileSystem.deleteAsync(this.cacheDir, { idempotent: true });\n      this.cache.clear();\n      this.currentCacheSize = 0;\n      await this.initializeCache();\n    } catch (error) {\n      console.error(\"Failed to clear cache:\", error);\n    }\n  }\n\n  getCacheSize(): number {\n    return this.currentCacheSize;\n  }\n\n  private startBackgroundTasks() {\n    // Clear any existing timers/listeners first\n    this.clearBackgroundTasks();\n\n    // Start idle cleanup with device-aware intervals\n    const perfConfig = videoPerformanceConfig.getCacheConfig();\n    const cleanupInterval = perfConfig.cleanupInterval;\n\n    if (cleanupInterval > 0) {\n      this.idleCleanupTimer = setInterval(() => {\n        this.performIdleCleanup();\n      }, cleanupInterval);\n    }\n\n    // Start memory pressure monitoring\n    this.memoryMonitorTimer = setInterval(() => {\n      this.checkMemoryPressure();\n    }, 5000); // Check every 5 seconds\n\n    // Start network monitoring for adaptive caching\n    this.networkListener = NetInfo.addEventListener((state) => {\n      this.handleNetworkChange(state);\n    });\n  }\n\n  private clearBackgroundTasks() {\n    if (this.idleCleanupTimer) {\n      clearInterval(this.idleCleanupTimer);\n      this.idleCleanupTimer = undefined;\n    }\n    if (this.memoryMonitorTimer) {\n      clearInterval(this.memoryMonitorTimer);\n      this.memoryMonitorTimer = undefined;\n    }\n    if (this.networkListener) {\n      this.networkListener();\n      this.networkListener = null;\n    }\n  }\n\n  private async performIdleCleanup() {\n    if (this.isCleaningUp) return;\n\n    try {\n      // Clean up old temporary files\n      const now = Date.now();\n      const maxAge = 2 * 60 * 60 * 1000; // 2 hours\n\n      for (const [key, entry] of this.cache.entries()) {\n        if (now - entry.lastAccessTime > maxAge && entry.priority === \"low\") {\n          await this.handleEviction(key, entry);\n        }\n      }\n\n      // Optimize cache based on access patterns\n      if (this.config.intelligentPreload) {\n        await this.optimizeCacheBasedOnPatterns();\n      }\n    } catch (error) {\n      console.error(\"Idle cleanup failed:\", error);\n    }\n  }\n\n  private async checkMemoryPressure() {\n    // Get actual memory info from environment detector\n    const memoryInfo = await environmentDetector.getMemoryInfo();\n    const memoryPressure = (memoryInfo.totalMemory - memoryInfo.availableMemory) / memoryInfo.totalMemory;\n\n    // Use device-aware memory pressure thresholds\n    const perfConfig = videoPerformanceConfig.getCacheConfig();\n\n    if (memoryPressure > perfConfig.memoryPressureThreshold) {\n      // Progressive cache degradation based on device tier\n      const reductionRatio = this.deviceTier === DevicePerformanceTier.LOW ? 0.3 : 0.5;\n      await this.reduceCache(reductionRatio);\n\n      // Reduce quality variants under pressure\n      if (memoryPressure > 0.9) {\n        await this.evictQualityVariants();\n      }\n    }\n  }\n\n  private async evictQualityVariants(): Promise<void> {\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.variantUris && entry.variantUris.size > 0) {\n        // Keep only the most appropriate quality for current conditions\n        const targetQuality = await this.getOptimalQualityForCurrentConditions();\n\n        for (const [quality, path] of entry.variantUris) {\n          if (quality !== targetQuality) {\n            try {\n              await FileSystem.deleteAsync(path, { idempotent: true });\n              entry.variantUris.delete(quality);\n            } catch (error) {\n              console.error(`Failed to evict quality variant ${quality}:`, error);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private async getOptimalQualityForCurrentConditions(): Promise<\"360p\" | \"720p\" | \"1080p\"> {\n    const qualitySelection = videoPerformanceConfig.getQualitySelection();\n    return qualitySelection.quality as \"360p\" | \"720p\" | \"1080p\";\n  }\n\n  private async reduceCache(targetRatio: number) {\n    const targetSize = this.config.maxCacheSize * targetRatio;\n\n    while (this.currentCacheSize > targetSize && this.cache.size > 0) {\n      // Remove lowest priority items first\n      const entries = Array.from(this.cache.entries());\n      const lowestPriority = entries.sort((a, b) => {\n        const priorityMap = { low: 0, normal: 1, high: 2 };\n        return priorityMap[a[1].priority] - priorityMap[b[1].priority];\n      })[0];\n\n      if (lowestPriority) {\n        await this.handleEviction(lowestPriority[0], lowestPriority[1]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  private updateViewingPattern(uri: string, timestamp: number) {\n    const patterns = this.viewingPatterns.get(uri) || [];\n    patterns.push(timestamp);\n\n    // Keep only recent patterns (last 10 accesses)\n    if (patterns.length > 10) {\n      patterns.shift();\n    }\n\n    this.viewingPatterns.set(uri, patterns);\n\n    // Predict next access time\n    if (patterns.length >= 2) {\n      const intervals = [];\n      for (let i = 1; i < patterns.length; i++) {\n        intervals.push(patterns[i] - patterns[i - 1]);\n      }\n      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;\n\n      // Update entry with predicted next access\n      const entry = this.cache.get(this.generateCacheKey(uri));\n      if (entry) {\n        entry.predictedNextAccess = timestamp + avgInterval;\n      }\n    }\n  }\n\n  private async optimizeCacheBasedOnPatterns() {\n    const now = Date.now();\n    const upcomingVideos: string[] = [];\n\n    // Find videos likely to be accessed soon\n    for (const [key, entry] of this.cache.entries()) {\n      if (\n        entry.predictedNextAccess &&\n        entry.predictedNextAccess - now < 60000 && // Within next minute\n        entry.predictedNextAccess > now\n      ) {\n        upcomingVideos.push(entry.uri);\n      }\n    }\n\n    // Preload predicted videos\n    if (upcomingVideos.length > 0) {\n      await this.warmCache(upcomingVideos.slice(0, 3)); // Warm up to 3 videos\n    }\n  }\n\n  async warmCache(uris: string[]) {\n    for (const uri of uris) {\n      const cacheKey = this.generateCacheKey(uri);\n      const entry = this.cache.get(cacheKey);\n\n      if (entry) {\n        // Touch the entry to keep it warm\n        entry.lastAccessTime = Date.now();\n        this.lruCache.set(cacheKey, entry);\n      }\n    }\n  }\n\n  private async loadViewingPatterns() {\n    try {\n      const patternsPath = `${this.cacheDir}patterns.json`;\n      let patternsExist = false;\n\n      try {\n        const patternsInfo = await FileSystem.getInfoAsync(patternsPath);\n        patternsExist = patternsInfo.exists;\n      } catch (error) {\n        patternsExist = false;\n      }\n\n      if (patternsExist) {\n        const patternsContent = await FileSystem.readAsStringAsync(patternsPath);\n        const patterns = JSON.parse(patternsContent);\n        this.viewingPatterns = new Map(Object.entries(patterns));\n      }\n    } catch (error) {\n      console.error(\"Failed to load viewing patterns:\", error);\n    }\n  }\n\n  private async saveViewingPatterns() {\n    try {\n      const patternsPath = `${this.cacheDir}patterns.json`;\n      const patterns = Object.fromEntries(this.viewingPatterns);\n      await FileSystem.writeAsStringAsync(patternsPath, JSON.stringify(patterns));\n    } catch (error) {\n      console.error(\"Failed to save viewing patterns:\", error);\n    }\n  }\n\n  getCacheStats(): {\n    size: number;\n    count: number;\n    maxSize: number;\n    hitRate: number;\n    priorityBreakdown: Record<string, number>;\n    oldestEntry: number;\n    newestEntry: number;\n    averageAccessFrequency: number;\n    storageEfficiency: number;\n    predictiveAccuracy?: number;\n  } {\n    const lruStats = this.lruCache.getStats();\n    const entries = Array.from(this.cache.values());\n\n    const priorityBreakdown = entries.reduce(\n      (acc, entry) => {\n        acc[entry.priority] = (acc[entry.priority] || 0) + 1;\n        return acc;\n      },\n      {} as Record<string, number>,\n    );\n\n    const timestamps = entries.map((e) => e.timestamp);\n\n    const avgAccessFreq = entries.length > 0 ? entries.reduce((sum, e) => sum + e.accessCount, 0) / entries.length : 0;\n\n    const storageEfficiency = this.config.maxCacheSize > 0 ? this.currentCacheSize / this.config.maxCacheSize : 0;\n\n    return {\n      size: this.currentCacheSize,\n      count: this.cache.size,\n      maxSize: this.config.maxCacheSize,\n      hitRate: this.cacheHitRate,\n      priorityBreakdown,\n      oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : 0,\n      newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : 0,\n      averageAccessFrequency: avgAccessFreq,\n      storageEfficiency,\n    };\n  }\n\n  /**\n   * Preload videos with device-aware and network-aware support\n   */\n  async preloadVideos(uris: string[], priority: \"high\" | \"normal\" | \"low\" = \"normal\"): Promise<void> {\n    // Get device-specific preload configuration\n    const preloadProfile = videoPerformanceConfig.getPreloadProfile();\n    const maxConcurrent = preloadProfile.maxConcurrentPreloads;\n    const preloadWindow = Math.min(uris.length, preloadProfile.preloadWindowSize);\n\n    // Filter URIs based on preload window\n    const urisToPreload = uris.slice(0, preloadWindow);\n\n    // Apply network-aware preloading\n    if (this.networkQuality === NetworkQualityTier.POOR) {\n      // Reduce preload for poor networks\n      const reducedUris = urisToPreload.slice(0, Math.ceil(preloadWindow / 2));\n      return this.preloadVideosWithConcurrency(reducedUris, priority, Math.max(1, maxConcurrent / 2));\n    }\n\n    // Check if aggressive preloading is enabled for this device tier\n    if (videoPerformanceConfig.shouldEnableFeature(\"aggressivePreloading\")) {\n      // Preload with higher concurrency for high-tier devices\n      return this.preloadVideosWithConcurrency(urisToPreload, priority, maxConcurrent * 2);\n    }\n\n    return this.preloadVideosWithConcurrency(urisToPreload, priority, maxConcurrent);\n  }\n\n  private async preloadVideosWithConcurrency(\n    uris: string[],\n    priority: \"high\" | \"normal\" | \"low\",\n    concurrency: number,\n  ): Promise<void> {\n    // Limit concurrent preloads to prevent overwhelming the system\n    const chunks = [];\n    for (let i = 0; i < uris.length; i += concurrency) {\n      chunks.push(uris.slice(i, i + concurrency));\n    }\n\n    for (const chunk of chunks) {\n      const preloadPromises = chunk.map((uri) =>\n        this.cacheVideo(uri, priority).catch((error) => {\n          console.error(`Failed to preload video ${uri}:`, error);\n        }),\n      );\n\n      await Promise.allSettled(preloadPromises);\n    }\n  }\n\n  /**\n   * Update cache configuration with device-aware settings\n   */\n  updateConfig(newConfig?: Partial<CacheConfig>): void {\n    // Get device-specific configuration\n    const perfConfig = videoPerformanceConfig.getCacheConfig();\n\n    // Merge device-specific config with provided config\n    this.config = {\n      ...this.config,\n      maxCacheSize: perfConfig.maxCacheSize,\n      cleanupThreshold: perfConfig.memoryPressureThreshold,\n      ...newConfig,\n    };\n\n    // Clear and restart background tasks with new config\n    this.clearBackgroundTasks();\n    this.startBackgroundTasks();\n\n    // Update LRU cache limits\n    if (newConfig?.maxEntries || newConfig?.maxCacheSize) {\n      // Note: LRUCache doesn't support dynamic config updates\n      // In a real implementation, you might need to recreate the cache\n      console.warn(\"Cache config updated, consider restarting the cache for full effect\");\n    }\n  }\n\n  /**\n   * Force cleanup of expired and low-priority entries\n   */\n  async forceCleanup(): Promise<{ removedCount: number; freedSpace: number }> {\n    const initialSize = this.currentCacheSize;\n    const initialCount = this.cache.size;\n\n    // Clean up expired entries from LRU cache\n    const _expiredRemoved = this.lruCache.cleanup();\n\n    // Force eviction if still over threshold\n    if (this.currentCacheSize > this.config.maxCacheSize * 0.8) {\n      await this.evictLeastRecentlyUsed();\n    }\n\n    const freedSpace = initialSize - this.currentCacheSize;\n    const removedCount = initialCount - this.cache.size;\n\n    return { removedCount, freedSpace };\n  }\n\n  /**\n   * Cleanup on destroy\n   */\n  destroy() {\n    this.clearBackgroundTasks();\n    this.saveViewingPatterns();\n    this.saveCacheIndex();\n  }\n\n  /**\n   * Initialize device and network detection\n   */\n  private async initializeDeviceAndNetwork(): Promise<void> {\n    try {\n      // Detect device tier\n      const deviceInfo = await environmentDetector.getDeviceInfo();\n      const memoryInfo = await environmentDetector.getMemoryInfo();\n\n      const totalMemoryGB = memoryInfo.totalMemory / (1024 * 1024 * 1024);\n      if (totalMemoryGB >= 6) {\n        this.deviceTier = DevicePerformanceTier.HIGH;\n      } else if (totalMemoryGB >= 4) {\n        this.deviceTier = DevicePerformanceTier.MID;\n      } else {\n        this.deviceTier = DevicePerformanceTier.LOW;\n      }\n\n      videoPerformanceConfig.setDeviceTier(this.deviceTier);\n\n      // Detect initial network quality\n      const netInfo = await NetInfo.fetch();\n      this.updateNetworkQuality(netInfo);\n\n      // Update cache config based on device tier\n      this.updateConfig();\n    } catch (error) {\n      console.error(\"Failed to initialize device and network detection:\", error);\n    }\n  }\n\n  /**\n   * Handle network changes\n   */\n  private handleNetworkChange(state: any): void {\n    this.updateNetworkQuality(state);\n\n    // Adjust cache strategy based on network change\n    if (this.networkQuality === NetworkQualityTier.POOR) {\n      // Reduce cleanup interval on poor networks\n      if (this.idleCleanupTimer) {\n        clearInterval(this.idleCleanupTimer);\n        this.idleCleanupTimer = setInterval(() => {\n          this.performIdleCleanup();\n        }, 60000); // Faster cleanup on poor networks\n      }\n    }\n  }\n\n  /**\n   * Update network quality based on connection info\n   */\n  private updateNetworkQuality(state: any): void {\n    if (!state.isConnected) {\n      this.networkQuality = NetworkQualityTier.POOR;\n      return;\n    }\n\n    const type = state.type?.toLowerCase();\n    const effectiveType = state.details?.cellularGeneration?.toLowerCase() || type;\n\n    if (effectiveType === \"wifi\" || effectiveType === \"5g\") {\n      this.networkQuality = NetworkQualityTier.EXCELLENT;\n    } else if (effectiveType === \"4g\") {\n      this.networkQuality = NetworkQualityTier.GOOD;\n    } else if (effectiveType === \"3g\") {\n      this.networkQuality = NetworkQualityTier.FAIR;\n    } else {\n      this.networkQuality = NetworkQualityTier.POOR;\n    }\n\n    videoPerformanceConfig.setNetworkQuality(this.networkQuality);\n  }\n\n  /**\n   * Get device-aware cache statistics\n   */\n  getDeviceAwareCacheStats(): any {\n    const baseStats = this.getCacheStats();\n    return {\n      ...baseStats,\n      deviceTier: this.deviceTier,\n      networkQuality: this.networkQuality,\n      qualityVariants: this.getQualityVariantStats(),\n      adaptiveSettings: {\n        currentPreloadLimit: videoPerformanceConfig.getPreloadProfile().maxConcurrentPreloads,\n        currentMemoryLimit: videoPerformanceConfig.getPreloadProfile().memoryLimit,\n        currentCleanupInterval: videoPerformanceConfig.getCacheConfig().cleanupInterval,\n      },\n    };\n  }\n\n  private getQualityVariantStats(): any {\n    let variantCount = 0;\n    let variantSize = 0;\n    const qualityDistribution: Record<string, number> = {};\n\n    for (const entry of this.cache.values()) {\n      if (entry.variantUris) {\n        variantCount += entry.variantUris.size;\n        for (const quality of entry.variantUris.keys()) {\n          qualityDistribution[quality] = (qualityDistribution[quality] || 0) + 1;\n        }\n      }\n    }\n\n    return {\n      count: variantCount,\n      size: variantSize,\n      distribution: qualityDistribution,\n    };\n  }\n}\n\nexport const videoCacheManager = new VideoCacheManager();\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoCleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoErrorMessages.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VideoErrorRecoveryService' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { VideoError, VideoErrorType } from \"../types/videoErrors\";\nimport { VideoErrorRecoveryService } from \"../services/VideoErrorRecoveryService\";\nimport NetInfo, { NetInfoState } from \"@react-native-community/netinfo\";\nimport * as Device from \"expo-device\";\n\nexport type ErrorSeverity = \"low\" | \"medium\" | \"high\" | \"critical\";\nexport type ErrorContext = \"loading\" | \"playback\" | \"network\" | \"format\" | \"permission\";\n\nexport interface UserFriendlyError {\n  title: string;\n  message: string;\n  actionText?: string;\n  secondaryActionText?: string;\n  severity: ErrorSeverity;\n  context: ErrorContext;\n  technicalDetails?: string;\n  retryStrategy: RetryStrategy;\n}\n\nexport interface RetryStrategy {\n  shouldRetry: boolean;\n  maxRetries: number;\n  backoffMs: number[];\n  explanation: string;\n}\n\nexport interface ErrorAnalytics {\n  errorCode: string;\n  errorType: VideoErrorType;\n  deviceInfo: {\n    model: string | null;\n    osVersion: string | null;\n    memory: number | null;\n  };\n  networkInfo?: NetInfoState;\n  timestamp: number;\n  attemptNumber: number;\n}\n\nexport class VideoErrorMessages {\n  private static retryAttempts: Map<string, number> = new Map();\n  private static errorHistory: ErrorAnalytics[] = [];\n  private static maxHistorySize = 50;\n\n  static getUserFriendlyError(\n    error: VideoError,\n    attemptNumber: number = 1,\n    userState?: { isOffline?: boolean; isLowBandwidth?: boolean },\n  ): UserFriendlyError {\n    const errorKey = `${error.type}-${error.code}`;\n    this.retryAttempts.set(errorKey, attemptNumber);\n\n    if (userState?.isOffline) {\n      return this.getOfflineError();\n    }\n\n    switch (error.type) {\n      case VideoErrorType.NETWORK:\n        return this.getNetworkError(error, attemptNumber, userState?.isLowBandwidth);\n\n      case VideoErrorType.DECODE:\n      case VideoErrorType.FORMAT:\n        return this.getFormatError(error, attemptNumber);\n\n      case VideoErrorType.PERMISSION:\n        return this.getPermissionError(error);\n\n      case VideoErrorType.MEMORY:\n        return this.getMemoryError(error, attemptNumber);\n\n      case VideoErrorType.SERVER:\n        return this.getServerError(error, attemptNumber);\n\n      case VideoErrorType.TIMEOUT:\n        return this.getTimeoutError(error, attemptNumber);\n\n      case VideoErrorType.UNKNOWN:\n      default:\n        return this.getGenericError(error, attemptNumber);\n    }\n  }\n\n  private static getOfflineError(): UserFriendlyError {\n    return {\n      title: \"You're offline\",\n      message: \"Connect to the internet to load videos\",\n      actionText: \"Check settings\",\n      secondaryActionText: \"View downloaded\",\n      severity: \"medium\",\n      context: \"network\",\n      retryStrategy: {\n        shouldRetry: true,\n        maxRetries: Infinity,\n        backoffMs: [1000, 2000, 5000],\n        explanation: \"Will retry automatically when connection restored\",\n      },\n    };\n  }\n\n  private static getNetworkError(\n    error: VideoError,\n    attemptNumber: number,\n    isLowBandwidth?: boolean,\n  ): UserFriendlyError {\n    if (isLowBandwidth) {\n      return {\n        title: \"Slow connection detected\",\n        message: \"Video quality adjusted for your connection speed\",\n        actionText: \"Load anyway\",\n        secondaryActionText: \"Settings\",\n        severity: \"low\",\n        context: \"network\",\n        technicalDetails: error.debugInfo,\n        retryStrategy: {\n          shouldRetry: true,\n          maxRetries: 5,\n          backoffMs: [500, 1000, 2000, 4000, 8000],\n          explanation: \"Retrying with lower quality settings\",\n        },\n      };\n    }\n\n    const messages = [\n      \"Having trouble connecting. Let's try again!\",\n      \"Connection hiccup. Trying once more...\",\n      \"Network is being stubborn. One more attempt...\",\n      \"Connection issues persist. Last try!\",\n    ];\n\n    const messageIndex = Math.min(attemptNumber - 1, messages.length - 1);\n\n    return {\n      title: attemptNumber === 1 ? \"Connection issue\" : \"Still having trouble\",\n      message: messages[messageIndex],\n      actionText: \"Retry now\",\n      secondaryActionText: attemptNumber > 2 ? \"Report issue\" : undefined,\n      severity: attemptNumber > 3 ? \"high\" : \"medium\",\n      context: \"network\",\n      technicalDetails: error.debugInfo,\n      retryStrategy: {\n        shouldRetry: attemptNumber < 4,\n        maxRetries: 4,\n        backoffMs: [1000, 2000, 4000, 8000],\n        explanation: `Retry ${attemptNumber}/4 with exponential backoff`,\n      },\n    };\n  }\n\n  private static getFormatError(error: VideoError, attemptNumber: number): UserFriendlyError {\n    const isCodecIssue = error.debugInfo?.includes(\"codec\") || error.debugInfo?.includes(\"h264\");\n\n    return {\n      title: \"Video format issue\",\n      message: isCodecIssue ? \"This video format isn't supported on your device\" : \"Unable to play this video format\",\n      actionText: attemptNumber === 1 ? \"Try different quality\" : \"Skip video\",\n      secondaryActionText: \"Report problem\",\n      severity: \"medium\",\n      context: \"format\",\n      technicalDetails: error.debugInfo,\n      retryStrategy: {\n        shouldRetry: attemptNumber === 1 && !isCodecIssue,\n        maxRetries: 1,\n        backoffMs: [500],\n        explanation: isCodecIssue ? \"Device doesn't support this codec\" : \"Trying alternative format\",\n      },\n    };\n  }\n\n  private static getPermissionError(error: VideoError): UserFriendlyError {\n    return {\n      title: \"Permission needed\",\n      message: \"Allow app to access media to play videos\",\n      actionText: \"Open settings\",\n      secondaryActionText: \"Learn why\",\n      severity: \"high\",\n      context: \"permission\",\n      technicalDetails: error.debugInfo,\n      retryStrategy: {\n        shouldRetry: false,\n        maxRetries: 0,\n        backoffMs: [],\n        explanation: \"User needs to grant permissions manually\",\n      },\n    };\n  }\n\n  private static getMemoryError(error: VideoError, attemptNumber: number): UserFriendlyError {\n    const deviceMemory = Device.totalMemory;\n    const isLowEndDevice = deviceMemory && deviceMemory < 2 * 1024 * 1024 * 1024;\n\n    return {\n      title: \"Memory issue\",\n      message: isLowEndDevice\n        ? \"Close other apps to free up memory for videos\"\n        : \"Too many videos loaded. Clearing cache...\",\n      actionText: attemptNumber === 1 ? \"Clear & retry\" : \"Restart app\",\n      severity: \"high\",\n      context: \"playback\",\n      technicalDetails: `Available memory: ${deviceMemory}, ${error.debugInfo}`,\n      retryStrategy: {\n        shouldRetry: attemptNumber === 1,\n        maxRetries: 1,\n        backoffMs: [2000],\n        explanation: \"Clearing memory and retrying once\",\n      },\n    };\n  }\n\n  private static getServerError(error: VideoError, attemptNumber: number): UserFriendlyError {\n    const statusCode = parseInt(error.code) || 500;\n\n    if (statusCode === 404) {\n      return {\n        title: \"Video not found\",\n        message: \"This video may have been removed or moved\",\n        actionText: \"Browse other videos\",\n        severity: \"low\",\n        context: \"loading\",\n        retryStrategy: {\n          shouldRetry: false,\n          maxRetries: 0,\n          backoffMs: [],\n          explanation: \"Video doesn't exist\",\n        },\n      };\n    }\n\n    if (statusCode >= 500) {\n      return {\n        title: \"Server issue\",\n        message: \"Our servers are having a moment. We're on it!\",\n        actionText: \"Try again\",\n        secondaryActionText: \"Check status\",\n        severity: attemptNumber > 2 ? \"critical\" : \"medium\",\n        context: \"network\",\n        technicalDetails: `HTTP ${statusCode}: ${error.debugInfo}`,\n        retryStrategy: {\n          shouldRetry: attemptNumber < 3,\n          maxRetries: 3,\n          backoffMs: [2000, 5000, 10000],\n          explanation: \"Server error, retrying with longer delays\",\n        },\n      };\n    }\n\n    return this.getGenericError(error, attemptNumber);\n  }\n\n  private static getTimeoutError(error: VideoError, attemptNumber: number): UserFriendlyError {\n    return {\n      title: \"Taking too long\",\n      message: attemptNumber === 1 ? \"Video is taking longer than usual to load\" : \"Still waiting for the video...\",\n      actionText: \"Keep waiting\",\n      secondaryActionText: \"Try lower quality\",\n      severity: \"low\",\n      context: \"loading\",\n      technicalDetails: error.debugInfo,\n      retryStrategy: {\n        shouldRetry: true,\n        maxRetries: 3,\n        backoffMs: [0, 0, 0],\n        explanation: \"Extending timeout duration\",\n      },\n    };\n  }\n\n  private static getGenericError(error: VideoError, attemptNumber: number): UserFriendlyError {\n    const messages = [\n      \"Something went wrong. Let's try that again!\",\n      \"Still having issues. Trying a different approach...\",\n      \"This is tricky. One more attempt...\",\n    ];\n\n    return {\n      title: \"Oops!\",\n      message: messages[Math.min(attemptNumber - 1, messages.length - 1)],\n      actionText: \"Retry\",\n      secondaryActionText: attemptNumber > 2 ? \"Get help\" : undefined,\n      severity: attemptNumber > 2 ? \"medium\" : \"low\",\n      context: \"loading\",\n      technicalDetails: `${error.type}: ${error.code} - ${error.debugInfo}`,\n      retryStrategy: {\n        shouldRetry: attemptNumber < 3,\n        maxRetries: 3,\n        backoffMs: [1000, 3000, 5000],\n        explanation: \"Standard retry with backoff\",\n      },\n    };\n  }\n\n  static getProgressiveErrorMessage(error: VideoError, attemptHistory: number[]): string {\n    const totalAttempts = attemptHistory.reduce((sum, a) => sum + a, 0);\n\n    if (totalAttempts === 0) {\n      return \"Loading video...\";\n    } else if (totalAttempts === 1) {\n      return \"Having a small hiccup...\";\n    } else if (totalAttempts === 2) {\n      return \"Taking a bit longer than expected...\";\n    } else if (totalAttempts === 3) {\n      return \"We're working on it...\";\n    } else {\n      return \"Thanks for your patience. Almost there...\";\n    }\n  }\n\n  static getSmartRecoverySuggestion(\n    error: VideoError,\n    deviceCapabilities?: {\n      hasWifi?: boolean;\n      batteryLevel?: number;\n      freeStorage?: number;\n    },\n  ): string[] {\n    const suggestions: string[] = [];\n\n    if (error.type === VideoErrorType.NETWORK && !deviceCapabilities?.hasWifi) {\n      suggestions.push(\"Connect to Wi-Fi for better video quality\");\n    }\n\n    if (error.type === VideoErrorType.MEMORY && deviceCapabilities?.freeStorage) {\n      if (deviceCapabilities.freeStorage < 100 * 1024 * 1024) {\n        suggestions.push(\"Free up storage space for smoother playback\");\n      }\n    }\n\n    if (deviceCapabilities?.batteryLevel && deviceCapabilities.batteryLevel < 20) {\n      suggestions.push(\"Low battery may affect video performance\");\n    }\n\n    if (error.type === VideoErrorType.DECODE) {\n      suggestions.push(\"Try updating your app for better video support\");\n    }\n\n    return suggestions;\n  }\n\n  static async logErrorForAnalytics(error: VideoError, attemptNumber: number): Promise<void> {\n    const netInfo = await NetInfo.fetch();\n\n    const analytics: ErrorAnalytics = {\n      errorCode: error.code,\n      errorType: error.type,\n      deviceInfo: {\n        model: Device.modelName,\n        osVersion: Device.osVersion,\n        memory: Device.totalMemory,\n      },\n      networkInfo: netInfo,\n      timestamp: Date.now(),\n      attemptNumber,\n    };\n\n    this.errorHistory.push(analytics);\n\n    if (this.errorHistory.length > this.maxHistorySize) {\n      this.errorHistory.shift();\n    }\n\n    if (__DEV__) {\n      console.log(\"[VideoErrorAnalytics]\", analytics);\n    }\n  }\n\n  static getErrorTrend(): {\n    mostCommonError?: VideoErrorType;\n    averageRetries: number;\n    successRate: number;\n  } {\n    if (this.errorHistory.length === 0) {\n      return { averageRetries: 0, successRate: 1 };\n    }\n\n    const errorCounts = new Map<VideoErrorType, number>();\n    let totalRetries = 0;\n    let maxAttempts = 0;\n\n    this.errorHistory.forEach((e) => {\n      errorCounts.set(e.errorType, (errorCounts.get(e.errorType) || 0) + 1);\n      totalRetries += e.attemptNumber;\n      maxAttempts = Math.max(maxAttempts, e.attemptNumber);\n    });\n\n    const mostCommonError = Array.from(errorCounts.entries()).sort((a, b) => b[1] - a[1])[0]?.[0];\n\n    const averageRetries = totalRetries / this.errorHistory.length;\n    const successRate = 1 - this.errorHistory.filter((e) => e.attemptNumber >= 3).length / this.errorHistory.length;\n\n    return { mostCommonError, averageRetries, successRate };\n  }\n\n  static clearErrorHistory(): void {\n    this.errorHistory = [];\n    this.retryAttempts.clear();\n  }\n\n  static shouldSuggestQualityReduction(error: VideoError): boolean {\n    return (\n      error.type === VideoErrorType.NETWORK ||\n      error.type === VideoErrorType.TIMEOUT ||\n      error.type === VideoErrorType.MEMORY ||\n      (error.type === VideoErrorType.DECODE &&\n        typeof error.debugInfo === \"string\" &&\n        error.debugInfo.includes(\"bitrate\"))\n    );\n  }\n\n  static getLocalizedMessage(error: UserFriendlyError, locale: string = \"en\"): UserFriendlyError {\n    return error;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoErrors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VideoLoadError' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stack' is assigned a value but never used.","line":341,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":341,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  VideoErrorCode,\n  VideoErrorSeverity,\n  BaseVideoError,\n  VideoDisposalError,\n  VideoLoadError,\n  VideoNetworkError,\n  VideoPlaybackError,\n  VideoPermissionError,\n  VideoSourceError,\n} from \"../types/videoErrors\";\nimport { RetryConfig } from \"./retryLogic\";\n\n// Comprehensive error classification patterns\nconst ERROR_PATTERNS = {\n  disposal: [\n    \"NativeSharedObjectNotFoundException\",\n    \"FunctionCallException\",\n    \"Unable to find the native shared object\",\n    \"already released\",\n    \"disposed\",\n    \"deallocated\",\n    \"null reference\",\n    \"JSI\",\n    \"Hermes\",\n  ],\n  network: [\n    \"NetworkError\",\n    \"Failed to fetch\",\n    \"ERR_NETWORK\",\n    \"ERR_INTERNET_DISCONNECTED\",\n    \"ECONNREFUSED\",\n    \"ETIMEDOUT\",\n    \"network_error\",\n    \"offline\",\n    \"no internet\",\n    \"connection failed\",\n  ],\n  decode: [\"decode\", \"codec\", \"unsupported format\", \"invalid video\", \"corrupted\", \"malformed\", \"ERR_VIDEO_DECODE\"],\n  source: [\"404\", \"403\", \"401\", \"not found\", \"forbidden\", \"unauthorized\", \"invalid url\", \"source not available\"],\n  permission: [\"permission denied\", \"not allowed\", \"access denied\", \"unauthorized\", \"forbidden\"],\n  rateLimit: [\"rate limit\", \"too many requests\", \"429\", \"throttled\", \"quota exceeded\"],\n  playback: [\"playback\", \"stalled\", \"buffering\", \"stuck\", \"not playing\", \"player error\"],\n  memory: [\"out of memory\", \"memory\", \"allocation failed\", \"OOM\", \"memory leak\"],\n};\n\n// Error recovery strategies\nexport interface ErrorRecoveryStrategy {\n  type: \"immediate\" | \"delayed\" | \"manual\" | \"fallback\" | \"none\";\n  retryConfig?: RetryConfig;\n  fallbackAction?: () => Promise<void>;\n  userMessage?: string;\n  requiresUserAction?: boolean;\n  canAutoRecover?: boolean;\n}\n\n// Error context for better debugging\nexport interface ErrorContext {\n  timestamp: number;\n  videoId?: string;\n  source?: string;\n  playerState?: string;\n  networkStatus?: boolean;\n  deviceInfo?: {\n    platform: string;\n    version: string;\n    isHermes: boolean;\n  };\n  previousErrors?: BaseVideoError[];\n}\n\n// Error metrics for tracking\nexport interface ErrorMetrics {\n  errorCode: VideoErrorCode;\n  count: number;\n  lastOccurrence: number;\n  recoveryAttempts: number;\n  recoverySuccesses: number;\n  averageRecoveryTime?: number;\n}\n\nclass VideoErrorAnalyzer {\n  private static errorHistory: Map<string, ErrorMetrics> = new Map();\n  private static errorPatternCache: Map<string, VideoErrorCode> = new Map();\n\n  /**\n   * Detect the specific type of video error from an unknown error\n   */\n  static detectVideoErrorType(error: unknown): VideoErrorCode {\n    if (!error) return VideoErrorCode.UNKNOWN;\n\n    const errorStr = this.getErrorString(error);\n\n    // Check cache first\n    const cached = this.errorPatternCache.get(errorStr);\n    if (cached) return cached;\n\n    // Check each pattern category\n    for (const [category, patterns] of Object.entries(ERROR_PATTERNS)) {\n      if (this.matchesPatterns(errorStr, patterns)) {\n        const errorCode = this.categoryToErrorCode(category);\n        this.errorPatternCache.set(errorStr, errorCode);\n        return errorCode;\n      }\n    }\n\n    return VideoErrorCode.UNKNOWN;\n  }\n\n  /**\n   * Create a recovery strategy based on error type and context\n   */\n  static createErrorRecoveryStrategy(error: BaseVideoError, context?: ErrorContext): ErrorRecoveryStrategy {\n    const metrics = this.getErrorMetrics(error.code);\n    const severity = error.severity || VideoErrorSeverity.ERROR;\n\n    // Check if too many failures\n    if (metrics.count > 10 && metrics.recoverySuccesses < 2) {\n      return {\n        type: \"none\",\n        userMessage: \"This issue appears to be persistent. Please try again later.\",\n        requiresUserAction: true,\n        canAutoRecover: false,\n      };\n    }\n\n    switch (error.code) {\n      case VideoErrorCode.DISPOSAL_ERROR:\n      case VideoErrorCode.DISPOSAL_FAILED:\n      case VideoErrorCode.DISPOSAL_TIMEOUT:\n        return {\n          type: \"immediate\",\n          retryConfig: {\n            maxRetries: 3,\n            initialDelay: 100,\n            maxDelay: 1000,\n            backoffFactor: 2,\n          },\n          canAutoRecover: true,\n        };\n\n      case VideoErrorCode.NETWORK_ERROR:\n      case VideoErrorCode.CONNECTION_FAILED:\n        return {\n          type: context?.networkStatus === false ? \"manual\" : \"delayed\",\n          retryConfig: {\n            maxRetries: 5,\n            initialDelay: 2000,\n            maxDelay: 30000,\n            backoffFactor: 2,\n            shouldRetry: () => context?.networkStatus !== false,\n          },\n          userMessage: \"Connection issue. Retrying...\",\n          canAutoRecover: true,\n        };\n\n      case VideoErrorCode.RATE_LIMITED:\n        return {\n          type: \"delayed\",\n          retryConfig: {\n            maxRetries: 3,\n            initialDelay: 30000, // Start with 30 second delay\n            maxDelay: 120000,\n            backoffFactor: 2,\n          },\n          userMessage: \"Too many requests. Please wait a moment.\",\n          canAutoRecover: true,\n        };\n\n      case VideoErrorCode.SOURCE_NOT_FOUND:\n      case VideoErrorCode.SOURCE_INVALID:\n        return {\n          type: \"fallback\",\n          fallbackAction: async () => {\n            // Fallback video loading logic\n            console.log(\"Loading fallback video source\");\n          },\n          userMessage: \"Video not available. Loading alternative...\",\n          canAutoRecover: true,\n        };\n\n      case VideoErrorCode.DECODE_ERROR:\n      case VideoErrorCode.UNSUPPORTED_FORMAT:\n        return {\n          type: \"fallback\",\n          userMessage: \"This video format is not supported.\",\n          requiresUserAction: false,\n          canAutoRecover: false,\n        };\n\n      case VideoErrorCode.PERMISSION_DENIED:\n      case VideoErrorCode.UNAUTHORIZED:\n        return {\n          type: \"manual\",\n          userMessage: \"You don't have permission to view this content.\",\n          requiresUserAction: true,\n          canAutoRecover: false,\n        };\n\n      case VideoErrorCode.PLAYBACK_STALLED:\n      case VideoErrorCode.BUFFERING_TIMEOUT:\n        return {\n          type: \"immediate\",\n          retryConfig: {\n            maxRetries: 3,\n            initialDelay: 1000,\n            maxDelay: 5000,\n            backoffFactor: 1.5,\n          },\n          userMessage: \"Video is buffering...\",\n          canAutoRecover: true,\n        };\n\n      default:\n        return {\n          type: severity === VideoErrorSeverity.CRITICAL ? \"manual\" : \"delayed\",\n          retryConfig: {\n            maxRetries: 3,\n            initialDelay: 1000,\n            maxDelay: 10000,\n            backoffFactor: 2,\n          },\n          canAutoRecover: severity !== VideoErrorSeverity.CRITICAL,\n        };\n    }\n  }\n\n  /**\n   * Check if an error is recoverable\n   */\n  static isRecoverableError(error: BaseVideoError): boolean {\n    const nonRecoverableCodes = [\n      VideoErrorCode.UNSUPPORTED_FORMAT,\n      VideoErrorCode.PERMISSION_DENIED,\n      VideoErrorCode.UNAUTHORIZED,\n      VideoErrorCode.DECODE_ERROR,\n    ];\n\n    if (nonRecoverableCodes.includes(error.code)) {\n      return false;\n    }\n\n    // Check severity\n    if (error.severity === VideoErrorSeverity.CRITICAL) {\n      return false;\n    }\n\n    // Check error history\n    const metrics = this.getErrorMetrics(error.code);\n    if (metrics.count > 20 && metrics.recoverySuccesses === 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Detect Hermes-specific errors\n   */\n  static isHermesError(error: unknown): boolean {\n    const errorStr = this.getErrorString(error);\n    const hermesPatterns = [\n      \"HermesInternal\",\n      \"JSI\",\n      \"jsi::\",\n      \"Hermes\",\n      \"FunctionCallException\",\n      \"NativeSharedObjectNotFoundException\",\n    ];\n\n    return this.matchesPatterns(errorStr, hermesPatterns);\n  }\n\n  /**\n   * Get error severity based on type and frequency\n   */\n  static getErrorSeverity(error: BaseVideoError): VideoErrorSeverity {\n    const metrics = this.getErrorMetrics(error.code);\n\n    // Escalate severity based on frequency\n    if (metrics.count > 10) {\n      if (error.severity === VideoErrorSeverity.WARNING) {\n        return VideoErrorSeverity.ERROR;\n      }\n      if (error.severity === VideoErrorSeverity.ERROR) {\n        return VideoErrorSeverity.CRITICAL;\n      }\n    }\n\n    return error.severity || VideoErrorSeverity.ERROR;\n  }\n\n  /**\n   * Create error with context\n   */\n  static createContextualError(code: VideoErrorCode, message: string, context?: ErrorContext): BaseVideoError {\n    const severity = this.getDefaultSeverity(code);\n    const recoverable = this.isRecoverableCode(code);\n    const metadata: Record<string, unknown> | undefined = context\n      ? {\n          context,\n        }\n      : undefined;\n\n    const error = this.instantiateError(code, message, metadata, recoverable, severity);\n\n    if (context) {\n      (error as any).context = context;\n    }\n\n    this.recordError(error);\n    return error;\n  }\n\n  /**\n   * Extract error context for debugging\n   */\n  static extractErrorContext(error: unknown): ErrorContext {\n    const timestamp = Date.now();\n    const context: ErrorContext = { timestamp };\n\n    if (error && typeof error === \"object\") {\n      const err = error as any;\n\n      // Extract common properties\n      if (err.videoId) context.videoId = err.videoId;\n      if (err.source) context.source = err.source;\n      if (err.playerState) context.playerState = err.playerState;\n      if (err.networkStatus !== undefined) context.networkStatus = err.networkStatus;\n\n      // Add device info\n      const platformInfo = (globalThis as { Platform?: { OS?: unknown; Version?: unknown } }).Platform;\n      context.deviceInfo = {\n        platform: typeof platformInfo?.OS === \"string\" ? (platformInfo.OS as string) : \"unknown\",\n        version: typeof platformInfo?.Version === \"number\" ? String(platformInfo.Version as number) : \"unknown\",\n        isHermes: this.isHermesRuntime(),\n      };\n\n      // Extract stack trace info if available\n      if (err.stack) {\n        const stack = String(err.stack);\n        // Parse relevant info from stack\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Get recovery suggestions for users\n   */\n  static getRecoverySuggestions(error: BaseVideoError): string[] {\n    const suggestions: string[] = [];\n\n    switch (error.code) {\n      case VideoErrorCode.NETWORK_ERROR:\n      case VideoErrorCode.CONNECTION_FAILED:\n        suggestions.push(\n          \"Check your internet connection\",\n          \"Try switching between Wi-Fi and mobile data\",\n          \"Restart the app\",\n        );\n        break;\n\n      case VideoErrorCode.PLAYBACK_STALLED:\n      case VideoErrorCode.BUFFERING_TIMEOUT:\n        suggestions.push(\n          \"Wait for the video to buffer\",\n          \"Try lowering video quality\",\n          \"Close other apps to free up resources\",\n        );\n        break;\n\n      case VideoErrorCode.SOURCE_NOT_FOUND:\n        suggestions.push(\"This video may have been removed\", \"Try refreshing the feed\", \"Check back later\");\n        break;\n\n      case VideoErrorCode.RATE_LIMITED:\n        suggestions.push(\n          \"You've made too many requests\",\n          \"Wait a few minutes before trying again\",\n          \"Avoid rapid scrolling through videos\",\n        );\n        break;\n\n      default:\n        suggestions.push(\n          \"Try again in a moment\",\n          \"Restart the app if the problem persists\",\n          \"Contact support if this continues\",\n        );\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Track error patterns for optimization\n   */\n  static analyzeErrorPatterns(): {\n    mostFrequent: VideoErrorCode[];\n    recentTrend: \"increasing\" | \"decreasing\" | \"stable\";\n    recommendations: string[];\n  } {\n    const now = Date.now();\n    const recentWindow = 5 * 60 * 1000; // 5 minutes\n\n    // Get most frequent errors\n    const sortedErrors = Array.from(this.errorHistory.entries())\n      .sort((a, b) => b[1].count - a[1].count)\n      .slice(0, 5)\n      .map(([code]) => code as VideoErrorCode);\n\n    // Analyze recent trend\n    const recentErrors = Array.from(this.errorHistory.values()).filter((m) => now - m.lastOccurrence < recentWindow);\n\n    const trend = this.calculateTrend(recentErrors);\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(sortedErrors, trend);\n\n    return {\n      mostFrequent: sortedErrors,\n      recentTrend: trend,\n      recommendations,\n    };\n  }\n\n  // Helper methods\n  private static getErrorString(error: unknown): string {\n    if (!error) return \"\";\n    if (typeof error === \"string\") return error.toLowerCase();\n    if (error instanceof Error) return (error.message + \" \" + error.stack).toLowerCase();\n    if (typeof error === \"object\" && \"message\" in error) {\n      return String((error as any).message).toLowerCase();\n    }\n    return JSON.stringify(error).toLowerCase();\n  }\n\n  private static matchesPatterns(str: string, patterns: string[]): boolean {\n    return patterns.some((pattern) => str.includes(pattern.toLowerCase()));\n  }\n\n  private static categoryToErrorCode(category: string): VideoErrorCode {\n    const mapping: Record<string, VideoErrorCode> = {\n      disposal: VideoErrorCode.DISPOSAL_ERROR,\n      network: VideoErrorCode.NETWORK_ERROR,\n      decode: VideoErrorCode.DECODE_ERROR,\n      source: VideoErrorCode.SOURCE_NOT_FOUND,\n      permission: VideoErrorCode.PERMISSION_DENIED,\n      rateLimit: VideoErrorCode.RATE_LIMITED,\n      playback: VideoErrorCode.PLAYBACK_STALLED,\n      memory: VideoErrorCode.UNKNOWN,\n    };\n    return mapping[category] || VideoErrorCode.UNKNOWN;\n  }\n\n  private static instantiateError(\n    code: VideoErrorCode,\n    message: string,\n    metadata: Record<string, unknown> | undefined,\n    recoverable: boolean,\n    severity: VideoErrorSeverity,\n  ): BaseVideoError {\n    switch (code) {\n      case VideoErrorCode.DISPOSAL_ERROR:\n      case VideoErrorCode.DISPOSAL_FAILED:\n      case VideoErrorCode.DISPOSAL_TIMEOUT:\n        return new VideoDisposalError(message, metadata, severity);\n\n      case VideoErrorCode.NETWORK_ERROR:\n      case VideoErrorCode.CONNECTION_FAILED:\n      case VideoErrorCode.LOAD_FAILED:\n        return new VideoNetworkError(message, metadata, severity);\n\n      case VideoErrorCode.PLAYBACK_FAILED:\n      case VideoErrorCode.PLAYBACK_STALLED:\n      case VideoErrorCode.BUFFERING_TIMEOUT:\n        return new VideoPlaybackError(code, message, metadata, severity);\n\n      case VideoErrorCode.PERMISSION_DENIED:\n      case VideoErrorCode.UNAUTHORIZED:\n        return new VideoPermissionError(message, metadata);\n\n      case VideoErrorCode.SOURCE_NOT_FOUND:\n      case VideoErrorCode.SOURCE_INVALID:\n        return new VideoSourceError(code, message, metadata, severity);\n\n      default:\n        return new BaseVideoError(code, message, metadata, recoverable, severity);\n    }\n  }\n\n  private static getDefaultSeverity(code: VideoErrorCode): VideoErrorSeverity {\n    const criticalCodes: VideoErrorCode[] = [VideoErrorCode.PERMISSION_DENIED, VideoErrorCode.UNAUTHORIZED];\n\n    const warningCodes: VideoErrorCode[] = [\n      VideoErrorCode.DISPOSAL_TIMEOUT,\n      VideoErrorCode.BUFFERING_TIMEOUT,\n      VideoErrorCode.DISPOSAL_ERROR,\n    ];\n\n    if (criticalCodes.includes(code)) return VideoErrorSeverity.CRITICAL;\n    if (warningCodes.includes(code)) return VideoErrorSeverity.WARNING;\n    return VideoErrorSeverity.ERROR;\n  }\n\n  private static isRecoverableCode(code: VideoErrorCode): boolean {\n    const nonRecoverable: VideoErrorCode[] = [\n      VideoErrorCode.PERMISSION_DENIED,\n      VideoErrorCode.UNAUTHORIZED,\n      VideoErrorCode.SOURCE_NOT_FOUND,\n      VideoErrorCode.SOURCE_INVALID,\n      VideoErrorCode.DISPOSAL_ERROR,\n      VideoErrorCode.DISPOSAL_FAILED,\n    ];\n\n    return !nonRecoverable.includes(code);\n  }\n\n  private static getErrorMetrics(code: VideoErrorCode): ErrorMetrics {\n    let metrics = this.errorHistory.get(code);\n    if (!metrics) {\n      metrics = {\n        errorCode: code,\n        count: 0,\n        lastOccurrence: 0,\n        recoveryAttempts: 0,\n        recoverySuccesses: 0,\n      };\n      this.errorHistory.set(code, metrics);\n    }\n    return metrics;\n  }\n\n  private static recordError(error: BaseVideoError): void {\n    const metrics = this.getErrorMetrics(error.code);\n    metrics.count++;\n    metrics.lastOccurrence = Date.now();\n\n    // Cleanup old cache entries if too large\n    if (this.errorPatternCache.size > 1000) {\n      const entriesToDelete = Array.from(this.errorPatternCache.keys()).slice(0, 500);\n      entriesToDelete.forEach((key) => this.errorPatternCache.delete(key));\n    }\n  }\n\n  private static isHermesRuntime(): boolean {\n    try {\n      // @ts-ignore\n      return typeof HermesInternal !== \"undefined\";\n    } catch {\n      return false;\n    }\n  }\n\n  private static calculateTrend(recentErrors: ErrorMetrics[]): \"increasing\" | \"decreasing\" | \"stable\" {\n    if (recentErrors.length < 2) return \"stable\";\n\n    // Simple trend analysis based on error frequency\n    const firstHalf = recentErrors.slice(0, Math.floor(recentErrors.length / 2));\n    const secondHalf = recentErrors.slice(Math.floor(recentErrors.length / 2));\n\n    const firstHalfCount = firstHalf.reduce((sum, m) => sum + m.count, 0);\n    const secondHalfCount = secondHalf.reduce((sum, m) => sum + m.count, 0);\n\n    if (secondHalfCount > firstHalfCount * 1.2) return \"increasing\";\n    if (secondHalfCount < firstHalfCount * 0.8) return \"decreasing\";\n    return \"stable\";\n  }\n\n  private static generateRecommendations(frequentErrors: VideoErrorCode[], trend: string): string[] {\n    const recommendations: string[] = [];\n\n    if (trend === \"increasing\") {\n      recommendations.push(\"Error rate is increasing. Consider investigating recent changes.\");\n    }\n\n    if (frequentErrors.includes(VideoErrorCode.NETWORK_ERROR)) {\n      recommendations.push(\"Implement offline mode or better network error handling\");\n    }\n\n    if (frequentErrors.includes(VideoErrorCode.DISPOSAL_ERROR)) {\n      recommendations.push(\"Review video player disposal logic for memory leaks\");\n    }\n\n    if (frequentErrors.includes(VideoErrorCode.RATE_LIMITED)) {\n      recommendations.push(\"Implement request throttling or caching\");\n    }\n\n    return recommendations;\n  }\n}\n\n// Exported functions for backward compatibility and ease of use\nexport const isDisposalError = (error: unknown): boolean => {\n  const code = VideoErrorAnalyzer.detectVideoErrorType(error);\n  return [VideoErrorCode.DISPOSAL_ERROR, VideoErrorCode.DISPOSAL_FAILED, VideoErrorCode.DISPOSAL_TIMEOUT].includes(\n    code,\n  );\n};\n\nexport const detectVideoErrorType = (error: unknown): VideoErrorCode => {\n  return VideoErrorAnalyzer.detectVideoErrorType(error);\n};\n\nexport const createErrorRecoveryStrategy = (error: BaseVideoError, context?: ErrorContext): ErrorRecoveryStrategy => {\n  return VideoErrorAnalyzer.createErrorRecoveryStrategy(error, context);\n};\n\nexport const isRecoverableError = (error: BaseVideoError): boolean => {\n  return VideoErrorAnalyzer.isRecoverableError(error);\n};\n\nexport const isHermesError = (error: unknown): boolean => {\n  return VideoErrorAnalyzer.isHermesError(error);\n};\n\nexport const getErrorSeverity = (error: BaseVideoError): VideoErrorSeverity => {\n  return VideoErrorAnalyzer.getErrorSeverity(error);\n};\n\nexport const createContextualError = (\n  code: VideoErrorCode,\n  message: string,\n  context?: ErrorContext,\n): BaseVideoError => {\n  return VideoErrorAnalyzer.createContextualError(code, message, context);\n};\n\nexport const extractErrorContext = (error: unknown): ErrorContext => {\n  return VideoErrorAnalyzer.extractErrorContext(error);\n};\n\nexport const getRecoverySuggestions = (error: BaseVideoError): string[] => {\n  return VideoErrorAnalyzer.getRecoverySuggestions(error);\n};\n\nexport const analyzeErrorPatterns = () => {\n  return VideoErrorAnalyzer.analyzeErrorPatterns();\n};\n\n// Error rate limiting utility\nexport class ErrorRateLimiter {\n  private errorCounts: Map<string, number> = new Map();\n  private windowStart: number = Date.now();\n  private readonly windowSize: number = 60000; // 1 minute\n  private readonly maxErrors: number = 10;\n\n  shouldReportError(errorKey: string): boolean {\n    this.cleanupOldEntries();\n\n    const count = this.errorCounts.get(errorKey) || 0;\n    if (count >= this.maxErrors) {\n      return false;\n    }\n\n    this.errorCounts.set(errorKey, count + 1);\n    return true;\n  }\n\n  private cleanupOldEntries(): void {\n    const now = Date.now();\n    if (now - this.windowStart > this.windowSize) {\n      this.errorCounts.clear();\n      this.windowStart = now;\n    }\n  }\n}\n\n// Error correlation utility\nexport class ErrorCorrelator {\n  private errorSequences: {\n    errors: VideoErrorCode[];\n    timestamp: number;\n  }[] = [];\n\n  recordError(code: VideoErrorCode): void {\n    const now = Date.now();\n    const recentSequence = this.errorSequences[this.errorSequences.length - 1];\n\n    if (recentSequence && now - recentSequence.timestamp < 5000) {\n      recentSequence.errors.push(code);\n      recentSequence.timestamp = now;\n    } else {\n      this.errorSequences.push({\n        errors: [code],\n        timestamp: now,\n      });\n\n      // Keep only recent sequences\n      if (this.errorSequences.length > 100) {\n        this.errorSequences = this.errorSequences.slice(-50);\n      }\n    }\n  }\n\n  findCorrelatedErrors(code: VideoErrorCode): VideoErrorCode[] {\n    const correlations: Map<VideoErrorCode, number> = new Map();\n\n    for (const sequence of this.errorSequences) {\n      const index = sequence.errors.indexOf(code);\n      if (index !== -1) {\n        // Check errors that appear before and after\n        for (let i = Math.max(0, index - 2); i <= Math.min(sequence.errors.length - 1, index + 2); i++) {\n          if (i !== index) {\n            const relatedCode = sequence.errors[i];\n            correlations.set(relatedCode, (correlations.get(relatedCode) || 0) + 1);\n          }\n        }\n      }\n    }\n\n    // Return codes that appear together frequently\n    return Array.from(correlations.entries())\n      .filter(([_, count]) => count > 2)\n      .sort((a, b) => b[1] - a[1])\n      .map(([code]) => code);\n  }\n}\n\n// Global instances\nexport const errorRateLimiter = new ErrorRateLimiter();\nexport const errorCorrelator = new ErrorCorrelator();\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoPlayerDisposal.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VideoPlayerCapabilities' is defined but never used.","line":1,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VideoErrorCode' is defined but never used.","line":2,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { VideoPlayerInterface, VideoPlayerState, VideoPlayerCapabilities } from \"../types/videoPlayer\";\nimport { VideoDisposalError, VideoErrorCode, VideoErrorSeverity } from \"../types/videoErrors\";\nimport { isHermesError } from \"./videoErrors\";\n\n// Disposal strategy types\nexport enum DisposalStrategy {\n  GRACEFUL = \"graceful\",\n  FORCED = \"forced\",\n  EMERGENCY = \"emergency\",\n  SCHEDULED = \"scheduled\",\n}\n\n// Disposal configuration\nexport interface DisposalConfig {\n  strategy: DisposalStrategy;\n  timeout: number;\n  retries: number;\n  fallbackStrategy?: DisposalStrategy;\n  enableMemoryCleanup: boolean;\n  enableHermesWorkarounds: boolean;\n}\n\n// Disposal result\nexport interface DisposalResult {\n  success: boolean;\n  strategy: DisposalStrategy;\n  duration: number;\n  retryCount: number;\n  error?: VideoDisposalError;\n  memoryFreed?: number;\n}\n\n// Player disposal state\ninterface PlayerDisposalState {\n  playerId: string;\n  player: VideoPlayerInterface;\n  state: VideoPlayerState;\n  disposalAttempts: number;\n  lastDisposalTime?: number;\n  isDisposed: boolean;\n  hermesCompatibilityMode: boolean;\n}\n\n// Memory tracking\ninterface MemoryMetrics {\n  beforeDisposal: number;\n  afterDisposal: number;\n  freed: number;\n  timestamp: number;\n}\n\n// Disposal queue item\ninterface QueuedDisposal {\n  playerId: string;\n  player: VideoPlayerInterface;\n  config: DisposalConfig;\n  priority: number;\n  scheduledTime?: number;\n}\n\n/**\n * Enhanced video player disposal utility with Hermes compatibility\n */\nexport class EnhancedVideoPlayerDisposal {\n  private static instance: EnhancedVideoPlayerDisposal;\n\n  private readonly DISPOSAL_TIMEOUT_DEFAULT = 500;\n  private readonly DISPOSAL_TIMEOUT_HERMES = 1000;\n  private readonly DISPOSAL_TIMEOUT_EMERGENCY = 100;\n  private readonly MAX_DISPOSAL_ATTEMPTS = 3;\n  private readonly MEMORY_CLEANUP_DELAY = 100;\n  private readonly DISPOSAL_QUEUE_CHECK_INTERVAL = 1000;\n\n  private disposalStates: Map<string, PlayerDisposalState>;\n  private disposalQueue: QueuedDisposal[];\n  private memoryMetrics: MemoryMetrics[];\n  private isHermesRuntime: boolean;\n  private queueProcessor?: NodeJS.Timeout;\n  private disposalInProgress: Set<string>;\n\n  private constructor() {\n    this.disposalStates = new Map();\n    this.disposalQueue = [];\n    this.memoryMetrics = [];\n    this.isHermesRuntime = this.detectHermesRuntime();\n    this.disposalInProgress = new Set();\n\n    // Start queue processor\n    this.startQueueProcessor();\n\n    // Monitor memory periodically\n    this.startMemoryMonitoring();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): EnhancedVideoPlayerDisposal {\n    if (!EnhancedVideoPlayerDisposal.instance) {\n      EnhancedVideoPlayerDisposal.instance = new EnhancedVideoPlayerDisposal();\n    }\n    return EnhancedVideoPlayerDisposal.instance;\n  }\n\n  /**\n   * Dispose a video player with advanced strategies\n   */\n  async disposePlayer(\n    playerId: string,\n    player: VideoPlayerInterface,\n    config?: Partial<DisposalConfig>,\n  ): Promise<DisposalResult> {\n    const fullConfig = this.getFullConfig(config);\n    const startTime = Date.now();\n\n    // Check if already disposing\n    if (this.disposalInProgress.has(playerId)) {\n      return {\n        success: false,\n        strategy: fullConfig.strategy,\n        duration: 0,\n        retryCount: 0,\n        error: new VideoDisposalError(\"Disposal already in progress\", undefined, VideoErrorSeverity.WARNING),\n      };\n    }\n\n    // Mark as in progress\n    this.disposalInProgress.add(playerId);\n\n    // Get or create disposal state\n    const disposalState = this.getOrCreateDisposalState(playerId, player);\n\n    try {\n      // Attempt disposal with the specified strategy\n      const result = await this.attemptDisposal(disposalState, fullConfig);\n\n      // Record metrics\n      if (result.success && fullConfig.enableMemoryCleanup) {\n        result.memoryFreed = await this.performMemoryCleanup(playerId);\n      }\n\n      // Update state\n      disposalState.isDisposed = result.success;\n      disposalState.lastDisposalTime = Date.now();\n\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        strategy: fullConfig.strategy,\n        duration: Date.now() - startTime,\n        retryCount: disposalState.disposalAttempts,\n        error: new VideoDisposalError(`Disposal failed: ${error}`, undefined, VideoErrorSeverity.ERROR),\n      };\n    } finally {\n      this.disposalInProgress.delete(playerId);\n    }\n  }\n\n  /**\n   * Schedule disposal for later execution\n   */\n  scheduleDisposal(\n    playerId: string,\n    player: VideoPlayerInterface,\n    delay: number,\n    config?: Partial<DisposalConfig>,\n  ): void {\n    const fullConfig = this.getFullConfig({\n      ...config,\n      strategy: DisposalStrategy.SCHEDULED,\n    });\n\n    const queueItem: QueuedDisposal = {\n      playerId,\n      player,\n      config: fullConfig,\n      priority: this.calculateDisposalPriority(fullConfig.strategy),\n      scheduledTime: Date.now() + delay,\n    };\n\n    this.disposalQueue.push(queueItem);\n    this.disposalQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Dispose multiple players in batch\n   */\n  async disposeBatch(\n    players: { playerId: string; player: VideoPlayerInterface }[],\n    config?: Partial<DisposalConfig>,\n  ): Promise<Map<string, DisposalResult>> {\n    const results = new Map<string, DisposalResult>();\n    const batchConfig = this.getFullConfig(config);\n\n    // Process in parallel with concurrency limit\n    const concurrencyLimit = 5;\n    const chunks = this.chunkArray(players, concurrencyLimit);\n\n    for (const chunk of chunks) {\n      const chunkResults = await Promise.all(\n        chunk.map(({ playerId, player }) =>\n          this.disposePlayer(playerId, player, batchConfig).then((result) => ({ playerId, result })),\n        ),\n      );\n\n      chunkResults.forEach(({ playerId, result }) => {\n        results.set(playerId, result);\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Attempt disposal with the specified strategy\n   */\n  private async attemptDisposal(state: PlayerDisposalState, config: DisposalConfig): Promise<DisposalResult> {\n    const startTime = Date.now();\n    let retryCount = 0;\n\n    for (let attempt = 0; attempt < config.retries; attempt++) {\n      retryCount = attempt + 1;\n      state.disposalAttempts++;\n\n      try {\n        // Apply strategy-specific disposal\n        await this.applyDisposalStrategy(state.player, config.strategy, config.timeout);\n\n        // Verify disposal if in Hermes environment\n        if (config.enableHermesWorkarounds && this.isHermesRuntime) {\n          await this.verifyHermesDisposal(state.player);\n        }\n\n        return {\n          success: true,\n          strategy: config.strategy,\n          duration: Date.now() - startTime,\n          retryCount,\n        };\n      } catch (error) {\n        if (attempt === config.retries - 1) {\n          // Last attempt failed, try fallback strategy\n          if (config.fallbackStrategy && config.fallbackStrategy !== config.strategy) {\n            try {\n              await this.applyDisposalStrategy(state.player, config.fallbackStrategy, this.DISPOSAL_TIMEOUT_EMERGENCY);\n\n              return {\n                success: true,\n                strategy: config.fallbackStrategy,\n                duration: Date.now() - startTime,\n                retryCount: retryCount + 1,\n              };\n            } catch (fallbackError) {\n              throw fallbackError;\n            }\n          }\n          throw error;\n        }\n\n        // Wait before retry with exponential backoff\n        await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, attempt)));\n      }\n    }\n\n    throw new Error(\"Disposal failed after all retries\");\n  }\n\n  /**\n   * Apply specific disposal strategy\n   */\n  private async applyDisposalStrategy(\n    player: VideoPlayerInterface,\n    strategy: DisposalStrategy,\n    timeout: number,\n  ): Promise<void> {\n    switch (strategy) {\n      case DisposalStrategy.GRACEFUL:\n        await this.gracefulDisposal(player, timeout);\n        break;\n\n      case DisposalStrategy.FORCED:\n        await this.forcedDisposal(player, timeout);\n        break;\n\n      case DisposalStrategy.EMERGENCY:\n        await this.emergencyDisposal(player);\n        break;\n\n      case DisposalStrategy.SCHEDULED:\n        await this.gracefulDisposal(player, timeout);\n        break;\n\n      default:\n        throw new Error(`Unknown disposal strategy: ${strategy}`);\n    }\n  }\n\n  /**\n   * Graceful disposal with proper cleanup\n   */\n  private async gracefulDisposal(player: VideoPlayerInterface, timeout: number): Promise<void> {\n    // Comment 5: For GRACEFUL, avoid aggressive prototype/property manipulation\n    const operations = [\n      () => this.pausePlayer(player),\n      () => this.mutePlayer(player),\n      () => this.releaseResources(player),\n      () => this.clearEventListeners(player),\n      // Don't finalize disposal for graceful strategy\n    ];\n\n    await this.executeWithTimeout(async () => {\n      for (const operation of operations) {\n        await operation();\n      }\n    }, timeout);\n  }\n\n  /**\n   * Forced disposal with aggressive cleanup\n   */\n  private async forcedDisposal(player: VideoPlayerInterface, timeout: number): Promise<void> {\n    await this.executeWithTimeout(async () => {\n      // Try to pause first\n      try {\n        await this.pausePlayer(player);\n      } catch {}\n\n      // Force release all resources\n      await this.forceReleaseResources(player);\n\n      // Comment 5: Only clear references for FORCED/EMERGENCY or Hermes\n      if (this.isHermesRuntime) {\n        await this.clearAllReferences(player);\n      }\n      await this.finalizeDisposal(player);\n    }, timeout);\n  }\n\n  /**\n   * Emergency disposal - immediate cleanup\n   */\n  private async emergencyDisposal(player: VideoPlayerInterface): Promise<void> {\n    try {\n      // Mark as disposed immediately\n      (player as any)._disposed = true;\n      (player as any)._emergencyDisposed = true;\n\n      // Nullify key properties\n      const keys = Object.keys(player);\n      for (const key of keys) {\n        try {\n          (player as any)[key] = null;\n        } catch {}\n      }\n    } catch {\n      // Ignore all errors in emergency disposal\n    }\n  }\n\n  /**\n   * Pause player safely\n   */\n  private async pausePlayer(player: VideoPlayerInterface): Promise<void> {\n    if (typeof player.pause === \"function\") {\n      await player.pause();\n    }\n  }\n\n  /**\n   * Mute player safely\n   */\n  private async mutePlayer(player: VideoPlayerInterface): Promise<void> {\n    if (typeof player.setMuted === \"function\") {\n      player.setMuted(true);\n    } else if (\"muted\" in player) {\n      (player as any).muted = true;\n    }\n  }\n\n  /**\n   * Release player resources\n   */\n  private async releaseResources(player: VideoPlayerInterface): Promise<void> {\n    const releaseMethods = [\"release\", \"stop\", \"dispose\", \"destroy\", \"cleanup\"];\n\n    for (const method of releaseMethods) {\n      if (typeof (player as any)[method] === \"function\") {\n        try {\n          await (player as any)[method]();\n        } catch (error) {\n          // Log but continue\n          if (__DEV__) {\n            console.debug(`Failed to call ${method}:`, error);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Force release all resources\n   */\n  private async forceReleaseResources(player: VideoPlayerInterface): Promise<void> {\n    await this.releaseResources(player);\n\n    // Additional aggressive cleanup\n    try {\n      // Clear video source\n      if (\"src\" in player) {\n        (player as any).src = null;\n      }\n      if (\"source\" in player) {\n        (player as any).source = null;\n      }\n\n      // Clear buffers\n      if (\"buffer\" in player) {\n        (player as any).buffer = null;\n      }\n\n      // Stop all media operations\n      if (typeof (player as any).abort === \"function\") {\n        (player as any).abort();\n      }\n    } catch {}\n  }\n\n  /**\n   * Clear event listeners\n   */\n  private async clearEventListeners(player: VideoPlayerInterface): Promise<void> {\n    if (typeof player.removeAllListeners === \"function\") {\n      player.removeAllListeners();\n    }\n\n    // Try common event removal methods\n    const eventMethods = [\"removeEventListener\", \"off\", \"unbind\"];\n    for (const method of eventMethods) {\n      if (typeof (player as any)[method] === \"function\") {\n        try {\n          (player as any)[method]();\n        } catch {}\n      }\n    }\n  }\n\n  /**\n   * Clear all references\n   */\n  private async clearAllReferences(player: VideoPlayerInterface): Promise<void> {\n    // Comment 5: Restrict aggressive cleanup to FORCED/EMERGENCY and Hermes\n    // Set prototype to null to break reference chains\n    try {\n      Object.setPrototypeOf(player, null);\n    } catch {}\n\n    // Clear all enumerable properties\n    const keys = Object.keys(player);\n    for (const key of keys) {\n      try {\n        delete (player as any)[key];\n      } catch {}\n    }\n  }\n\n  /**\n   * Finalize disposal\n   */\n  private async finalizeDisposal(player: VideoPlayerInterface): Promise<void> {\n    // Mark as disposed\n    (player as any)._disposed = true;\n    (player as any)._disposedAt = Date.now();\n  }\n\n  /**\n   * Verify Hermes disposal\n   */\n  private async verifyHermesDisposal(player: VideoPlayerInterface): Promise<void> {\n    // Hermes-specific verification\n    if (this.isHermesRuntime) {\n      // Wait for GC\n      await new Promise((resolve) => setTimeout(resolve, this.MEMORY_CLEANUP_DELAY));\n\n      // Check if player is still accessible\n      try {\n        const test = (player as any)._disposed;\n        if (!test) {\n          throw new Error(\"Hermes disposal verification failed\");\n        }\n      } catch (error) {\n        if (isHermesError(error)) {\n          // Expected - player is properly disposed\n          return;\n        }\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Perform memory cleanup\n   */\n  private async performMemoryCleanup(playerId: string): Promise<number> {\n    const beforeMemory = this.getMemoryUsage();\n\n    // Force garbage collection if available\n    if (global.gc) {\n      global.gc();\n    }\n\n    // Wait for cleanup\n    await new Promise((resolve) => setTimeout(resolve, this.MEMORY_CLEANUP_DELAY));\n\n    const afterMemory = this.getMemoryUsage();\n    const freed = Math.max(0, beforeMemory - afterMemory);\n\n    // Record metrics\n    this.memoryMetrics.push({\n      beforeDisposal: beforeMemory,\n      afterDisposal: afterMemory,\n      freed,\n      timestamp: Date.now(),\n    });\n\n    // Clean up disposal state\n    this.disposalStates.delete(playerId);\n\n    return freed;\n  }\n\n  /**\n   * Process disposal queue\n   */\n  private async processDisposalQueue(): Promise<void> {\n    const now = Date.now();\n    const readyItems: QueuedDisposal[] = [];\n\n    // Find items ready for disposal\n    this.disposalQueue = this.disposalQueue.filter((item) => {\n      if (!item.scheduledTime || item.scheduledTime <= now) {\n        readyItems.push(item);\n        return false;\n      }\n      return true;\n    });\n\n    // Process ready items\n    for (const item of readyItems) {\n      if (!this.disposalInProgress.has(item.playerId)) {\n        this.disposePlayer(item.playerId, item.player, item.config);\n      }\n    }\n  }\n\n  /**\n   * Start queue processor\n   */\n  private startQueueProcessor(): void {\n    if (!this.queueProcessor) {\n      this.queueProcessor = setInterval(() => {\n        this.processDisposalQueue();\n      }, this.DISPOSAL_QUEUE_CHECK_INTERVAL);\n    }\n  }\n\n  /**\n   * Start memory monitoring\n   */\n  private startMemoryMonitoring(): void {\n    setInterval(() => {\n      this.cleanupOldMetrics();\n      this.analyzeMemoryTrends();\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Clean up old metrics\n   */\n  private cleanupOldMetrics(): void {\n    const cutoffTime = Date.now() - 24 * 60 * 60 * 1000; // 24 hours\n    this.memoryMetrics = this.memoryMetrics.filter((metric) => metric.timestamp > cutoffTime);\n  }\n\n  /**\n   * Analyze memory trends\n   */\n  private analyzeMemoryTrends(): void {\n    if (this.memoryMetrics.length < 10) return;\n\n    const recentMetrics = this.memoryMetrics.slice(-10);\n    const averageFreed = recentMetrics.reduce((sum, m) => sum + m.freed, 0) / recentMetrics.length;\n\n    if (averageFreed < 1000) {\n      // Less than 1KB freed on average - might indicate disposal issues\n      if (__DEV__) {\n        console.warn(\"Low memory freed during disposal - potential memory leak\");\n      }\n    }\n  }\n\n  /**\n   * Get or create disposal state\n   */\n  private getOrCreateDisposalState(playerId: string, player: VideoPlayerInterface): PlayerDisposalState {\n    let state = this.disposalStates.get(playerId);\n\n    if (!state) {\n      state = {\n        playerId,\n        player,\n        state: VideoPlayerState.Idle,\n        disposalAttempts: 0,\n        isDisposed: false,\n        hermesCompatibilityMode: this.isHermesRuntime,\n      };\n      this.disposalStates.set(playerId, state);\n    }\n\n    return state;\n  }\n\n  /**\n   * Get full disposal configuration\n   */\n  private getFullConfig(partial?: Partial<DisposalConfig>): DisposalConfig {\n    const defaultTimeout = this.isHermesRuntime ? this.DISPOSAL_TIMEOUT_HERMES : this.DISPOSAL_TIMEOUT_DEFAULT;\n\n    return {\n      strategy: DisposalStrategy.GRACEFUL,\n      timeout: defaultTimeout,\n      retries: this.MAX_DISPOSAL_ATTEMPTS,\n      fallbackStrategy: DisposalStrategy.FORCED,\n      enableMemoryCleanup: true,\n      enableHermesWorkarounds: this.isHermesRuntime,\n      ...partial,\n    };\n  }\n\n  /**\n   * Calculate disposal priority\n   */\n  private calculateDisposalPriority(strategy: DisposalStrategy): number {\n    switch (strategy) {\n      case DisposalStrategy.EMERGENCY:\n        return 0; // Highest priority\n      case DisposalStrategy.FORCED:\n        return 1;\n      case DisposalStrategy.GRACEFUL:\n        return 2;\n      case DisposalStrategy.SCHEDULED:\n        return 3; // Lowest priority\n      default:\n        return 99;\n    }\n  }\n\n  /**\n   * Execute with timeout\n   */\n  private async executeWithTimeout<T>(operation: () => Promise<T>, timeout: number): Promise<T> {\n    return Promise.race([\n      operation(),\n      new Promise<never>((_, reject) => {\n        setTimeout(() => {\n          reject(\n            new VideoDisposalError(`Operation timed out after ${timeout}ms`, undefined, VideoErrorSeverity.WARNING),\n          );\n        }, timeout);\n      }),\n    ]);\n  }\n\n  /**\n   * Detect Hermes runtime\n   */\n  private detectHermesRuntime(): boolean {\n    try {\n      // @ts-ignore\n      return typeof HermesInternal !== \"undefined\";\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get memory usage\n   */\n  private getMemoryUsage(): number {\n    try {\n      // React Native specific memory API\n      if ((global as any).performance?.memory) {\n        return (global as any).performance.memory.usedJSHeapSize || 0;\n      }\n\n      // Fallback to process memory if available\n      if (typeof process !== \"undefined\" && process.memoryUsage) {\n        return process.memoryUsage().heapUsed;\n      }\n    } catch {}\n\n    return 0;\n  }\n\n  /**\n   * Chunk array for batch processing\n   */\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  /**\n   * Get disposal statistics\n   */\n  getStatistics(): {\n    totalDisposals: number;\n    activeDisposals: number;\n    queuedDisposals: number;\n    averageMemoryFreed: number;\n    hermesMode: boolean;\n  } {\n    const totalDisposals = Array.from(this.disposalStates.values()).reduce(\n      (sum, state) => sum + state.disposalAttempts,\n      0,\n    );\n\n    const averageMemoryFreed =\n      this.memoryMetrics.length > 0\n        ? this.memoryMetrics.reduce((sum, m) => sum + m.freed, 0) / this.memoryMetrics.length\n        : 0;\n\n    return {\n      totalDisposals,\n      activeDisposals: this.disposalInProgress.size,\n      queuedDisposals: this.disposalQueue.length,\n      averageMemoryFreed,\n      hermesMode: this.isHermesRuntime,\n    };\n  }\n\n  /**\n   * Clear all disposal states\n   */\n  clearAll(): void {\n    this.disposalStates.clear();\n    this.disposalQueue = [];\n    this.memoryMetrics = [];\n    this.disposalInProgress.clear();\n  }\n\n  /**\n   * Stop queue processor\n   */\n  stopQueueProcessor(): void {\n    if (this.queueProcessor) {\n      clearInterval(this.queueProcessor);\n      this.queueProcessor = undefined;\n    }\n  }\n}\n\n// Export singleton instance\nexport const videoPlayerDisposal = EnhancedVideoPlayerDisposal.getInstance();\n\n// Export convenience functions\nexport async function disposeVideoPlayer(\n  playerId: string,\n  player: VideoPlayerInterface,\n  config?: Partial<DisposalConfig>,\n): Promise<DisposalResult> {\n  return videoPlayerDisposal.disposePlayer(playerId, player, config);\n}\n\nexport function scheduleVideoPlayerDisposal(\n  playerId: string,\n  player: VideoPlayerInterface,\n  delay: number,\n  config?: Partial<DisposalConfig>,\n): void {\n  videoPlayerDisposal.scheduleDisposal(playerId, player, delay, config);\n}\n\nexport async function disposeVideoPlayersBatch(\n  players: { playerId: string; player: VideoPlayerInterface }[],\n  config?: Partial<DisposalConfig>,\n): Promise<Map<string, DisposalResult>> {\n  return videoPlayerDisposal.disposeBatch(players, config);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/videoTestRunner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uploadVideoToSupabase' is defined but never used.","line":9,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logSmokeTestResults' is defined but never used.","line":10,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive video pipeline test runner\n *\n * This utility provides a complete test suite for the video processing pipeline\n * including upload, processing, storage, and playback verification.\n */\n\nimport { supabase } from \"../lib/supabase\";\nimport { ensureSignedVideoUrl, uploadVideoToSupabase } from \"./storage\";\nimport { runVideoSmokeTest, logSmokeTestResults } from \"./__tests__/videoSmokeTest\";\n\ninterface TestResult {\n  testName: string;\n  success: boolean;\n  duration: number;\n  error?: string;\n  details?: any;\n}\n\ninterface VideoTestSuite {\n  results: TestResult[];\n  summary: {\n    total: number;\n    passed: number;\n    failed: number;\n    duration: number;\n  };\n}\n\n/**\n * Test video URI validation and path handling\n */\nasync function testVideoUriHandling(): Promise<TestResult> {\n  const startTime = Date.now();\n\n  try {\n    // Test storage path handling\n    const storagePath = \"confessions/test-user/test-video.mp4\";\n    const signedUrl = await ensureSignedVideoUrl(storagePath);\n\n    if (!signedUrl.signedUrl || !signedUrl.signedUrl.startsWith(\"https://\")) {\n      throw new Error(\"Invalid signed URL generated\");\n    }\n\n    // Test HTTP URL passthrough\n    const httpUrl = \"https://example.com/video.mp4\";\n    const passthroughUrl = await ensureSignedVideoUrl(httpUrl);\n\n    if (passthroughUrl.signedUrl !== httpUrl) {\n      throw new Error(\"HTTP URL passthrough failed\");\n    }\n\n    return {\n      testName: \"Video URI Handling\",\n      success: true,\n      duration: Date.now() - startTime,\n      details: {\n        storagePathHandled: true,\n        httpPassthrough: true,\n        signedUrlGenerated: true,\n      },\n    };\n  } catch (error) {\n    return {\n      testName: \"Video URI Handling\",\n      success: false,\n      duration: Date.now() - startTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test database video_uri column constraints\n */\nasync function testDatabaseConstraints(): Promise<TestResult> {\n  const startTime = Date.now();\n\n  try {\n    // Check that only storage paths are stored, not URLs\n    const { data, error } = await supabase\n      .from(\"confessions\")\n      .select(\"video_uri\")\n      .not(\"video_uri\", \"is\", null)\n      .limit(10);\n\n    if (error) throw error;\n\n    const httpUrls = (data || []).filter((row) => row.video_uri && row.video_uri.startsWith(\"http\"));\n\n    if (httpUrls.length > 0) {\n      throw new Error(`Found ${httpUrls.length} HTTP URLs in video_uri column`);\n    }\n\n    return {\n      testName: \"Database Constraints\",\n      success: true,\n      duration: Date.now() - startTime,\n      details: {\n        recordsChecked: data?.length || 0,\n        httpUrlsFound: httpUrls.length,\n        constraintValid: true,\n      },\n    };\n  } catch (error) {\n    return {\n      testName: \"Database Constraints\",\n      success: false,\n      duration: Date.now() - startTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test Edge Function response format\n */\nasync function testEdgeFunctionFormat(): Promise<TestResult> {\n  const startTime = Date.now();\n\n  try {\n    const { data, error } = await supabase.functions.invoke(\"process-video\", {\n      body: {\n        videoPath: \"confessions/test-user/test-video.mp4\",\n        options: {\n          enableFaceBlur: false,\n          enableVoiceChange: false,\n          enableTranscription: true,\n          quality: \"medium\",\n        },\n      },\n    });\n\n    if (error) throw error;\n\n    // Verify response structure\n    const requiredFields = [\"success\", \"storagePath\"];\n    const missingFields = requiredFields.filter((field) => !(field in data));\n\n    if (missingFields.length > 0) {\n      throw new Error(`Missing required fields: ${missingFields.join(\", \")}`);\n    }\n\n    // Verify no public URLs are returned\n    const hasPublicUrl =\n      \"processedVideoUrl\" in data && data.processedVideoUrl && data.processedVideoUrl.startsWith(\"http\");\n\n    if (hasPublicUrl) {\n      throw new Error(\"Edge Function returned public URL instead of storage path\");\n    }\n\n    return {\n      testName: \"Edge Function Format\",\n      success: true,\n      duration: Date.now() - startTime,\n      details: {\n        responseValid: true,\n        hasStoragePath: !!data.storagePath,\n        noPublicUrls: !hasPublicUrl,\n        success: data.success,\n      },\n    };\n  } catch (error) {\n    return {\n      testName: \"Edge Function Format\",\n      success: false,\n      duration: Date.now() - startTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Test bucket consistency across the pipeline\n */\nasync function testBucketConsistency(): Promise<TestResult> {\n  const startTime = Date.now();\n\n  try {\n    // Check that all video paths use confessions bucket\n    const { data, error } = await supabase\n      .from(\"confessions\")\n      .select(\"video_uri\")\n      .not(\"video_uri\", \"is\", null)\n      .limit(20);\n\n    if (error) throw error;\n\n    const videoPaths = (data || []).map((row) => row.video_uri).filter(Boolean) as string[];\n    const videosBucketPaths = videoPaths.filter((path) => path.startsWith(\"videos/\"));\n    const confessionsBucketPaths = videoPaths.filter((path) => path.startsWith(\"confessions/\"));\n\n    return {\n      testName: \"Bucket Consistency\",\n      success: true,\n      duration: Date.now() - startTime,\n      details: {\n        totalPaths: videoPaths.length,\n        videosBucket: videosBucketPaths.length,\n        confessionsBucket: confessionsBucketPaths.length,\n        migrationNeeded: videosBucketPaths.length > 0,\n      },\n    };\n  } catch (error) {\n    return {\n      testName: \"Bucket Consistency\",\n      success: false,\n      duration: Date.now() - startTime,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Run complete video pipeline test suite\n */\nexport async function runCompleteVideoTests(): Promise<VideoTestSuite> {\n  if (!__DEV__) {\n    return {\n      results: [],\n      summary: {\n        total: 0,\n        passed: 0,\n        failed: 0,\n        duration: 0,\n      },\n    };\n  }\n\n  const startTime = Date.now();\n  const results: TestResult[] = [];\n\n  console.log(\"\\n🧪 Starting Complete Video Pipeline Tests\");\n  console.log(\"==========================================\");\n\n  // Run all tests\n  const tests = [testVideoUriHandling, testDatabaseConstraints, testEdgeFunctionFormat, testBucketConsistency];\n\n  for (const test of tests) {\n    console.log(`\\n⏳ Running ${test.name}...`);\n    const result = await test();\n    results.push(result);\n\n    const icon = result.success ? \"✅\" : \"❌\";\n    console.log(`${icon} ${result.testName} (${result.duration}ms)`);\n\n    if (result.error) {\n      console.log(`   Error: ${result.error}`);\n    }\n\n    if (result.details) {\n      console.log(`   Details:`, result.details);\n    }\n  }\n\n  // Run smoke tests\n  console.log(\"\\n⏳ Running Smoke Tests...\");\n  const smokeTestResults = await runVideoSmokeTest();\n\n  // Convert smoke test results to our format\n  smokeTestResults.results.forEach((smokeResult) => {\n    results.push({\n      testName: `Smoke: ${smokeResult.step}`,\n      success: smokeResult.success,\n      duration: 0, // Smoke tests don't track individual durations\n      error: smokeResult.error,\n      details: smokeResult.details,\n    });\n  });\n\n  const totalDuration = Date.now() - startTime;\n  const passed = results.filter((r) => r.success).length;\n  const failed = results.length - passed;\n\n  const summary = {\n    total: results.length,\n    passed,\n    failed,\n    duration: totalDuration,\n  };\n\n  console.log(\"\\n📊 Test Summary\");\n  console.log(\"================\");\n  console.log(`Total Tests: ${summary.total}`);\n  console.log(`Passed: ${summary.passed}`);\n  console.log(`Failed: ${summary.failed}`);\n  console.log(`Duration: ${summary.duration}ms`);\n  console.log(`Success Rate: ${((passed / results.length) * 100).toFixed(1)}%`);\n\n  if (failed === 0) {\n    console.log(\"\\n🎉 All tests passed! Video pipeline is working correctly.\");\n  } else {\n    console.log(`\\n⚠️  ${failed} test(s) failed. Check the details above.`);\n  }\n\n  console.log(\"==========================================\\n\");\n\n  return {\n    results,\n    summary,\n  };\n}\n\n/**\n * Quick health check for video pipeline\n */\nexport async function quickVideoHealthCheck(): Promise<boolean> {\n  if (!__DEV__) return true;\n\n  try {\n    // Test basic signed URL generation\n    const testPath = \"confessions/health-check/test.mp4\";\n    const signedUrl = await ensureSignedVideoUrl(testPath);\n\n    if (!signedUrl.signedUrl || !signedUrl.signedUrl.startsWith(\"https://\")) {\n      return false;\n    }\n\n    // Test database connectivity\n    const { error } = await supabase.from(\"confessions\").select(\"id\").limit(1);\n\n    return !error;\n  } catch {\n    return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/iamabillionaire/Downloads/SupaSecret/src/utils/viewsCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]